

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="let const  没什么新的东西 就不写了 不知道为什么这本书后面都用的 var 字符串与正则表达式  更好的 Unicode 支持关于 UnicodeUnicode使用16位二进制来存储文字。我们将一个16位的二进制编码叫做一个码元（Code Unit），Unicode编码范围在0 - 2^16。也就是我们所说的占一个字节。 由于技术的发展，Unicode对文字编码进行了扩展，将某些文字扩展">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解ES6">
<meta property="og:url" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="let const  没什么新的东西 就不写了 不知道为什么这本书后面都用的 var 字符串与正则表达式  更好的 Unicode 支持关于 UnicodeUnicode使用16位二进制来存储文字。我们将一个16位的二进制编码叫做一个码元（Code Unit），Unicode编码范围在0 - 2^16。也就是我们所说的占一个字节。 由于技术的发展，Unicode对文字编码进行了扩展，将某些文字扩展">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721192756233.png">
<meta property="og:image" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721192733715.png">
<meta property="og:image" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721204939237.png">
<meta property="og:image" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220722162911548.png">
<meta property="og:image" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220722201416156.png">
<meta property="og:image" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220724205823067.png">
<meta property="og:image" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726144254499.png">
<meta property="og:image" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726152259722.png">
<meta property="og:image" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726152623070.png">
<meta property="og:image" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726161901329.png">
<meta property="article:published_time" content="2022-07-21T05:57:00.000Z">
<meta property="article:modified_time" content="2022-07-26T09:04:32.185Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="字符串">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721192756233.png">
  
  
  
  <title>深入理解ES6 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"qPzYEpTngSrzQtV1XpsPSmPm-gzGzoHsz","app_key":"kf4lqne4FqonWhpUQzS1Ffrx","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>JY BLOG</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解ES6"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-07-21 13:57" pubdate>
          July 21, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          215 mins
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span>次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">深入理解ES6</h1>
            
            <div class="markdown-body">
              
              <h1 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721192756233.png" srcset="/img/loading.gif" lazyload class="" title="image-20220721192756233">

<p>没什么新的东西 就不写了</p>
<p>不知道为什么这本书后面都用的 var</p>
<h1 id="字符串与正则表达式"><a href="#字符串与正则表达式" class="headerlink" title="字符串与正则表达式"></a>字符串与正则表达式</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721192733715.png" srcset="/img/loading.gif" lazyload class="" title="image-20220721192733715">

<h2 id="更好的-Unicode-支持"><a href="#更好的-Unicode-支持" class="headerlink" title="更好的 Unicode 支持"></a>更好的 Unicode 支持</h2><h3 id="关于-Unicode"><a href="#关于-Unicode" class="headerlink" title="关于 Unicode"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yongG/p/12153646.html">关于 Unicode</a></h3><p>Unicode使用16位二进制来存储文字。我们将一个16位的二进制编码叫做一个码元（Code Unit），Unicode编码范围在0 - 2^16。也就是我们所说的占一个字节。</p>
<p>由于技术的发展，Unicode对文字编码进行了扩展，将某些文字扩展到了32位（占用两个码元），并且，将某个文字对应的二进制数字叫做码点（Code Point），Unicode编码范围在0 - 2^32，占2个字节。</p>
<p>特别要注意，码点可以是一个码元，也可以是两个码元。</p>
<p>字符串的length属性返回的是码元。所以在对一些字符串如果要处理长度的时候要注意这一点。</p>
<p><strong>ES6 为了支持 Unicode 的发展也新增了一些方法</strong></p>
<h3 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h3><p>可以在给定字符串中按位置提取 Unicode 代码点。该方法接受的是<strong>码元位置</strong>而非字符位置，并返回一个整数值。</p>
<p><strong>charCodeAt 的优化版</strong></p>
<p>charCodeAt是根据码元来匹配，codePointAt是根据码点来进行匹配的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;𘚠a&quot;</span> ;		<span class="hljs-comment">// 特殊字符显示不出来</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 55329</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 56992</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 97</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 100000</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 56992</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 97</span><br></code></pre></td></tr></table></figure>



<p><strong>判断字符包含了一个还是两个码元</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 16 位字符的上边界用十六进制表示就是 FFFF ，因此任何大于该数字的代码点必须用两个码元（共 32 位）来表示。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">is32Bit</span>(<span class="hljs-params">c</span>) &#123;<br>    <span class="hljs-keyword">return</span> c.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>) &gt; <span class="hljs-number">0xFFFF</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>String.fromCodePoint</strong></p>
<p>codePointAt() 的逆操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCodePoint</span>(<span class="hljs-number">134071</span>))   <span class="hljs-comment">// 𠮷</span><br></code></pre></td></tr></table></figure>

<p>codePointAt &lt;—&gt; fromCodePoint</p>
<p>charCodeAt &lt;—&gt; fromCharCode</p>
<h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h3><p>开发国际化应用时，这个方法很重要</p>
<p>在比较字符串时，必须被标准化为同一种形式</p>
<h3 id="正则表达式-u-标志"><a href="#正则表达式-u-标志" class="headerlink" title="正则表达式 u 标志"></a>正则表达式 u 标志</h3><p>正则表达式假定单个字符由一个16位的码元表示。为了解决这个问题，ES6 定义了用于处理 Unicode 的 u 标志</p>
<p>当一个正则表达式设置了 u 标志后看，工作表模式将切换到针对字符，而不是针对码元</p>
<p><strong>计算码点数量</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">codePointLength</span>(<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = text.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[\s\S]/gu</span>)<br>    <span class="hljs-keyword">return</span> result ? result.<span class="hljs-property">length</span> : <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>判断是否支持 u 标志</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasRegExpU</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> pattern = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="字符串的其他改动"><a href="#字符串的其他改动" class="headerlink" title="字符串的其他改动"></a>字符串的其他改动</h2><h3 id="识别子字符串的方法"><a href="#识别子字符串的方法" class="headerlink" title="识别子字符串的方法"></a>识别子字符串的方法</h3><p><strong>includes()</strong> 方法，在给定文本存在于字符串中的任意位置时会返回 true ，否则返回false ；</p>
<p><strong>startsWith()</strong> 方法，在给定文本出现在字符串起始处时返回 true ，否则返回 false ；</p>
<p><strong>endsWith()</strong> 方法，在给定文本出现在字符串结尾处时返回 true ，否则返回 false 。</p>
<p>每个方法都接受两个参数：<strong>需要搜索的文本</strong>，以及<strong>可选的搜索起始位置索引</strong>。</p>
<p>当提供了第二个参数时， includes() 与 startsWith() 方法会从该索引位置开始尝试匹配；而<strong>endsWith() 方法会将字符串长度减去该参数</strong>，以此为起点开始尝试匹配。</p>
<p>当第二个参数未提供时， includes() 与 startsWith() 方法会从字符串起始处开始查找，而 endsWith() 方法则从尾部开始。实际上，第二个参数减少了搜索字符串的次数。以下是使用这些方法的演示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&quot;Hello world!&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;Hello&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;!&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;o&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;o&quot;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;world!&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;x&quot;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>



<p><strong>若你需要找到它们在另一个字符串中的确切位置，则需要使用 indexOf() 和 lastIndexOf() 。</strong></p>
<p>如果向 startsWith() 、 endsWith() 或 includes() 方法传入了正则表达式,会抛出错误。</p>
<p>而 indexOf() 以及 lastIndexOf() 会将正则表达式转换为字符串并搜索它。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>ES6 还为字符串添加了一个 repeat() 方法，它接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;x&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// &quot;xxx&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;hellohello&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;abc&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;abcabcabcabc&quot;</span><br></code></pre></td></tr></table></figure>



<h2 id="正则表达式的其他改动"><a href="#正则表达式的其他改动" class="headerlink" title="正则表达式的其他改动"></a>正则表达式的其他改动</h2><h3 id="y-标志"><a href="#y-标志" class="headerlink" title="y 标志"></a>y 标志</h3><p>y 标志影响正则表达式搜索时的粘连（ sticky ）属性，它表示从正则表达式的 lastIndex 属性值的位置开始检索字符串中的匹配字符。如果在该位置没有匹配成功，那么正则表达式将停止检索</p>
<h3 id="复制正则表达式"><a href="#复制正则表达式" class="headerlink" title="复制正则表达式"></a>复制正则表达式</h3><p>允许复制正则表达式时修改标志</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re1 = <span class="hljs-regexp">/ab/i</span>,<br><span class="hljs-comment">// ES5 中会抛出错误, ES6 中可用</span><br>re2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(re1, <span class="hljs-string">&quot;g&quot;</span>);	<span class="hljs-comment">// 如果没有第二个参数, re2 就会拥有与 re1 相同的标志。</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &quot;/ab/i&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re2.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &quot;/ab/g&quot;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;ab&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;ab&quot;</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;AB&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;AB&quot;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>



<h3 id="flags-属性"><a href="#flags-属性" class="headerlink" title="flags 属性"></a>flags 属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/ab/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re.<span class="hljs-property">source</span>); <span class="hljs-comment">// &quot;ab&quot; ES5就有</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re.<span class="hljs-property">flags</span>); <span class="hljs-comment">// &quot;g&quot;</span><br></code></pre></td></tr></table></figure>



<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p><strong>模板字符串解决了什么问题：</strong></p>
<p>多行字符串：针对多行字符串的形式概念；</p>
<p>基本的字符串格式化：将字符串部分替换为已存在的变量值的能力；</p>
<p>HTML 转义：能转换字符串以便将其安全插入到 HTML 中的能力。</p>
<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = <span class="hljs-string">`Multiline</span><br><span class="hljs-string">string`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <br><span class="hljs-comment">// &quot;Multiline</span><br><span class="hljs-comment">// string&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">length</span>); <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure>

<p>反引号之内的所有空白符都是字符串的一部分，因此需要留意缩进</p>
<p>如果让多行文本保持合适的缩进很重要，考虑将多行模板字面量的第一行空置并在此后进行缩进</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> html = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;div&gt;</span><br><span class="hljs-string">&lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="hljs-string">&lt;/div&gt;`</span>.<span class="hljs-title function_">trim</span>();<br></code></pre></td></tr></table></figure>



<h3 id="制造替代位"><a href="#制造替代位" class="headerlink" title="制造替代位"></a>制造替代位</h3><p>${任意表达式}</p>
<p>模板字面量本身也是 JS 表达式，因此可嵌套</p>
<h3 id="标签化模板"><a href="#标签化模板" class="headerlink" title="标签化模板"></a>标签化模板</h3><p>一个模板标签（ template tag ）能对模板字面量进行转换并返回最终的字符串值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = tag<span class="hljs-string">`Hello world`</span>;<br></code></pre></td></tr></table></figure>



<p>标签（ tag ）是函数，它被调用时接收需要处理的模板字面量数据。标签所接收的数据被划分为独立片段，并且必须将它们组合起来以创建结果。第一个参数是个数组，包含被 JS 解释过的字面量字符串，随后的参数是每个替换位的解释值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span>(<span class="hljs-params">literals, ...substitutions</span>) &#123;<br>    <span class="hljs-comment">// 返回一个字符串</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>内置的标签 String.raw()</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message1 = <span class="hljs-string">`Multiline\nstring`</span>,<br>message2 = <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`Multiline\nstring`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message1);<br><span class="hljs-comment">// &quot;Multiline</span><br><span class="hljs-comment">// string&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message2); <span class="hljs-comment">// &quot;Multiline\\nstring&quot;</span><br></code></pre></td></tr></table></figure>

<p>内部实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">raw</span>(<span class="hljs-params">literals, ...substitutions</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">// 仅使用 substitution 的元素数量来进行循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; substitutions.<span class="hljs-property">length</span>; i++) &#123;<br>        result += literals.<span class="hljs-property">raw</span>[i]; <span class="hljs-comment">// 改为使用原始值</span><br>        result += substitutions[i];<br>    &#125;<br>    <span class="hljs-comment">// 添加最后一个字面量</span><br>    result += literals.<span class="hljs-property">raw</span>[literals.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">let</span> message = raw<span class="hljs-string">`Multiline\nstring`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// &quot;Multiline\\nstring&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">length</span>); <span class="hljs-comment">// 17</span><br></code></pre></td></tr></table></figure>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721204939237.png" srcset="/img/loading.gif" lazyload class="" title="image-20220721204939237">

<h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>参数默认值的存在触发了 arguments 对象与具名参数的分离</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 非严格模式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mixArgs</span>(<span class="hljs-params">first, second = <span class="hljs-string">&quot;b&quot;</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>);          <span class="hljs-comment">// 1</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// true  </span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// false</span><br>    first = <span class="hljs-string">&quot;c&quot;</span>;<br>    second = <span class="hljs-string">&quot;d&quot;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// false</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// false</span><br>&#125;<br><span class="hljs-title function_">mixArgs</span>(<span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>参数默认值可以使用表达式</p>
<p>参数默认值存在暂时性死区</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">first = second, second</span>) &#123;<br>    <span class="hljs-keyword">return</span> first + second;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 抛出错误</span><br></code></pre></td></tr></table></figure>



<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>…具名参数</p>
<p>是包含传递给函数的其余参数的一个数组</p>
<p>函数的 length 属性用于指示剧名参数的数量，而剩余参数对其毫无影响</p>
<p><strong>剩余参数的限制条件：</strong></p>
<p>一、函数只能有一个剩余参数，并且它必须被放在最后。</p>
<p>二、剩余参数不能在对象字面量的 setter 属性中使用。（对象字面量的 setter 被限定只能使用单个参数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> object = &#123;<br><span class="hljs-comment">// 语法错误：不能在 setter 中使用剩余参数</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">...value</span>) &#123;<br>        <span class="hljs-comment">// 一些操作</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<p><strong>设计剩余参数是为了替代 ES 中的 arguments</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkArgs</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args.<span class="hljs-property">length</span>);			<span class="hljs-comment">// 2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>);		<span class="hljs-comment">// 2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args[<span class="hljs-number">0</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);	<span class="hljs-comment">// a a</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args[<span class="hljs-number">1</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);	<span class="hljs-comment">// b b</span><br>&#125;<br><span class="hljs-title function_">checkArgs</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br></code></pre></td></tr></table></figure>



<p><strong>拓展运算符</strong></p>
<p>拓展运算符常和剩余参数一起使用</p>
<p>以一个例子为例，查找数组最大值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES5及以前</span><br><span class="hljs-keyword">let</span> values = [<span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">75</span>, <span class="hljs-number">100</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Math</span>, values)); <span class="hljs-comment">// 100</span><br><br><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">let</span> values = [<span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">75</span>, <span class="hljs-number">100</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...values)); <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure>



<h2 id="ES6-的名称属性"><a href="#ES6-的名称属性" class="headerlink" title="ES6 的名称属性"></a>ES6 的名称属性</h2><p>匿名函数使得调试困难，因此 ES6 给所有函数添加了 name 属性。name 仅用于在调试时获得函数的相关信息，不能获取对函数的引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">var</span> doAnotherThing = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doSomething.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;doSomething&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doAnotherThing.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;doAnotherThing&quot;</span><br></code></pre></td></tr></table></figure>



<p><strong>特殊情况</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> doSomething = <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingElse</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">firstName</span>() &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Nicholas&quot;</span><br>	&#125;,<br>    <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doSomething.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;doSomethingElse&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">sayName</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;sayName&quot;</span><br><span class="hljs-keyword">var</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(person, <span class="hljs-string">&quot;firstName&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">get</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;get firstName&quot;</span><br></code></pre></td></tr></table></figure>

<p>getter 函数会有 get 前缀，setter 函数会有 set 前缀</p>
<p>getter 与 setter 函数都必须使用 Object.getOwnPropertyDescriptor 来检索</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> doSomething = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doSomething.<span class="hljs-title function_">bind</span>().<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;bound doSomething&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>()).<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;anonymous&quot;</span><br></code></pre></td></tr></table></figure>

<p>使用 bind() 创建的函数会有 bound 前缀</p>
<p>使用 Function 构造器创建的函数会有 anonymous 前缀</p>
<h2 id="明确函数的双重用途"><a href="#明确函数的双重用途" class="headerlink" title="明确函数的双重用途"></a>明确函数的双重用途</h2><p>一般函数 和 构造函数(new)，构造函数名首字母大写</p>
<p>JS 为函数提供了两个内部方法，[[Call]] 和 [[Construct]]</p>
<p>函数未使用 new 调用时，[[call]] 方法执行，运行函数体</p>
<p>函数使用 new 调用时，[[Construct]] 方法调用，创建一个新的对象，并且以该对象为 this 执行函数体</p>
<p>拥有 [[Constructor]] 方法的函数被称为构造器</p>
<p><strong>判断调用的是什么方法</strong></p>
<p>当 [[Constructor]] 被调用时，new.target 为 new 调用的构造函数</p>
<p>当 [[Call]] 被调用时，new.target 为 undefiend</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>)			<span class="hljs-comment">// [Function: Person]</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 使用 new</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You must use new with Person.&quot;</span>)<br>    &#125;   <br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><span class="hljs-keyword">var</span> notAPerson = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">&quot;Michael&quot;</span>); <span class="hljs-comment">// 出错！</span><br></code></pre></td></tr></table></figure>



<h2 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h2><p>块级函数会被提升到所在代码块的顶部</p>
<p>而使用 let 的函数表达式不会</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>没有 this 、 super 、 arguments ，也没有 new.target 绑定。this 、 super 、arguments 、以及函数内部的 new.target 的值由所在的、最靠近的非箭头函数来决定。</p>
<p>不能被使用 new 调用： 箭头函数没有 [[Construct]] 方法，因此不能被用为构造函数，使用 new 调用箭头函数会抛出错误。</p>
<p>没有原型： 既然不能对箭头函数使用 new ，那么它也不需要原型，也就是没有prototype 属性。</p>
<p>不能更改 this ： this 的值在函数内部不能被修改，在函数的整个生命周期内其值会保持不变。</p>
<p>没有 arguments 对象： 既然箭头函数没有 arguments 绑定，你必须依赖于具名参数或剩余参数来访问函数的参数。</p>
<p>不允许重复的具名参数： 箭头函数不允许拥有重复的具名参数，无论是否在严格模式下；而相对来说，传统函数只有在严格模式下才禁止这种重复。</p>
<p>箭头函数也拥有 name 属性，并且遵循与其他函数相同的规则</p>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>这是一项引擎优化，改变了尾部调用的系统。</p>
<p>尾调用（tail call ）指的是调用函数的语句是另一个函数的最后语句</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-title function_">doSomethingElse</span>(); <span class="hljs-comment">// 尾调用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 ES5 引擎中实现的尾调用，其处理就像其他函数调用一样：<strong>一个新的栈帧</strong>（ stack frame）被创建并推到调用栈之上，用于表示该次函数调用。这意味着<strong>之前每个栈帧都被保留在内存中，当调用栈太大时会出问题。</strong></p>
<p>ES6 在严格模式下力图为特定尾调用减少调用栈的大小（非严格模式的尾调用则保持不变）。<strong>当满足以下条件时，尾调用优化会清除当前栈帧并再次利用它，而不是为尾调用创建新的栈帧</strong>：</p>
<ol>
<li>尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）；</li>
<li>进行尾调用的函数在尾调用返回结果后不能做额外操作；</li>
<li>尾调用的结果作为当前函数的返回值。</li>
</ol>
<p><strong>尾调用优化主要是用在递归中</strong></p>
<p>不考虑尾调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    	<span class="hljs-comment">// 未被优化：在返回之后还要执行乘法</span><br>    	<span class="hljs-keyword">return</span> n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>考虑尾调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 未被优化：在返回之后还要执行乘法</span><br>        <span class="hljs-keyword">return</span> n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在重写的 factorial() 函数中，添加了第二个参数 p ，其默认值为 1 。 p 参数保存着前一次乘法的结果，因此下一次的结果就能在进行函数调用之前被算出。</p>
<p><strong>尾调用优化是你在书写任意递归函数时都需要考虑的因素</strong>，因为它能提供显著的性能提升，尤其是被应用到计算复杂度很高的函数时。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220722162911548.png" srcset="/img/loading.gif" lazyload class="" title="image-20220722162911548">

<h2 id="需计算属性名"><a href="#需计算属性名" class="headerlink" title="需计算属性名"></a>需计算属性名</h2><p>方括号允许你将变量或字符串字面量指定为属性名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 变量</span><br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&quot;last name&quot;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-string">&quot;first name&quot;</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    [lastName]: <span class="hljs-string">&quot;Zakas&quot;</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;first name&quot;</span>]); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[lastName]); <span class="hljs-comment">// &quot;Zakas&quot;</span><br><br><span class="hljs-comment">// 字符串字面量</span><br><span class="hljs-keyword">var</span> suffix = <span class="hljs-string">&quot; name&quot;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    [<span class="hljs-string">&quot;first&quot;</span> + suffix]: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    [<span class="hljs-string">&quot;last&quot;</span> + suffix]: <span class="hljs-string">&quot;Zakas&quot;</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;first name&quot;</span>]); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;last name&quot;</span>]); <span class="hljs-comment">// &quot;Zakas&quot;</span><br></code></pre></td></tr></table></figure>



<h2 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h2><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>Object.is() 用来判断两个值是否相等，修复了 &#x3D;&#x3D;&#x3D; 的一些问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-number">0</span> == -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(+<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>



<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>用于混入对象</p>
<p>Object.assign() 方法接受任意数量的供应者，而接收者会按照供应者在参数中的顺序来依次接收它们的属性。这意味着在接收者中，第二个供应者的属性可能会覆盖第一个供应者的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> receiver = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(receiver,<br>    &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;js&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;file.js&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;css&quot;</span><br>    &#125;<br>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver.<span class="hljs-property">type</span>); <span class="hljs-comment">// &quot;css&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;file.js&quot;</span><br></code></pre></td></tr></table></figure>



<p><strong>由于 Object.assign() 使用赋值运算符，供应者的访问器属性就会转变成接收者的数据属性</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> receiver = &#123;&#125;,<br>supplier = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;file.js&quot;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(receiver, supplier);<br><br><span class="hljs-keyword">var</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(receiver, <span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">value</span>); <span class="hljs-comment">// &quot;file.js&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">get</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>



<h2 id="自有属性的枚举顺序"><a href="#自有属性的枚举顺序" class="headerlink" title="自有属性的枚举顺序"></a>自有属性的枚举顺序</h2><p>ES6 则严格定义了对象自有属性在被枚举时返回的顺序。</p>
<p>对 Object.getOwnPropertyNames() 与 Reflect.ownKeys 如何返回属性造成了影响，还同样影响了 Object.assign() 处理属性的顺序。</p>
<p><strong>自有属性枚举时基本顺序如下：</strong></p>
<ol>
<li>所有的数字类型键，按升序排列。</li>
<li>所有的字符串类型键，按被添加到对象的顺序排列。</li>
<li>所有的符号类型（详见第六章）键，也按添加顺序排列。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span><br>&#125;;<br><br>obj.<span class="hljs-property">d</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// &quot;012acbd&quot;</span><br></code></pre></td></tr></table></figure>

<p>数值类型的键会被合并并排序；字符串类型的键会跟在数值类型的键之后</p>
<p>for-in 循环的枚举顺序仍未被明确规定，因为并非所有的 JS 引擎都采用相同的方式。而 Object.keys() 和 JSON.stringify() 也使用了与 for-in 一样的枚举顺序。</p>
<h2 id="更强大的原型"><a href="#更强大的原型" class="headerlink" title="更强大的原型"></a>更强大的原型</h2><h3 id="修改对象的原型"><a href="#修改对象的原型" class="headerlink" title="修改对象的原型"></a><strong>修改对象的原型</strong></h3><p>直到 ES5 为止， JS 编程最重要的假定之一就是对象的原型在初始化完成后会保持不变。</p>
<p>ES6 通过添加 <strong>Object.setPrototypeOf()</strong> 方法而改变了这种假定，此方法允许你修改任意指定对象的原型。</p>
<p>它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h3><p>super 使得在对象原型上的功能调用变得更容易</p>
<p>super 是指向当前对象的原型的一个指针，实际上就是 Object.getPrototypeOf(this) 的值</p>
<h2 id="正式的“方法”定义"><a href="#正式的“方法”定义" class="headerlink" title="正式的“方法”定义"></a>正式的“方法”定义</h2><p>在 ES6 之前，“方法”的概念从未被正式定义，它此前仅指对象的函数属性（而非数据属性）。</p>
<p>ES6 则正式做出了定义：<strong>方法是一个拥有 [[HomeObject]] 内部属性的函数</strong>，此内部属性指向该方法所属的对象。</p>
<p>任何对 super 的引用都会使用 [[HomeObject]] 属性来判断要做什么。第一步是在 [[HomeObject]] 上调用 Object.getPrototypeOf() 来获取对原型的引用；接下来，在该原型上查找同名函数；最后，创建 this 绑定并调用该方法。</p>
<h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220722201416156.png" srcset="/img/loading.gif" lazyload class="" title="image-20220722201416156">

<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p><strong>当使用解构来配合 var 、 let 或 const 来声明变量时，必须提供初始化器</strong>（即等号右边的值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 语法错误！</span><br><span class="hljs-keyword">var</span> &#123; type, name &#125;;<br><br><span class="hljs-comment">// 语法错误！</span><br><span class="hljs-keyword">let</span> &#123; type, name &#125;;<br><br><span class="hljs-comment">// 语法错误！</span><br><span class="hljs-keyword">const</span> &#123; type, name &#125;;<br></code></pre></td></tr></table></figure>



<p><strong>解构赋值表达式的值为表达式右侧（在 &#x3D; 之后）的值。</strong></p>
<p>也就是说在任何期望有个值的位置都可以使用解构赋值表达式。例如，传递值给函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> node = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Identifier&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span><br>&#125;,<br>type = <span class="hljs-string">&quot;Literal&quot;</span>,<br>name = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outputInfo</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value === node); <span class="hljs-comment">// true</span><br>&#125;<br><br><span class="hljs-title function_">outputInfo</span>(&#123; type, name &#125; = node);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(type); <span class="hljs-comment">// &quot;Identifier&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// &quot;foo&quot;</span><br></code></pre></td></tr></table></figure>



<p><strong>可以给默认值，也可以给不同的变量名</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> node = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Identifier&quot;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">type</span>: localType, <span class="hljs-attr">name</span>: localName = <span class="hljs-string">&quot;bar&quot;</span>&#125; = node<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localType); <span class="hljs-comment">// &quot;Identifier&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localName); <span class="hljs-comment">// &quot;bar&quot;</span><br></code></pre></td></tr></table></figure>



<p><strong>嵌套解构</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> node = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Identifier&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,<br>        <span class="hljs-attr">loc</span>: &#123;<br>        <span class="hljs-attr">start</span>: &#123;<br>            <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">column</span>: <span class="hljs-number">1</span><br>        &#125;,<br>        <span class="hljs-attr">end</span>: &#123;<br>            <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">column</span>: <span class="hljs-number">4</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 提取 node.loc.start</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">loc</span>: &#123; <span class="hljs-attr">start</span>: localStart &#125;&#125; = node;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localStart.<span class="hljs-property">line</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localStart.<span class="hljs-property">column</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>



<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>与对象差别不大，也有默认值、嵌套解构等</p>
<p><strong>可以用来交换两个值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[a,b] = [b,a]<br></code></pre></td></tr></table></figure>



<p><strong>剩余项</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [ <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span> ];<br><span class="hljs-keyword">let</span> [ firstColor, ...restColors ] = colors;	<span class="hljs-comment">// restColors 是一个数组</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstColor); <span class="hljs-comment">// &quot;red&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restColors.<span class="hljs-property">length</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restColors[<span class="hljs-number">0</span>]); <span class="hljs-comment">// &quot;green&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restColors[<span class="hljs-number">1</span>]); <span class="hljs-comment">// &quot;blue&quot;</span><br></code></pre></td></tr></table></figure>



<p><strong>克隆数组</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在 ES6 中克隆数组</span><br><span class="hljs-keyword">let</span> colors = [ <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span> ];<br><span class="hljs-keyword">let</span> [ ...clonedColors ] = colors;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clonedColors); <span class="hljs-comment">//&quot;[red,green,blue]&quot;</span><br></code></pre></td></tr></table></figure>



<h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setCookie</span>(<span class="hljs-params">name, value,</span><br><span class="hljs-params">    &#123;</span><br><span class="hljs-params">        secure = <span class="hljs-literal">false</span>,</span><br><span class="hljs-params">        path = <span class="hljs-string">&quot;/&quot;</span>,</span><br><span class="hljs-params">        domain = <span class="hljs-string">&quot;example.com&quot;</span>,</span><br><span class="hljs-params">        expires = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.now() + <span class="hljs-number">360000000</span>)</span><br><span class="hljs-params">    &#125; = &#123;&#125;</span><br><span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>此代码中参数解构给每个属性都提供了默认值</strong>，所以你可以避免检查指定属性是否已被传入（以便在未传入时使用正确的值）。<strong>而整个解构的参数同样有一个默认值，即一个空对象</strong>，令该参数成为可选参数。</p>
<h1 id="Set-与-Map"><a href="#Set-与-Map" class="headerlink" title="Set 与 Map"></a>Set 与 Map</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220724205823067.png" srcset="/img/loading.gif" lazyload class="" title="image-20220724205823067">

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="判断值是否重复"><a href="#判断值是否重复" class="headerlink" title="判断值是否重复"></a>判断值是否重复</h3><p>Set 和 Map 不会使用强制类型转换来判断值是否重复，而是使用 Object.is() 方法（唯一例外时 +0 与 -0 被判断为相等)</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a><strong>forEach()</strong></h3><p>forEach() 方法会被传递一个回调函数，该回调接受三个参数：</p>
<ol>
<li>Set 中下个位置的值；</li>
<li>Set 中下个位置的键；</li>
<li>目标 Set 自身。</li>
</ol>
<p>因为 Set 中 每一项同时认定为键与值，因此 1 和 2 是相同的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, ownerSet</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot; &quot;</span> + value);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ownerSet === set);<br>&#125;);<br><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-literal">true</span><br><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>



<p>如果想在回调函数中使用 this ，你可以给 forEach() 传入一个 this 值作为第二个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-keyword">let</span> processor = &#123;<br>    <span class="hljs-title function_">output</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;,<br>    <span class="hljs-title function_">process</span>(<span class="hljs-params">dataSet</span>) &#123;<br>        dataSet.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">output</span>(value);<br>        &#125;, <span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;;<br>processor.<span class="hljs-title function_">process</span>(set);<br></code></pre></td></tr></table></figure>



<h2 id="Weak-Set"><a href="#Weak-Set" class="headerlink" title="Weak Set"></a>Weak Set</h2><p>只允许存储对象弱引用，不能存储基本类型。add(基本类型)会报错，has()或delete()会返回 false</p>
<p>Weak Set 不可迭代，不能用于 for-of 循环，没有 keys() 与 values() 方法，没有 forEach()，没有 size 属性</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map-的初始化"><a href="#Map-的初始化" class="headerlink" title="Map 的初始化"></a>Map 的初始化</h3><p><strong>你能将数组传递给 Map 构造器，以便使用数据来初始化一个 Map</strong> 。该<strong>数组中的每一项也必须是数组</strong>，内部数组的首个项会作为键，第二项则为对应值。因此整个Map 就被这些双项数组所填充。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>], [<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">25</span>]]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;age&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;age&quot;</span>)); <span class="hljs-comment">// 25</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>



<h2 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h2><p>所有键都必须是对象，都是弱引用，不会干扰垃圾回收。</p>
<p>没有 size 属性，没有 clear() 方法</p>
<p><strong>实际应用：在对象实例中存储私有数据</strong></p>
<p>在 ES6 中对象的所有属性都是公开的，因此若想让数据对于对象自身可访问、而在其他条件下不可访问，那么你就需要使用一些创造力。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 一般用 _属性 表示私有属性, 但并不能做到真正私有</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = name;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>        privateData.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, &#123; <span class="hljs-attr">name</span>: name &#125;);<br>    &#125;<br>    <br>    <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">name</span>;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Person</span>;<br>&#125;());<br></code></pre></td></tr></table></figure>

<p>当 Person 构造器被调用时，将 this 作为键在 Weak Map 上建立了一个入口，而包含私有信息的对象成为了对应的值，其中只存放了 name 属性。通过将 this 传递给 privateData.get() 方法，以获取值对象并访问其 name 属性， getName() 函数便能提取私有信息。这种技术让私有信息能够保持私有状态，并且当与之关联的对象实例被销毁时，私有信息也会被同时销毁。</p>
<h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><p><strong>意义：</strong></p>
<p>for 循环需要初始化变量以便追踪集合内的位置，而迭代器则以编程方式返回集合中的下一个项。</p>
<p><strong>作用：</strong></p>
<p>新增的 for-of 与它协同工作，扩展运算符（ … ）也使用了它，而它甚至还能让异步操作更易完成。</p>
<img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726144254499.png" srcset="/img/loading.gif" lazyload class="" title="image-20220726144254499">



<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="何为迭代器"><a href="#何为迭代器" class="headerlink" title="何为迭代器"></a>何为迭代器</h3><p>迭代器是被设计专用于迭代的对象，带有特定接口。所有的迭代器对象都拥有 next() 方法，会返回一个结果对象。该结果对象有两个属性：对应下一个值的 value ，以及一个布尔类型的 done ，其值为 true 时表示没有更多值可供使用。迭代器持有一个指向集合位置的内部指针，每当调用了 next() 方法，迭代器就会返回相应的下一个值。</p>
<p>若你在最后一个值返回后再调用 next() ，所返回的 done 属性值会是 true ，并且 value 属性值会是迭代器自身的返回值（ return value ，即使用 return 语句明确返回的值）。该“返回值”不是原数据集的一部分，却会成为相关数据的最后一个片段，或在迭代器未提供返回值的时候使用 undefined 。迭代器自身的返回值类似于函数的返回值，是向调用者返回信息的最后手段。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><h3 id="何为生成器"><a href="#何为生成器" class="headerlink" title="何为生成器"></a>何为生成器</h3><p>生成器（ generator ）是能返回一个迭代器的函数。生成器函数由放在 function 关键字之后的一个星号（ * ）来表示，并能使用新的 yield 关键字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 生成器</span><br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">// 生成器能像正规函数那样被调用，但会返回一个迭代器</span><br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>yield 关键字也是 ES6 新增的，指定了迭代器在被 next() 方法调用时应当按顺序返回的值，传递给 next() 的参数会成为 yield 语句的值。</p>
<p><strong>生成器函数最有意思的方面可能就是它们会在每个 yield 语句后停止执行，在函数中停止执行的能力是极其强大的。</strong></p>
<p>yield 关键字只能用在生成器内部，用于其他位置都时语法错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params">items</span>) &#123;<br>    items.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>        <span class="hljs-comment">// 语法错误</span><br>        <span class="hljs-keyword">yield</span> item + <span class="hljs-number">1</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 星号放置在 function 关键字与圆括号之间，是因为这个函数表达式是匿名的</span><br><span class="hljs-keyword">let</span> createIterator = <span class="hljs-keyword">function</span> *(items) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">yield</span> items[i];<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure>

<p>不能将箭头函数创建为生成器</p>
<h3 id="生成器对象方法"><a href="#生成器对象方法" class="headerlink" title="生成器对象方法"></a>生成器对象方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6 方法的速记法，只要在方法名之前加上一个星号*</span><br><span class="hljs-keyword">var</span> o = &#123;<br>    *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params">items</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">yield</span> items[i];<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> iterator = o.<span class="hljs-title function_">createIterator</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure>



<h2 id="可迭代对象与-for-of-循环"><a href="#可迭代对象与-for-of-循环" class="headerlink" title="可迭代对象与 for-of 循环"></a>可迭代对象与 for-of 循环</h2><p>可迭代对象时包含 Symbol.iterator 属性的对象。</p>
<p>ES6 中，所有的集合对象（数组、Set与Map）以及字符串都是可迭代对象。</p>
<p>生成器创建的所有迭代器都是可迭代对象，因为生成器默认就会为 Symbol.iterator 属性赋值。</p>
<p>可迭代对象被设计用于与 ES 新增的 for-of 循环配合使用。</p>
<p><strong>for-of 循环会调用当前对象的 Symbol.Iterator 方法（发生在后台），获取一个迭代器 iterator，然后在调用 iterator 的 next</strong></p>
<p>在不可迭代对象、 null 或 undefined 上使用 for-of 语句，会抛出错误。</p>
<h3 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h3><p>可以使用 Symbol.iterator 来访问对象上的默认迭代器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> iterator = values[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<br></code></pre></td></tr></table></figure>

<p>既然 Symbol.iterator 指定了默认迭代器，你就可以使用它来检测一个对象是否能进行迭代</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isIterable</span>(<span class="hljs-params">object</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> object[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] === <span class="hljs-string">&quot;function&quot;</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-string">&quot;Hello&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>())); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>())); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>())); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>())); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>for-of 循环在执行之前会做类似的检查，因此在遇到不可迭代对象是才会抛出错误</p>
<p>Weak Set 与 Weak Map 并未拥有内置的迭代器，使用弱引用意味着无法获知这些集合内部到底有多少个值，同时意味着没有方法可以迭代这些值。</p>
<h3 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h3><p>开发者自定义对象默认情况下不是可迭代对象，但你可以创建一个包含生成器的 Symbol.iterator 属性，让它们成为可迭代对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> collection = &#123;<br>    <span class="hljs-attr">items</span>: [],<br>    *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>) &#123;<br>            <span class="hljs-keyword">yield</span> item;<br>        &#125;<br>    &#125;<br>&#125;;<br><br>collection.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);<br>collection.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);<br>collection.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> collection) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>当使用 let-of 迭代 collection 时，会调用内部的 Symbol.iterator，从而迭代 this.items。</p>
<p><strong>只有当内置的迭代器无法满足你的需要时，才有必要创建自定义迭代器，这最常发生在定义你自己的对象或类时</strong></p>
<h2 id="内置的迭代器"><a href="#内置的迭代器" class="headerlink" title="内置的迭代器"></a>内置的迭代器</h2><h3 id="集合的迭代器"><a href="#集合的迭代器" class="headerlink" title="集合的迭代器"></a>集合的迭代器</h3><p>ES6 的三种集合对象：数组、Map、Set，都拥有如下迭代器</p>
<p>entries() ：返回一个包含键值对的迭代器；<br>values() ：返回一个包含集合中的值的迭代器；<br>keys() ：返回一个包含集合中的键的迭代器。</p>
<p><strong>集合的默认迭代器</strong></p>
<p>当 for-of 循环没有显式指定迭代器时，每种集合类型都有一个默认的迭代器供循环使用。</p>
<p><strong>values() 方法是数组与 Set 的默认迭代器，而 entries() 方法则是 Map 的默认迭代器。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [ <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span> ];<br><span class="hljs-keyword">let</span> tracking = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1234</span>, <span class="hljs-number">5678</span>, <span class="hljs-number">9012</span>]);<br><span class="hljs-keyword">let</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br>data.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;Understanding ES6&quot;</span>);<br>data.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;format&quot;</span>, <span class="hljs-string">&quot;print&quot;</span>);<br><br><span class="hljs-comment">// 与使用 colors.values() 相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> colors) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><br><span class="hljs-comment">// 与使用 tracking.values() 相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> tracking) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>&#125;<br><br><span class="hljs-comment">// 与使用 data.entries() 相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> data) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="字符串的迭代器"><a href="#字符串的迭代器" class="headerlink" title="字符串的迭代器"></a>字符串的迭代器</h3><p><strong>方括号表示法工作在码元而非字符上</strong>，因此它不能被用于正确访问双字节的字符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;A B&quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i &lt; message.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message[i]);<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">A</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">B</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<p>ES6 旨在为 Unicode 提供完全支持，字符串的默认迭代器就是解决字符串迭代问题的一种尝试。这样一来，<strong>借助字符串默认迭代器就能处理字符而不是码元。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;A B&quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> message) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">A</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">B</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<h3 id="NodeList-的迭代器"><a href="#NodeList-的迭代器" class="headerlink" title="NodeList 的迭代器"></a>NodeList 的迭代器</h3><p>随着默认迭代器被附加到 ES6 ， DOM 关于 NodeList 的规定也包含了一个默认迭代器（此规定在 HTML 规范而非 ES6 规范中），其表现方式与数组的默认迭代器一致。</p>
<h2 id="扩展运算符与非数组的可迭代对象"><a href="#扩展运算符与非数组的可迭代对象" class="headerlink" title="扩展运算符与非数组的可迭代对象"></a>扩展运算符与非数组的可迭代对象</h2><p>扩展运算符能作用于所有可迭代对象，并且会使用默认迭代器来判断需要使用哪些值。所有的值都从迭代器中被读取出来并插入数组，遵循迭代器返回值的顺序。</p>
<p>扩展运算符是将可迭代对象转换为数组的最简单方法。你可以将字符串转换为包含字符（而非码元）的数组，也能将浏览器中的 NodeList 对象转换为节点数组。</p>
<h2 id="迭代器高级功能"><a href="#迭代器高级功能" class="headerlink" title="迭代器高级功能"></a>迭代器高级功能</h2><h3 id="传递参数给迭代器"><a href="#传递参数给迭代器" class="headerlink" title="传递参数给迭代器"></a>传递参数给迭代器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 关键在于：传递给 next() 的参数会成为 yield 语句的值</span><br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> first = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> second = <span class="hljs-keyword">yield</span> first + <span class="hljs-number">2</span>; <span class="hljs-comment">// 4 + 2</span><br>    <span class="hljs-keyword">yield</span> second + <span class="hljs-number">3</span>; <span class="hljs-comment">// 5 + 3</span><br>&#125;<br><br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;&#123; value: 6, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// &quot;&#123; value: 8, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726152259722.png" srcset="/img/loading.gif" lazyload class="" title="image-20220726152259722">



<h3 id="在迭代器中抛出错误"><a href="#在迭代器中抛出错误" class="headerlink" title="在迭代器中抛出错误"></a>在迭代器中抛出错误</h3><p>能传递给迭代器的不仅是数据，还可以是错误条件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> first = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> second = <span class="hljs-keyword">yield</span> first + <span class="hljs-number">2</span>; <span class="hljs-comment">// yield 4 + 2 ，然后抛出错误</span><br>    <span class="hljs-keyword">yield</span> second + <span class="hljs-number">3</span>; <span class="hljs-comment">// 永不会被执行</span><br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;&#123; value: 6, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Boom&quot;</span>))); <span class="hljs-comment">// 从生成器中抛出了错误</span><br></code></pre></td></tr></table></figure>

<img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726152623070.png" srcset="/img/loading.gif" lazyload class="" title="image-20220726152623070">



<p><strong>可以在内部使用 try…catch 捕获错误</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> first = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> second;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        second = <span class="hljs-keyword">yield</span> first + <span class="hljs-number">2</span>; <span class="hljs-comment">// yield 4 + 2 ，然后抛出错误</span><br>    &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>        second = <span class="hljs-number">6</span>; <span class="hljs-comment">// 当出错时，给变量另外赋值</span><br>    &#125;<br>    <span class="hljs-keyword">yield</span> second + <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;&#123; value: 6, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Boom&quot;</span>))); <span class="hljs-comment">// &quot;&#123; value: 9, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>将 next() 与 throw() 都当作迭代器的指令，会有助于思考。</p>
<p>next() 方法指示迭代器继续执行（可能会带着给定的值），而 throw() 方法则指示迭代器通过抛出一个错误继续执行。<strong>在调用点之后会发生什么，根据生成器内部的代码来决定。</strong></p>
<h3 id="生成器的-return-语句"><a href="#生成器的-return-语句" class="headerlink" title="生成器的 return 语句"></a>生成器的 return 语句</h3><p><strong>return 会终止后续的程序</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure>



<p><strong>return 可以指定返回值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 42, done: true &#125;&quot; 非常特殊，value 不为 undefined，done 为 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>扩展运算符与 for-of 循环会忽略 return 语句所指定的任意值。</strong>一旦它们看到 done的值为 true ，它们就会停止操作而不会读取对应的 value 值。不过，在生成器进行委托时，迭代器的返回值会非常有用。</p>
<h3 id="生成器委托"><a href="#生成器委托" class="headerlink" title="生成器委托"></a>生成器委托</h3><p>一些情况下，将两个迭代器的值合并在一起会更有用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createNumberIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createColorIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;red&quot;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;green&quot;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createCombinedIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> *<span class="hljs-title function_">createNumberIterator</span>();<br>    <span class="hljs-keyword">yield</span> *<span class="hljs-title function_">createColorIterator</span>();<br>    <span class="hljs-keyword">yield</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">var</span> iterator = <span class="hljs-title function_">createCombinedIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 2, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: &quot;red&quot;, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: &quot;green&quot;, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: true, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure>



<h2 id="异步任务运行"><a href="#异步任务运行" class="headerlink" title="异步任务运行"></a>异步任务运行</h2><p><strong>由于生成器能让你在执行过程中有效地暂停代码操作，它就开启了与异步编程相关的许多可能性。</strong></p>
<p>由于 yield 能停止运行，并在重新开始运行前等待 next() 方法被调用，你就可以在没有回调函数的情况下实现异步调用。</p>
<p><strong>传统异步操作</strong></p>
<p>调用一个包含回调的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;config.json&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, contents</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">throw</span> err;<br>    &#125;<br>        <br>    <span class="hljs-title function_">doSomethingWith</span>(contents);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Done&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>



<p><strong>使用 yield</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">taskDef</span>) &#123;<br>    <span class="hljs-comment">// 创建迭代器，让它在别处可用</span><br>    <span class="hljs-keyword">let</span> task = <span class="hljs-title function_">taskDef</span>();<br>    <span class="hljs-comment">// 启动任务</span><br>    <span class="hljs-keyword">let</span> result = task.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-comment">// 递归使用函数来保持对 next() 的调用</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">step</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 如果还有更多要做的</span><br>        <span class="hljs-keyword">if</span> (!result.<span class="hljs-property">done</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result.<span class="hljs-property">value</span> === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>                result.<span class="hljs-title function_">value</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (err) &#123;<br>                        result = task.<span class="hljs-keyword">throw</span>(err);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><br>                    result = task.<span class="hljs-title function_">next</span>(data);<br>                    <span class="hljs-title function_">step</span>();<br>                &#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result = task.<span class="hljs-title function_">next</span>(result.<span class="hljs-property">value</span>);<br>                <span class="hljs-title function_">step</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 开始处理过程</span><br>    <span class="hljs-title function_">step</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">run</span>(<span class="hljs-keyword">function</span>*() &#123;<br>    <span class="hljs-keyword">let</span> contents = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;config.json&quot;</span>);<br>    <span class="hljs-title function_">doSomethingWith</span>(contents);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Done&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>此例执行了异步的 readFile() 操作，而在<strong>主要代码中并未暴露出任何回调函数</strong>。除了 yield 之外，<strong>此代码看起来与同步代码并无二致</strong>。既然执行异步操作的函数都遵循了同一接口，你就可以用貌似同步的代码来书写处理逻辑。</p>
<p>看上去好像更复杂了，但这是因为当前回调任务少，<strong>如果需要嵌套回调函数，或者需要按顺序处理一系列的异步任务时，使用生成器和迭代器会方便很多</strong>。</p>
<h1 id="JS-的类"><a href="#JS-的类" class="headerlink" title="JS 的类"></a>JS 的类</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726161901329.png" srcset="/img/loading.gif" lazyload class="" title="image-20220726161901329">



<h2 id="ES5-中的仿类结构"><a href="#ES5-中的仿类结构" class="headerlink" title="ES5 中的仿类结构"></a>ES5 中的仿类结构</h2><p><strong>自定义类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PersonType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">PersonType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>person.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PersonType</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>



<h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonClass</span> &#123;<br>    <span class="hljs-comment">// 等价于 PersonType 构造器</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-comment">// 自有属性</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-comment">// 等价于 PersonType.prototype.sayName</span><br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonClass</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>person.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// &quot;function&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span>); <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>自有属性：该属性出现在实例上而不是原型上，只能在类的构造器或方法内部进行创建。</strong></p>
<p><strong>类与自定义类型的区别</strong></p>
<ol>
<li><strong>类声明不会被提升，这与函数定义不同</strong>。类声明的行为与 let 相似，因此在程序的执行到达声明处之前，类会存在于暂时性死区内。</li>
<li><strong>类声明中的所有代码会自动运行在严格模式下</strong>，并且也无法退出严格模式。</li>
<li><strong>类的所有方法都是不可枚举的</strong>，这是对于自定义类型的显著变化，后者必须用Object.defineProperty() 才能将方法改变为不可枚举。</li>
<li><strong>类的所有方法内部都没有 [[Construct]]</strong> ，因此使用 new 来调用它们会抛出错误。</li>
<li><strong>调用类构造器时不使用 new</strong> ，会抛出错误。</li>
<li><strong>试图在类的方法内部重写类名</strong>，会抛出错误。</li>
</ol>
<p><strong>如果我们不使用类来定义上面的 PersonClass</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 直接等价于 PersonClass</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">PersonType2</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">PersonType2</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>        <br>        <span class="hljs-comment">// 确认函数被调用时使用了 new</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Constructor must be called with new.&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">PersonType2</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;sayName&quot;</span>, &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <br>            <span class="hljs-comment">// 确认函数被调用时没有使用 new</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>            	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Method cannot be called with new.&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>        &#125;,<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">PersonType2</span>;<br>&#125;());<br></code></pre></td></tr></table></figure>



<h2 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h2><p>类与函数有相似之处，即它们都有两种形式：声明与表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title class_">PersonClass</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonClass2</span> &#123;		<span class="hljs-comment">// PersonClass2 可省略，匿名和具名</span><br>    <span class="hljs-comment">// 等价于 PersonType 构造器</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 等价于 PersonType.prototype.sayName</span><br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonClass</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>person.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// &quot;function&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span>); <span class="hljs-comment">// &quot;function&quot;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass2</span>); <span class="hljs-comment">// &quot;undefined&quot;	外部是访问不到 PersonClass2 的</span><br></code></pre></td></tr></table></figure>



<h2 id="作为一级公民的类"><a href="#作为一级公民的类" class="headerlink" title="作为一级公民的类"></a>作为一级公民的类</h2><p>能被当作值来使用的就称为一级公民</p>
<p>JS的函数就是一级公民，类也延续了下来。</p>
<p>类能作为参数传入函数；也有立即调用类构造器的用法。</p>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2>
              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E4%B9%A6%E7%B1%8D/" class="category-chain-item">书籍</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">#字符串</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解ES6</div>
      <div>http://example.com/2022/07/21/深入理解ES6/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>July 21, 2022</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/01/%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="实习记录">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">实习记录</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/15/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" title="类型转换">
                        <span class="hidden-mobile">类型转换</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
    
      
            
                  
</div>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
