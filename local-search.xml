<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mini Vue</title>
    <link href="/2022/09/28/Mini-Vue/"/>
    <url>/2022/09/28/Mini-Vue/</url>
    
    <content type="html"><![CDATA[<h2 id="vue-整体流程"><a href="#vue-整体流程" class="headerlink" title="vue 整体流程"></a>vue 整体流程</h2><img src="/2022/09/28/Mini-Vue/13429147-32832d6b08b108c4.jpg" class="" title="img"><h2 id="vue-的三个-core"><a href="#vue-的三个-core" class="headerlink" title="vue 的三个 core"></a>vue 的三个 core</h2><h3 id="Reactivity-Module"><a href="#Reactivity-Module" class="headerlink" title="Reactivity Module"></a>Reactivity Module</h3><p>创建 JS 响应对象，并观察其变化，当使用这些对象的代码运行时，他们会被跟踪，当响应式对象变化时，代码会运行。</p><h3 id="Compiler-Module"><a href="#Compiler-Module" class="headerlink" title="Compiler Module"></a>Compiler Module</h3><p>将 HTML 模板编译成渲染函数</p><h3 id="Render-Module"><a href="#Render-Module" class="headerlink" title="Render Module"></a>Render Module</h3><p>三个阶段</p><ol><li>Render Phase</li></ol><p>渲染阶段，调用 render 函数，返回一个虚拟DOM节点</p><ol start="2"><li>Mount Phase</li></ol><p>挂载阶段，使用 虚拟DOM节点并调用 DOM API 来创建网页</p><ol start="3"><li>Patch Phase</li></ol><p>补丁阶段，新旧虚拟节点对比，并更新网页变化部分</p><h3 id="总的流程"><a href="#总的流程" class="headerlink" title="总的流程"></a>总的流程</h3><p>我们拥有 html template 和 设定的响应式对象</p><ol><li><p>Compiler Module 会将 template 转换为一个 render 函数</p></li><li><p>Reactivity Module 初始化响应式对象</p></li><li><p>Renderer Module （渲染）会调用 render 函数（而 render 函数引用了响应式对象），观察响应式对象的变化，render 函数返回一个虚拟 DOM 节点</p></li><li><p>Renderer Module（挂载）调用 mount 函数，使用虚拟 DOM 创建 页面</p></li><li><p>如果响应式对象发生任何变化，render 会再次调用 render 函数，创建一个新的虚拟 DOM，新旧虚拟节点传入 Patch 函数，新旧虚拟节点对比，根据需要更新网页</p></li></ol><h2 id="compiler-和-render"><a href="#compiler-和-render" class="headerlink" title="compiler 和 render"></a>compiler 和 render</h2><h3 id="在-js-中使用-render"><a href="#在-js-中使用-render" class="headerlink" title="在 js 中使用 render"></a>在 js 中使用 render</h3><p>在 js 中使用 render 创建元素</p><p>h 函数会调用 vnode函数 从而创建 vnode 对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123;h&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;foo&#x27;</span></span><br><span class="language-javascript">            <span class="hljs-attr">onClick</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">onClick</span></span><br><span class="language-javascript">        &#125;, <span class="hljs-string">&#x27;hello&#x27;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="从-template-到-页面实例"><a href="#从-template-到-页面实例" class="headerlink" title="从 template 到 页面实例"></a>从 template 到 页面实例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>vue 在内部做的是：</p><ol><li>compiler 将 template 转为 render 函数，renderer 调用 render 函数，返回一个虚拟 DOM</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; h &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;, [<br>        <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;span&#x27;</span>, <span class="hljs-literal">null</span>, [<span class="hljs-string">&#x27;hello&#x27;</span>])<br>    ])<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>虚拟 DOM 转为真实 DOM 并挂载到容器(父组件)上</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue3">mount(vdom, document.getElementById(&#x27;app&#x27;))<br></code></pre></td></tr></table></figure><h2 id="写一个简单的-mount"><a href="#写一个简单的-mount" class="headerlink" title="写一个简单的 mount"></a>写一个简单的 mount</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mount</span>(<span class="hljs-params">vnode, container</span>) &#123;<br>    <span class="hljs-comment">// 根据 虚拟DOM 创建 真实DOM</span><br>    <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">tag</span>)<br>    <span class="hljs-comment">// props</span><br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">props</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> vnode.<span class="hljs-property">props</span>) &#123;<br>            <span class="hljs-keyword">const</span> value = vnode.<span class="hljs-property">props</span>[key]<br>            el.<span class="hljs-title function_">setAttribute</span>(key, value)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// children (假设要么是 字符串 要么是 vnode 的数组；实际在 vue 中是 字符串和 vnode 的混合数组)</span><br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">children</span>) &#123;<br>        vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>                el.<span class="hljs-property">textContent</span> = vnode.<span class="hljs-property">children</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>                    <span class="hljs-title function_">mount</span>(child, el)<br>                &#125;)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    container.<span class="hljs-title function_">appendChild</span>(el)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写一个简单的-patch"><a href="#写一个简单的-patch" class="headerlink" title="写一个简单的 patch"></a>写一个简单的 patch</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">n1, n2</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n1.<span class="hljs-property">tag</span> === n2.<span class="hljs-property">tag</span>) &#123;<br>        <span class="hljs-keyword">const</span> el = n2.<span class="hljs-property">el</span> = n1.<span class="hljs-property">el</span><br>        <span class="hljs-comment">// props</span><br>        <span class="hljs-keyword">const</span> oldProps = n1.<span class="hljs-property">props</span> || &#123;&#125;<br>        <span class="hljs-keyword">const</span> newProps = n2.<span class="hljs-property">props</span> || &#123;&#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> newProps) &#123;<br>            <span class="hljs-keyword">const</span> oldValue = oldProps[key]<br>            <span class="hljs-keyword">const</span> newValue = newProps[key]<br>            <span class="hljs-keyword">if</span> (newValue !== oldValue) &#123;<br>                el.<span class="hljs-title function_">setAttribute</span>(key, newValue)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> oldProps) &#123;<br>            <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> newProps)) &#123;<br>                el.<span class="hljs-title function_">removeAttribute</span>(key)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// children</span><br>        <span class="hljs-keyword">const</span> oldChildren = n1.<span class="hljs-property">children</span><br>        <span class="hljs-keyword">const</span> newChildren = n2.<span class="hljs-property">children</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChildren === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldChildren === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (newChildren !== oldChildren) &#123;<br>                    el.<span class="hljs-property">textcontent</span> = newChildren<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                el.<span class="hljs-property">textContent</span> = newChildren<br>                <span class="hljs-comment">// oldChildren 的孩子怎么办？ 不用删掉吗？</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldChildren === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>                el.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&#x27;</span><br>                newChildren.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>                    <span class="hljs-title function_">mount</span>(child, el)<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 这里写的是没有 key 的简单的 diff 算法; 带 key 的 diff 算法看源码</span><br>                <span class="hljs-keyword">const</span> commonLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(newChildren.<span class="hljs-property">length</span>, oldChildren.<span class="hljs-property">length</span>)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; commonLength; i++) &#123;<br>                    <span class="hljs-title function_">patch</span>(oldChildren[i], newChildren[i])<br>                &#125;<br>                <span class="hljs-keyword">if</span> (newChildren.<span class="hljs-property">length</span> &gt; oldChildren.<span class="hljs-property">length</span>) &#123;<br>                    newChildren.<span class="hljs-title function_">slice</span>(oldChildren.<span class="hljs-property">length</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>                        <span class="hljs-title function_">mount</span>(el, child)<br>                    &#125;)<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newChildren.<span class="hljs-property">length</span> &lt; oldChildren.<span class="hljs-property">length</span>) &#123;<br>                    oldChildren.<span class="hljs-title function_">slice</span>(newChildren.<span class="hljs-property">length</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>                        el.<span class="hljs-title function_">removeChild</span>(child)<br>                    &#125;)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>grid布局</title>
    <link href="/2022/09/27/grid%E5%B8%83%E5%B1%80/"/>
    <url>/2022/09/27/grid%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Grid 布局将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。</p><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/20210126105810167.png" class="" title="img"><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="行数行宽-x2F-列数列宽"><a href="#行数行宽-x2F-列数列宽" class="headerlink" title="行数行宽&#x2F;列数列宽"></a>行数行宽&#x2F;列数列宽</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>grid-template-columns 定义每一列列宽</p><p>grid-template-rows 定义每一行行宽</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927170918911.png" class="" title="image-20220927170918911"><p>值可以是绝对单位&#x2F;百分比，也有一些额外的属性和方法来简化代码</p><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><h5 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h5><p>用于简化重复的值&#x2F;模式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-comment">/* 6列 */</span><br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100px</span> <span class="hljs-number">20px</span> <span class="hljs-number">80px</span>);<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="auto-fill"><a href="#auto-fill" class="headerlink" title="auto-fill"></a>auto-fill</h5><p>自动填充，每一行（或每一列）容纳尽可能多的单元格。</p><p>一般用于单元格大小固定，但容器大小不确定时。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-comment">/* 每列宽度 100px 自动填充 */</span><br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">100px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927171621426.png" class="" title="image-20220927171621426"><h5 id="fr"><a href="#fr" class="headerlink" title="fr"></a>fr</h5><p>fraction 的缩写，意为”片段”</p><p>不给具体数值，但给定比例。可以和绝对单位混用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">150px</span> <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927171812596.png" class="" title="image-20220927171812596"><h5 id="minmax"><a href="#minmax" class="headerlink" title="minmax()"></a>minmax()</h5><p>minmax() 函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">1</span>fr);<br></code></pre></td></tr></table></figure></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>两栏式布局非常简单</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">70%</span> <span class="hljs-number">30%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="间距-gap"><a href="#间距-gap" class="headerlink" title="间距 gap"></a>间距 gap</h3><p><strong>row-gap 属性设置行间距</strong></p><p><strong>column-gap 属性设置列间距</strong></p><p><strong>gap 是两者的简写形式，</strong>如果 gap 省略了第二个值，浏览器认为第二个值等于第一个值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span> <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927173417160.png" class="" title="image-20220927173417160"><h3 id="区域-area"><a href="#区域-area" class="headerlink" title="区域 area"></a>区域 area</h3><p><strong>grid-template-areas 属性用于定义区域</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&quot;header header header&quot;</span><br>                     <span class="hljs-string">&quot;main main sidebar&quot;</span><br>                     <span class="hljs-string">&quot;footer footer footer&quot;</span>;<br></code></pre></td></tr></table></figure><p>顶部是页眉区域 header，底部是页脚区域 footer，中间部分则为 main 和 sidebar。</p><p>如果某些区域不需要利用，则使用 . 表示</p><p>区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><h3 id="控制单元格排列方式"><a href="#控制单元格排列方式" class="headerlink" title="控制单元格排列方式"></a>控制单元格排列方式</h3><p><strong>grid-auto-flow 控制子元素排列方式，默认为 row</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">grid-auto-flow</span>: column;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927174250065.png" class="" title="image-20220927174250065"><p><strong>dense 关键字用于让元素排列更加紧密</strong></p><p>不加 dense</p><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927174425864.png" class="" title="image-20220927174425864"><p>加 dense</p><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927174512952.png" class="" title="image-20220927174512952"><h3 id="控制内容在单元格中的位置"><a href="#控制内容在单元格中的位置" class="headerlink" title="控制内容在单元格中的位置"></a>控制内容在单元格中的位置</h3><p><strong>justify-items 属性设置单元格内容的水平位置（左中右）</strong></p><p><strong>align-items 属性设置单元格内容的垂直位置（上中下）</strong></p><p><strong>place-items 属性是 align-items 属性和 justify-items 属性的合并简写形式</strong>，如果省略第二个值，则浏览器认为与第一个值相等。</p><p>可选值：</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  justify-items: start;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927175053534.png" class="" title="image-20220927175053534"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">align-items</span>: start;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927175150874.png" class="" title="image-20220927175150874"><h3 id="控制整个内容区在容器中的位置"><a href="#控制整个内容区在容器中的位置" class="headerlink" title="控制整个内容区在容器中的位置"></a>控制整个内容区在容器中的位置</h3><p><strong>justify-content 属性是整个内容区域在容器里面的水平位置（左中右）</strong></p><p><strong>align-content 属性是整个内容区域的垂直位置（上中下）</strong></p><p><strong>place-content 属性是 align-content 属性和 justify-content 属性的合并简写形式。</strong>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p><p>可选值：</p><ul><li><p>start - 对齐容器的起始边框</p></li><li><p>end - 对齐容器的结束边框</p></li><li><p>center - 容器内部居中</p></li><li><p>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</p></li><li><p>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</p></li><li><p>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</p></li><li><p>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">justify-content</span>: space-around;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927175720883.png" class="" title="image-20220927175720883"><h3 id="控制网格外部项目的宽高"><a href="#控制网格外部项目的宽高" class="headerlink" title="控制网格外部项目的宽高"></a>控制网格外部项目的宽高</h3><p>grid-auto-columns 属性和 grid-auto-rows 属性用来设置，浏览器自动创建的多余网格的列宽和行高。</p><p>如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。 */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927223440294.png" class="" title="image-20220927223440294"><h3 id="合并属性-grid-template"><a href="#合并属性-grid-template" class="headerlink" title="合并属性 grid-template"></a>合并属性 grid-template</h3><p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p><p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="指定项目位置"><a href="#指定项目位置" class="headerlink" title="指定项目位置"></a>指定项目位置</h3><ul><li>grid-column-start 属性：左边框所在的垂直网格线</li><li>grid-column-end 属性：右边框所在的垂直网格线</li><li>grid-row-start 属性：上边框所在的水平网格线</li><li>grid-row-end 属性：下边框所在的水平网格线</li></ul><p>值可以是 数字 左右边框的名字 span关键字(表示左右边框&#x2F;上下边框跨越了多少个网格)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927223748443.png" class="" title="image-20220927223748443"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-start</span>: header-start;<br>  <span class="hljs-attribute">grid-column-end</span>: header-end;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-start</span>: span <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式</p><p><code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 中间有个 / */</span><br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: &lt;start-line&gt; / &lt;end-line&gt;;<br>  <span class="hljs-attribute">grid-row</span>: &lt;start-line&gt; / &lt;end-line&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="指定项目放在哪个区域"><a href="#指定项目放在哪个区域" class="headerlink" title="指定项目放在哪个区域"></a>指定项目放在哪个区域</h3><p>grid-area 可以直接指定区域，也可以用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: e;<br>&#125;<br><br><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">1</span> / <span class="hljs-number">1</span> / <span class="hljs-number">3</span> / <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置单个项目的在单元格中的位置"><a href="#设置单个项目的在单元格中的位置" class="headerlink" title="设置单个项目的在单元格中的位置"></a>设置单个项目的在单元格中的位置</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><p>可选值：</p><blockquote><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span>  &#123;<br>  justify-self: start;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927224801964.png" class="" title="image-20220927224801964"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></p><p><a href="https://www.cnblogs.com/starof/p/15627296.html">https://www.cnblogs.com/starof/p/15627296.html</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm run xxx</title>
    <link href="/2022/09/24/npm-run-xxx/"/>
    <url>/2022/09/24/npm-run-xxx/</url>
    
    <content type="html"><![CDATA[<h2 id="npm-run-xxx后发生了什么"><a href="#npm-run-xxx后发生了什么" class="headerlink" title="npm run xxx后发生了什么"></a>npm run xxx后发生了什么</h2><p><strong>去 package.json 的 scripts 里找对应的 xxx，然后执行 xxx</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;private&quot;</span>: ,<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;vite&quot;</span>,<br>    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;vue-tsc --noEmit &amp;&amp; vite build&quot;</span>,<br>    <span class="hljs-string">&quot;preview&quot;</span>: <span class="hljs-string">&quot;vite preview&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>  &#125;,<br>  <span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以 npm run dev 时，实际会执行 vite</p><p><strong>为什么不直接执行 vite，而要执行 npm run dev？</strong></p><p>因为 vite 指令不存在操作系统里</p><p><strong>为什么执行 npm run dev 就能成功？</strong></p><p>因为npm 会去找同名可执行文件</p><p>我们在 npm i vite 安装依赖时，就会在 node_modules&#x2F;.bin&#x2F; 目录中创建 好 vite 为名的几个可执行文件，这些文件都是软链接。</p><img src="/2022/09/24/npm-run-xxx/image-20220924104924956.png" class="" title="image-20220924104924956"><p>vite - shell脚本</p><p>vite.cmd - cmd脚本</p><p>vite.ps1 - shell 脚本</p><p>以 vite.cmd 为例</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cmd">@<span class="hljs-built_in">ECHO</span> off<br><span class="hljs-keyword">GOTO</span> <span class="hljs-built_in">start</span><br>:find_dp0<br><span class="hljs-built_in">SET</span> dp0=%~dp0<br><span class="hljs-keyword">EXIT</span> /b<br>:<span class="hljs-built_in">start</span><br><span class="hljs-built_in">SETLOCAL</span><br><span class="hljs-keyword">CALL</span> :find_dp0<br><br><span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXIST</span> &quot;<span class="hljs-variable">%dp0%</span>\node.exe&quot; (<br>  <span class="hljs-built_in">SET</span> &quot;_prog=<span class="hljs-variable">%dp0%</span>\node.exe&quot;<br>) <span class="hljs-keyword">ELSE</span> (<br>  <span class="hljs-built_in">SET</span> &quot;_prog=node&quot;<br>  <span class="hljs-built_in">SET</span> PATHEXT=<span class="hljs-variable">%PATHEXT:;.JS;=;%</span><br>)<br><br><span class="hljs-built_in">endLocal</span> &amp; <span class="hljs-keyword">goto</span> #_undefined_# <span class="hljs-number">2</span>&gt;<span class="hljs-built_in">NUL</span> || <span class="hljs-built_in">title</span> <span class="hljs-variable">%COMSPEC%</span> &amp; &quot;<span class="hljs-variable">%_prog%</span>&quot;  &quot;<span class="hljs-variable">%dp0%</span>\..\vite\bin\vite.js&quot; %*<br></code></pre></td></tr></table></figure><p>主要就是在判断环境、拼接路径，然后指向运行 路径下的 &#x2F;vite&#x2F;bin&#x2F;vite.js 脚本</p><p>实际脚本位置就在 node_modules&#x2F;vite&#x2F;bin&#x2F;vite.js</p><img src="/2022/09/24/npm-run-xxx/image-20220924112057516.png" class="" title="image-20220924112057516"><p>之后会用 node 去执行这个 js 脚本</p><p><strong>软连接是在哪形成的？</strong></p><p>包中源代码的 package.json 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// node_modules/vite/package.json</span><br>&#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;3.1.0&quot;</span>,<br><span class="hljs-string">&quot;bin&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;vite&quot;</span>: <span class="hljs-string">&quot;bin/vite.js&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 npm install 时，npm 读到该配置(bin)后，就将 bin&#x2F;vite.js 文件软链接到 .&#x2F;node_modules&#x2F;.bin 目录下</p><p>而 npm 还会自动把 node_modules&#x2F;.bin 加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.npm run xxx 时，会到 package.json 的 scripts 里找映射，执行对应的指令</p><p>2.指令实际是无法执行的，但 npm 会从全局的 node_modules&#x2F;.bin 中查找指令同名的可执行文件，他们都是软链接。</p><p>3.软链接是写在 包的源代码的 package.json 中的，在 npm install 时会配置好，一般软链接的指向我们可以在 node_modules 下找到包，bin 里面有一个 js 文件，最后将在 node 中执行这个 js 文件。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DocumentFragment</title>
    <link href="/2022/09/23/DocumentFragment/"/>
    <url>/2022/09/23/DocumentFragment/</url>
    
    <content type="html"><![CDATA[<h1 id="文档碎片"><a href="#文档碎片" class="headerlink" title="文档碎片"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">文档碎片</a></h1><h2 id="什么是文档碎片"><a href="#什么是文档碎片" class="headerlink" title="什么是文档碎片"></a>什么是文档碎片</h2><p>它被作为一个轻量版的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document"><code>Document</code></a> 使用，就像标准的 document 一样，存储由节点（nodes）组成的文档结构。与 document 相比，最大的区别是<strong>它不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染（重绘重排），且不会对性能产生影响。</strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>最常用的方法是使用 <code>DocumentFragment</code> 创建并组成一个 DOM 子树，然后使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node"><code>Node</code></a> 接口方法（如：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild"><code>appendChild()</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore"><code>insertBefore()</code></a>）将其插入到 DOM 中。这种情况下<strong>会插入片段的所有子节点，并留下一个空的 DocumentFragment</strong>。因为<strong>所有的节点会被一次插入到文档中，所以仅会发生一个重渲染的操作，而不是每个节点分别被插入到文档中从而发生多次重渲染的操作</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#list&#x27;</span>)<br><span class="hljs-keyword">const</span> fruits = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Orange&#x27;</span>, <span class="hljs-string">&#x27;Banana&#x27;</span>, <span class="hljs-string">&#x27;Melon&#x27;</span>]<br><br><span class="hljs-keyword">const</span> fragment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DocumentFragment</span>()<br><br>fruits.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fruit</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>)<br>  li.<span class="hljs-property">textContent</span> = fruit<br>  fragment.<span class="hljs-title function_">appendChild</span>(li)<br>&#125;)<br><br>list.<span class="hljs-title function_">appendChild</span>(fragment)<br></code></pre></td></tr></table></figure><img src="/2022/09/23/DocumentFragment/image-20220923172037861.png" class="" title="image-20220923172037861"><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>文档片段节点的三个node属性——nodeType、nodeName、nodeValue分别是11、’#document-fragment’和null，文档片段节点没有父节点parentNode</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> frag = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(frag.<span class="hljs-property">nodeType</span>);<span class="hljs-comment">//11</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(frag.<span class="hljs-property">nodeValue</span>);<span class="hljs-comment">//null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(frag.<span class="hljs-property">nodeName</span>);<span class="hljs-comment">//&#x27;#document-fragment&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(frag.<span class="hljs-property">parentNode</span>);<span class="hljs-comment">//null</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>服务端渲染 客户端渲染 预渲染</title>
    <link href="/2022/09/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%20%E9%A2%84%E6%B8%B2%E6%9F%93/"/>
    <url>/2022/09/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%20%E9%A2%84%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="三种渲染方式"><a href="#三种渲染方式" class="headerlink" title="三种渲染方式"></a>三种渲染方式</h1><p><strong>客户端渲染</strong>：用户访问 url，请求 html 文件，前端根据路由动态渲染页面内容。关键链路较长，有一定的白屏时间；</p><p><strong>服务端渲染</strong>：用户访问 url，服务端根据访问路径请求所需数据，拼接成 html 字符串，返回给前端。前端接收到 html 时已有部分内容；</p><p><strong>预渲染</strong>：<strong>构建阶段</strong>生成匹配预渲染路径的 html 文件（注意：<strong>每个需要预渲染的路由都有一个对应的 html</strong>）。构建出来的 html 文件已有部分内容。</p><h1 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h1><h2 id="什么是客户端渲染"><a href="#什么是客户端渲染" class="headerlink" title="什么是客户端渲染"></a>什么是客户端渲染</h2><ol><li><p>http发起请求</p></li><li><p>服务端接受请求，响应一个页面<code>index.html</code>给客户端，也可以说是一个页面字符串。</p></li><li><p>客户端拿到页面，然后进行解析渲染，解析到静态页面会渲染显示在浏览器上，解析到script动态脚本<code>&lt;script src=&#39;user.js&#39;&gt;&lt;/script&gt;</code>，则浏览器会再次向浏览器发起请求</p></li><li><p>服务端再次处理服务端的请求，然后响应数据</p></li><li><p>客户端拿到服务器返回的数据，然后利用模板引擎进行渲染，最终将数据也显示在页面上</p></li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>与服务端渲染相反</p><h1 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h1><h2 id="什么是服务端渲染"><a href="#什么是服务端渲染" class="headerlink" title="什么是服务端渲染"></a>什么是服务端渲染</h2><p>服务器端的渲染，指的是客户端只需要发起一次http请求，服务器就会一次性将渲染好的页面进行返回，客户端不需要再次发起请求去服务器端拿数据。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><strong>首屏时间短</strong></li></ul><p>服务端在内网进行请求数据，响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大。</p><p>服务器性能好，渲染更快。</p><ul><li><strong>利于 SEO</strong></li></ul><p>因为后端会返回完整的 html 页面</p><ul><li><strong>占用客户端资源少</strong></li></ul><p>移动端省电</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>不利于前后端分离</li></ul><p>后端在生成前端的页面</p><ul><li>占用服务器端资源</li></ul><p>如果请求较多，会对服务器造成一定的访问压力</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>vue框架的项目，使用nuxt就很方便了，我们<strong>只需要按照nuxt的脚手架创建好项目结构</strong>，然后就可以按照vue的开发方式进行开发了。<br>nuxt支持SSR服务端渲染模式和SSG静态生成模式，如果说我们的页面需要提前动态获取数据并进行拼接，我们就需要使用服务端渲染模式；如果说我们的页面静态的东西比较多，动态数据不需要考虑SEO，那么我们可以选择静态生成模式，相当于使用预渲染，不需要node服务器也能够提升SEO。</p><h1 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h1><h2 id="什么是预渲染"><a href="#什么是预渲染" class="headerlink" title="什么是预渲染"></a>什么是预渲染</h2><p><strong>SSG</strong>（static side generate），无需服务器实时动态编译，<strong>在构建时针对特定路由简单的生成静态HTML文件</strong>。</p><h3 id="预渲染的作用"><a href="#预渲染的作用" class="headerlink" title="预渲染的作用"></a>预渲染的作用</h3><p>针对单页应用，服务端渲染和预渲染共同解决的问题：</p><ol><li><strong>SEO</strong>：单页应用的网站内容是根据当前路径动态渲染的，html 文件中往往没有内容，网络爬虫不会等到页面脚本执行完再抓取；</li><li><strong>弱网环境</strong>：当用户在一个弱环境中访问你的站点时，你会想要尽可能快的将内容呈现给他们。甚至是在 js 脚本被加载和解析前；</li><li><strong>低版本浏览器</strong>：用户的浏览器可能不支持你使用的 js 特性，预渲染或服务端渲染能够让用户至少能够看到首屏的内容，而不是一个空白的网页。</li></ol><p>预渲染能与服务端渲染一样提高 SEO 优化，但前者比后者需要更少的配置，实现成本低。弱网环境下，预渲染能更快地呈现页面内容，减少页面可见时间。</p><h3 id="不适合的场景"><a href="#不适合的场景" class="headerlink" title="不适合的场景"></a>不适合的场景</h3><p><strong>1.个性化内容</strong>：对于路由是 &#x2F;my-profile 的页面来说，预渲染就失效了。因为页面内容依据看它的人而显得不同；</p><p><strong>2.经常变化的内容</strong>：如果你预渲染一个游戏排行榜，这个排行榜会随着新的玩家记录而更新，预渲染会让你的页面显示不正确直到脚本加载完成并替换成新的数据。这是一个不好的用户体验；</p><p><strong>3.成千上万的路由</strong>：不建议预渲染非常多的路由，因为这会严重拖慢你的构建进程。</p><h2 id="使用预渲染"><a href="#使用预渲染" class="headerlink" title="使用预渲染"></a>使用预渲染</h2><h3 id="prerender-spa-plugin"><a href="#prerender-spa-plugin" class="headerlink" title="prerender-spa-plugin"></a>prerender-spa-plugin</h3><p><a href="https://link.juejin.cn/?target=https://github.com/chrisvfritz/prerender-spa-plugin"><strong>prerender-spa-plugin</strong></a> 是一个 webpack 插件用于在单页应用中预渲染静态 html 内容。它是框架无关的。</p><p>预渲染的单页应用<strong>路由需要使用 History 模式</strong>而不是 Hash 模式。原因很简单，Hash 不会带到服务器，路由信息会丢失。</p><h3 id="配置预渲染前"><a href="#配置预渲染前" class="headerlink" title="配置预渲染前"></a>配置预渲染前</h3><p>没有配置预渲染的话，一般来说，根据 nginx 的配置，无论访问哪个路由都会返回首页 dist&#x2F;index.html。具体情况视配置而见</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">location / &#123;<br>  try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span><span class="hljs-regexp">/ /i</span>ndex.html;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置预渲染"><a href="#配置预渲染" class="headerlink" title="配置预渲染"></a>配置预渲染</h3><p>安装包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> prerender-spa-plugin<br></code></pre></td></tr></table></figure><p>配置 webpack</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">PrerenderSpaPlugin</span> = <span class="hljs-title function_">require</span>(<span class="hljs-params"><span class="hljs-string">&#x27;prerender-spa-plugin&#x27;</span></span>)<br><br>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrerenderSpaPlugin</span>(<br>      <span class="hljs-comment">// 输出目录的绝对路径</span><br>      path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;../dist&#x27;</span>),<br>      <span class="hljs-comment">// 预渲染的路由</span><br>      [ <span class="hljs-string">&#x27;/new&#x27;</span>, <span class="hljs-string">&#x27;/hot&#x27;</span> ]<br>    )<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="预渲染效果"><a href="#预渲染效果" class="headerlink" title="预渲染效果"></a>预渲染效果</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs axapta">dist<br>│  <span class="hljs-keyword">index</span>.html<br>│  <br>├─hot<br>│      <span class="hljs-keyword">index</span>.html<br>│      <br>├─<span class="hljs-keyword">new</span><br>│      <span class="hljs-keyword">index</span>.html<br>│      <br>└─<span class="hljs-keyword">static</span><br></code></pre></td></tr></table></figure><p>对比 dist 目录，可以发现预渲染的目录多了两个文件 <code>new/index.html</code>, <code>hot/index.html</code></p><p>其中，**&#x2F;new** 和 <strong>&#x2F;hot</strong> 路由返回的 html 包含了对应路由的内容，从而实现预渲染。进入这两个路由时，直接发请求获取预渲染的 html。</p><p>没有配置预渲染的路由跟原来一样，还是访问 &#x2F;index.html，请求脚本，动态渲染。</p><p>预渲染达到了类似服务端渲染的效果。区别在于预渲染发生在<strong>构建时</strong>，服务端渲染发生在服务器<strong>处理请求时</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单的说就是在 build 时会在 dist 文件夹里多生成几个 html 文件，数量根据需要预渲染的路由个数而变（webpack中配置）。进入路由时，会直接返回对应的已经预渲染好的 html，而不用再在客户端动态渲染或是服务端渲染 。</p><p>实际上是一种空间换时间的方法，会增大打包后的体积，提升预渲染路由页面的渲染时间。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903503362523143">https://juejin.cn/post/6844903503362523143</a></p>]]></content>
    
    
    <categories>
      
      <category>优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pokemon项目</title>
    <link href="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要做这个项目"><a href="#为什么要做这个项目" class="headerlink" title="为什么要做这个项目"></a>为什么要做这个项目</h1><p>1.练习 vue3+ts，学习一些 css 技巧（布局&#x2F;动画效果）</p><p>2.网页版的宝可梦图鉴很少，大都是app。并且宝可梦图鉴大都很丑，让人没有使用的欲望。</p><p>3.其实更想做篮球和足球的数据图鉴，但是没找到免费的开源接口</p><h1 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h1><p>getPokemonApi(id: number)</p><p>base_experience：击败这只宝可梦获得的经验</p><p>abilities: 能力&#x2F;被动 为神奇宝贝在战斗或主世界中提供被动效果。神奇宝贝有多种可能的能力，但一次只能有一种能力</p><p>forms：种族？暂时没啥用</p><p>game_indices:  游戏不同代</p><p>height: 身高 dm</p><p>held_items：当遭遇到这只宝可梦时，它可能携带的物品</p><p>location_area_encounters：可能遭遇的地点</p><p>moves：技能</p><p>name：名字</p><p>order：仅用于排序</p><p>past_types：该宝可梦在前几代拥有的类型的详细信息</p><p>species：一些图片</p><p>status：统计数据(hp attack)。每个神奇宝贝的每个属性都有一个值，随着他们的等级增加而增长，并且可以通过战斗中的效果暂时改变。effort（EV）努力点</p><p>types：类别（注意类别克制）<a href="https://pokeapi.co/api/v2/type/%7Bid">https://pokeapi.co/api/v2/type/{id</a> or name}&#x2F;</p><p>weight：体重</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="保证请求的顺序"><a href="#保证请求的顺序" class="headerlink" title="保证请求的顺序"></a>保证请求的顺序</h2><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220906222915890.png" class="" title="image-20220906222915890"><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h3><p>没有获取所有宝可梦数据的请求，一次只能获取一个宝可梦的数据。而我们需要保证获取的顺序。</p><p>也就是说，有很多个请求需要依次发送，待上一个请求完成之后再发送下一个请求，发生异常时也要能够继续后面的请求。</p><p><strong>如果直接循环发请求，会乱序。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getPokemon</span> = (<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<br>    <span class="hljs-title function_">getPokemonApi</span>(id).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123; data &#125; = res<br>        pokemons.<span class="hljs-title function_">push</span>(data)<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">21</span>; i++) &#123;<br>        <span class="hljs-title function_">getPokemon</span>(i)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220906223103579.png" class="" title="image-20220906223103579"><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><a href="http://t.zoukankan.com/jyughynj-p-14429662.html">解决方案</a></h3><p><strong>1.使用生成器</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 生成器 用来保证请求的顺序</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">21</span>; i++) &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-title function_">getPokemonApi</span>(i)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理请求结果并发送下一次请求</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">res: <span class="hljs-built_in">any</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">done</span>) &#123;<br>        res.<span class="hljs-property">value</span><br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)<br>            pokemons.<span class="hljs-title function_">push</span>(response.<span class="hljs-property">data</span>)<br>            <span class="hljs-title function_">run</span>(gen.<span class="hljs-title function_">next</span>())<br>        &#125;)<br>            .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123; <span class="hljs-comment">// 处理一下异常</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(err)<br>            <span class="hljs-title function_">run</span>(gen.<span class="hljs-title function_">next</span>())<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 开始执行</span><br><span class="hljs-keyword">let</span> gen = <span class="hljs-title function_">generator</span>()<br><span class="hljs-title function_">run</span>(gen.<span class="hljs-title function_">next</span>())<br></code></pre></td></tr></table></figure><p>一个请求完成之后再发送下一个请求，关键在于发送一个之后先停下来等待该请求完成，处理之后再继续下一个请求。生成器generator里面的yield语句可以分割代码，程序遇到yield会停住，通过next语句可以一次执行一个yield分割的语句，本文尝试使用生成器完成依次发送多个请求的功能。</p><p><strong>2.await</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPokemon</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">101</span>; i++) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">getPokemonApi</span>(i)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>            pokemons.<span class="hljs-title function_">push</span>(response.<span class="hljs-property">data</span>)<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">getPokemon</span>()<br></code></pre></td></tr></table></figure><p>await会强制其他代码等待，直到后面的promise执行完毕</p><h2 id="背景色渐变"><a href="#背景色渐变" class="headerlink" title="背景色渐变"></a>背景色渐变</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.body</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to top, <span class="hljs-number">#f3e7e9</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#e3eeff</span> <span class="hljs-number">99%</span>, <span class="hljs-number">#e3eeff</span> <span class="hljs-number">100%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。</p><h2 id="card-模糊效果"><a href="#card-模糊效果" class="headerlink" title="card 模糊效果"></a>card 模糊效果</h2><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220916140510192.png" class="" title="image-20220916140510192"><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">h4</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">10px</span> <span class="hljs-number">5px</span> <span class="hljs-number">10px</span>;<br>    <span class="hljs-comment">// 阴影</span><br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0.3px</span> <span class="hljs-number">0.7px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.126</span>),<br>        <span class="hljs-number">0</span> <span class="hljs-number">0.9px</span> <span class="hljs-number">1.7px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.179</span>), <span class="hljs-number">0</span> <span class="hljs-number">1.8px</span> <span class="hljs-number">3.5px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.224</span>),<br>        <span class="hljs-number">0</span> <span class="hljs-number">3.7px</span> <span class="hljs-number">7.3px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.277</span>), <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">20px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>);<br>    <span class="hljs-comment">// 模糊</span><br>    backdrop-<span class="hljs-attribute">filter</span>: blur(<span class="hljs-number">20px</span>);<br>    <span class="hljs-attribute">transition</span>: <span class="hljs-number">0.5s</span> ease;<br><br>    <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0.7px</span> <span class="hljs-number">1px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.157</span>),<br>            <span class="hljs-number">0</span> <span class="hljs-number">1.7px</span> <span class="hljs-number">2.6px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.224</span>), <span class="hljs-number">0</span> <span class="hljs-number">3.5px</span> <span class="hljs-number">5.3px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.28</span>),<br>            <span class="hljs-number">0</span> <span class="hljs-number">7.3px</span> <span class="hljs-number">11px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.346</span>), <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">30px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>backdrop-filter 和 filter 的区别：</p><p>backdrop-filter 只使背景模糊，不影响内容</p><p>filter 会使整部分都模糊</p><h2 id="head-动画效果"><a href="#head-动画效果" class="headerlink" title="head 动画效果"></a>head 动画效果</h2><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220916204520003.png" class="" title="image-20220916204520003"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/back.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Pokemon<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: Biko;<br>    <span class="hljs-attribute">src</span>: url(<span class="hljs-string">&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/4273/biko-black.woff&quot;</span>);<br>&#125;<br><span class="hljs-selector-class">.head</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-comment">// app.vue 中给 Head 组件设了高度, 因此这里才能 100%</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">align-items</span>: center;<br>    <span class="hljs-comment">// gif 可能过大, 所以溢出隐藏掉 </span><br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-selector-tag">img</span>,<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>        <span class="hljs-attribute">position</span>: absolute;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-selector-tag">img</span> &#123;<br>        <span class="hljs-comment">// object-fit 属性指定元素的内容应该如何去适应指定容器的高度与宽度。</span><br>        <span class="hljs-comment">// cover: 保持原有尺寸比例。但部分内容可能被剪切。</span><br>        <span class="hljs-attribute">object-fit</span>: cover;<br>    &#125;<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10vw</span>;<br>        <span class="hljs-attribute">font-family</span>: Biko, sans-serif;<br>        <span class="hljs-attribute">font-weight</span>: bold;<br>        <span class="hljs-attribute">text-transform</span>: uppercase;<br>        <span class="hljs-attribute">text-align</span>: center;<br>        <span class="hljs-attribute">background</span>: white;<br>        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.7</span>;<br>        <span class="hljs-comment">// 滤色模式</span><br>        <span class="hljs-attribute">mix-blend-mode</span>: screen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心是 mix-blend-mode: screen  滤色模式</strong></p><p><strong>当使用滤色模式,图层中纯黑部分变成完全透明,纯白部分则完全不透明,其他颜色则根据灰度产生各种级别的不透明</strong></p><p>如果不加 opacity 和 mix-blend-mode，则如下所示</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220916210837353.png" class="" title="image-20220916210837353"><p>加上 mix-blend-mode后，白色遮挡，黑色穿透</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220916210928338.png" class="" title="image-20220916210928338"><p>再加上 opacity:0.7</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220916211113363.png" class="" title="image-20220916211113363"><h2 id="card-显示形式"><a href="#card-显示形式" class="headerlink" title="card 显示形式"></a>card 显示形式</h2><p>两种形式</p><ol><li><p>不改变 url，点击 more details 弹出 card，点击其它位置关闭</p></li><li><p>&#x3D;&#x3D;路由&#x3D;&#x3D;，点击 more details 直接跳转路由</p></li></ol><p>最后选择路由，因为想将组件拆小，并且逻辑更清晰些</p><p><a href="https://lol.qq.com/tft/#/champion">云顶官网</a>也是这样做的</p><p>点卡片跳转路由 哈希模式，路由传参 params (传id)，显示在路径上</p><h2 id="多图绕中心旋转"><a href="#多图绕中心旋转" class="headerlink" title="多图绕中心旋转"></a>多图绕中心旋转</h2><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220925194954595.png" class="" title="image-20220925194954595"><p>灵感来源：<a href="https://codepen.io/sparshgupta007/pen/gOeypaj">https://codepen.io/sparshgupta007/pen/gOeypaj</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info-imgs&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info-imgs-box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, , index) in pokemonImgs&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;`--i:$&#123;index&#125;`&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;typeof value === &#x27;string&#x27; &amp;&amp; value&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-keyword">@keyframes</span> rotate&#123;<br>    <span class="hljs-selector-tag">from</span>&#123;<br>        <span class="hljs-comment">// perspective 设定物体到屏幕的距离</span><br>        <span class="hljs-attribute">transform</span>:perspective(<span class="hljs-number">1200px</span>) rotateY(<span class="hljs-number">0deg</span>);<br>    &#125;<br>    <span class="hljs-selector-tag">to</span>&#123;<br>        <span class="hljs-attribute">transform</span>:perspective(<span class="hljs-number">1200px</span>) rotateY(<span class="hljs-number">360deg</span>);<br>    &#125;<br>&#125;<br><span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">-imgs</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">align-items</span>: center;<br>    <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">-box</span> &#123;<br>        <span class="hljs-attribute">position</span>: relative;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">10vw</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br>        <span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d;<br>        <span class="hljs-attribute">animation</span>: rotate <span class="hljs-number">20s</span> linear infinite;<br>        <span class="hljs-selector-tag">span</span> &#123;<br>            <span class="hljs-attribute">position</span>: absolute;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>            <span class="hljs-comment">// 设置元素的子元素是位于 3D 空间中还是平面中。</span><br>            <span class="hljs-attribute">transform-style</span>:preserve-<span class="hljs-number">3</span>d;<br>            <span class="hljs-comment">// 让每张图片 y 方向上旋转一些角度; z 方向上移动一些距离(不然会叠在一起) </span><br>            <span class="hljs-attribute">transform</span>:rotateY(calc(var(--i) * <span class="hljs-number">45deg</span>)) translateZ(<span class="hljs-number">10vw</span>);<br>            <span class="hljs-selector-tag">img</span> &#123;<br>                <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<br>                <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;<br>                <span class="hljs-attribute">object-fit</span>:cover;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心就是利用</p><p>transform-style:preserve-3d和ransform:rotateY(calc(var(–i) * 45deg)) translateZ(10vw)构造一个三维立方体，可以想象在立方体的前后左右四个面各贴一张图片。</p><p>然后 利用动画 rotateY 从 0 到 360 度 让立方体 自转</p><p><strong>补充知识：</strong></p><p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/perspective">perspective</a></strong></p><p>指定了观察者与 z&#x3D;0 平面的距离，使具有三维位置变换的元素产生透视效果。</p><p>perspective 越大，观察者与平面的距离越远，物体越小。</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220925183438206.png" class="" title="image-20220925183438206"><p><strong>html 向 css 传参</strong></p><p>html 中写内联样式 :style&#x3D;”`–i:${index}`“</p><p>css 利用 var 接收 var(–i) </p><h2 id="路由不跳转问题"><a href="#路由不跳转问题" class="headerlink" title="路由不跳转问题"></a>路由不跳转问题</h2><p>同一页面下，query 参数不同，router.push 后页面不跳转。如下图，点击妙蛙花时，路由不跳转。</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220926141821034.png" class="" title="image-20220926141821034"><p>原因：vue官网详细解释说明<strong>使用同一路由携带不同参数，本质上是重用相同的组件实例，默认在跳转路由时会采用缓存策略,并不会刷新当前路由组件</strong>，因此不会调用组件的生命周期挂钩。</p><p>解决：监听 router 的动作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue3">watch: &#123;<br>    &#x27;$route&#x27; (to, from) &#123;<br>        this.$router.go(0);<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h1 id="待做"><a href="#待做" class="headerlink" title="待做"></a>待做</h1><p>类似 <a href="https://50projects50days.com/#projects">https://50projects50days.com/#projects</a></p><p>分页器</p><p>api 等待时，放皮卡丘跑步的 gif</p><p>左侧来一个精灵球，hover弹出很多选项</p><p>精灵间的对比</p><p>公共 interface 写在哪？ vite-env.d.ts里吗？</p><p>background-size: cover 图片大小自适应</p><p>vue3 + ts 的路由：</p><p><a href="https://blog.csdn.net/m0_63677099/article/details/124259762">https://blog.csdn.net/m0_63677099/article/details/124259762</a></p><p><strong>一个很好的参考</strong></p><p><a href="https://codepen.io/tiffachoo/pen/omowyX">https://codepen.io/tiffachoo/pen/omowyX</a></p><h1 id="暂时做不到的"><a href="#暂时做不到的" class="headerlink" title="暂时做不到的"></a>暂时做不到的</h1><p><strong>1.每张卡要有自己的专属图片（最好是炫酷一点的），替代下方统一的图片</strong></p><p>开源 api 中没有</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220924191406689.png" class="" title="image-20220924191406689"><p><strong>2.不同种族的 card 应该有不同的配色方案</strong></p><p>没有 ui，十几个种族，自己设计太麻烦</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式与开发实践</title>
    <link href="/2022/09/05/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/09/05/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象的JS"><a href="#面向对象的JS" class="headerlink" title="面向对象的JS"></a>面向对象的JS</h2><h3 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h3><p>如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子</p><p>只关注对象的行为，而不关注对象本身</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同一操作作用于不同对象上时，可以产生不同的解释和结果。</p><p>多态背后的思想是将 “做什么” 和 “谁去做以及怎样去做，也就是将 ”不变的事物“ 与 ”可能改变的事物” 分类开来。这样后续再增加新的对象时，仅仅增加代码即可，不用再去修改之前的代码。</p><p>使用继承来得到多态效果，是让对象表现出多态性的最常用手段。</p>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue的事件修饰符</title>
    <link href="/2022/09/04/vue%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2022/09/04/vue%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6981628129089421326">https://juejin.cn/post/6981628129089421326</a>  这篇文章写得挺完整了</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事件修饰符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Content-Type</title>
    <link href="/2022/09/04/FormData/"/>
    <url>/2022/09/04/FormData/</url>
    
    <content type="html"><![CDATA[<h1 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h1><p><strong>Content-Type</strong>（MediaType），即是Internet Media Type，互联网媒体类型，也叫做<strong>MIME类型</strong>。在互联网中有成百上千中不同的数据类型，HTTP在传输数据对象时会为他们打上称为MIME的数据格式标签，用于<strong>区分数据类型</strong>。</p><p>在HTTP协议消息头中，使用Content-Type来表示请求和响应中的媒体类型信息。它用来告诉服务端如何处理请求的数据，以及告诉客户端（一般是浏览器）如何解析响应的数据，比如显示图片，解析并展示html等等。</p><p><strong>Content-Type的格式：</strong><br><strong>Content-Type：type&#x2F;subtype ;parameter</strong></p><p>type：主类型，任意的字符串，如text，如果是*号代表所有；<br>subtype：子类型，任意的字符串，如html，如果是*号代表所有，用“&#x2F;”与主类型隔开；<br>parameter：可选参数，如charset，boundary等。</p><p>例如：<br>Content-Type: text&#x2F;html;<br>Content-Type: application&#x2F;json;charset:utf-8;</p><h2 id="application-x2F-json"><a href="#application-x2F-json" class="headerlink" title="application&#x2F;json"></a>application&#x2F;json</h2><p>现在越来越多的应用使用application&#x2F;json，用来告诉服务端消息主体是序列化的json字符串。由于json规范的流行，各大浏览器都开始原生支持JSON.stringfy。</p><p>而且spring对这个content-Type上传的数据有很好的支持，可以直接通过@RequestBody进行接收。也是当前完美适配当前流行的RestApi。</p><p>JSON 是一种轻量级的数据格式，以“键-值”对的方式组织的数据。使用这个类型，需要参数本身就是json格式的数据，参数会被直接放到请求实体里，不进行任何处理。服务端&#x2F;客户端会按json格式解析数据（约定好的情况下）。</p><p>请求参数</p><img src="/2022/09/04/FormData/20190111180712373.png" class="" title="application&#x2F;json请求参数"><p>http 请求报文</p><img src="/2022/09/04/FormData/20190624231555162.png" class="" title="application&#x2F;json报文"><h2 id="application-x2F-x-www-form-urlencoded"><a href="#application-x2F-x-www-form-urlencoded" class="headerlink" title="application&#x2F;x-www-form-urlencoded"></a>application&#x2F;x-www-form-urlencoded</h2><p>在最开始的请求方式中，请求参数都是放在url中，表单提交的时候，都是以key&#x3D;&amp;value&#x3D;的方式写在url后面。这也是浏览器表单提交的默认方式。</p><p>不支持文件，一般用于表单提交。</p><ul><li>请求参数<img src="/2022/09/04/FormData/20190111174842982.png" class="" title="application&#x2F;x-www-form-urlencoded请求参数"></li><li>http 请求报文<img src="/2022/09/04/FormData/20190624231322976.png" class="" title="application&#x2F;x-www-form-urlencoded报文"></li></ul><h2 id="multipart-x2F-form-data"><a href="#multipart-x2F-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>此种方式多用于<strong>文件上传</strong>，表单数据都保存在http的正文部分，各个表单项之间用boundary分开。</p><p>与application&#x2F;x-www-form-urlencoded不同，这是一个多部分多媒体类型。首先生成了一个 boundary 用于分割不同的字段，在请求实体里每个参数以——boundary开始，然后是附加信息和参数名，然后是空行，最后是参数内容。多个参数将会有多个boundary块。如果参数是文件会有特别的文件域。最后以——boundary–为结束标识。multipart&#x2F;form-data支持文件上传的格式，一般需要上传文件的表单则用该类型。</p><p>下面是一个例子：</p><ul><li>请求参数<img src="/2022/09/04/FormData/20190111174827455.png" class="" title="multipart&#x2F;form-data请求参数"></li><li>http 请求报文<img src="/2022/09/04/FormData/20190624231435322.png" class="" title="multipart&#x2F;form-data报文"></li></ul><p><code>Content-Disposition</code> 是必选项， <code>name</code> 属性代表着表单元素的 <code>key</code>，<code>filename</code> 则是上传文件的名称</p><h3 id="为什么需要-FormData"><a href="#为什么需要-FormData" class="headerlink" title="为什么需要 FormData"></a>为什么需要 FormData</h3><p><code>application/json</code> 作为请求头 <code>Content-Type</code> 字段值时，表示告知服务端参数是序列化后的 <code>JSON</code> 字符串，所以一般在传参时都会用 <code>JSON.stringify</code> 序列化一下，但是 <strong><code>JSON.stringify</code> 在转换某一些数据结构时会出问题</strong>，比如 会丢失 function 类型的参数、循环引用时会报错、**<code>Blob</code> &#x2F;<code>File</code> 对象会被转化成 <code>&#123;&#125;</code>**  等等。</p><p>如果要是图片那可以转换成 <code>base64</code> 格式进行上传解决，这种方式虽然可行，但是转换成 <code>base64</code> 格式需要很多字符，占用很多资源，而且很长，不便于阅读，另外就是服务端接收到这个参数还得解析，很麻烦，此时，<code>FormData</code> 就可用上了。</p><h3 id="使用-FormData"><a href="#使用-FormData" class="headerlink" title="使用 FormData"></a>使用 FormData</h3><p>window 上直接挂载了 FormData 对象</p><img src="/2022/09/04/FormData/image-20220904172337954.png" class="" title="image-20220904172337954"><p>我们一般都使用 append 方法</p><p>append 和 set 的区别：</p><p><code>append</code> 的 <code>key</code> 存在，就会附加到已有值集合的后面，而 <code>set</code> 会使用新值覆盖已有的值</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/a772116804/article/details/114586937">https://blog.csdn.net/a772116804/article/details/114586937</a></p><p><a href="https://juejin.cn/post/7057293668440834061">https://juejin.cn/post/7057293668440834061</a></p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>传参</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写常用函数</title>
    <link href="/2022/08/28/%E6%89%8B%E5%86%99%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/2022/08/28/%E6%89%8B%E5%86%99%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一次的once"><a href="#一次的once" class="headerlink" title="一次的once"></a>一次的once</h2><h2 id="只执行一次的-once"><a href="#只执行一次的-once" class="headerlink" title="只执行一次的 once"></a>只执行一次的 once</h2><p>实现一个 once 函数，记忆返回结果只执行一次</p><p>类似于 lodash.once</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// f 是一个函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">x</span>) =&gt; x;<br><br><span class="hljs-keyword">const</span> onceF = <span class="hljs-title function_">once</span>(f);<br><br><span class="hljs-comment">//=&gt; 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onceF</span>(<span class="hljs-number">3</span>))<br><br><span class="hljs-comment">//=&gt; 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onceF</span>(<span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">once</span>(<span class="hljs-params">f</span>) &#123;<br>  <span class="hljs-keyword">let</span> result<br>  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> result<br>    result = <span class="hljs-title function_">f</span>(...args)<br>    flag = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无限累加的-sum"><a href="#无限累加的-sum" class="headerlink" title="无限累加的 sum"></a>无限累加的 sum</h2><p>参数无限，调用次数无限</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">//6</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>).<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">//11</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>).<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">//10</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)(<span class="hljs-number">2</span>).<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">//9</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)(<span class="hljs-number">6</span>).<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">...rest</span>) =&gt; <span class="hljs-title function_">sum</span>(...args, ...rest)<br>  f.<span class="hljs-property">valueOf</span> = <span class="hljs-function">() =&gt;</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> f<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用于函数合成的-compose"><a href="#用于函数合成的-compose" class="headerlink" title="用于函数合成的 compose"></a>用于函数合成的 compose</h2><p>实现一个 compose 函数，进行函数合成，比如 redux 中的 compose，react 高阶组件连续调用时的 compose</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add10</span> = (<span class="hljs-params">x</span>) =&gt; x + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mul10</span> = (<span class="hljs-params">x</span>) =&gt; x * <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">add100</span> = (<span class="hljs-params">x</span>) =&gt; x + <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// (10 + 100) * 10 + 10 = 1110</span><br><span class="hljs-title function_">compose</span>(add10, mul10, add100)(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p><strong>错误的(我最初写的)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> funcs = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>).<span class="hljs-title function_">reverse</span>()<br>  <span class="hljs-keyword">const</span> n = funcs.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      num = funcs[i](num)<br>    &#125;<br>    <span class="hljs-keyword">return</span> num<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然没有考虑函数的参数个数与返回值个数的问题，只用了一个num，默认一个参数了。</p><p><strong>正确版</strong></p><p>利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">array.reduce</a> 函数</p><p>上一次的返回结果会作为下一次的参数，a 为上一个值，b为当前值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">...funcs</span>) &#123;<br>    <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(...args)))<br>&#125;<br></code></pre></td></tr></table></figure><p>是一个正向的，从左向右递推的过程。</p><p>如果 a 是函数，b是参数，就是 (a,b) &#x3D;&gt; a(b)</p><p>但是要考虑到 b 也是函数，所以 b 也得调用一下，得到返回值后再作为 a 的参数传入</p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>手写函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueRouter的hash和history模式</title>
    <link href="/2022/08/28/VueRouter%E7%9A%84hash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/08/28/VueRouter%E7%9A%84hash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="VueRouter的hash和history模式"><a href="#VueRouter的hash和history模式" class="headerlink" title="VueRouter的hash和history模式"></a>VueRouter的hash和history模式</h2><p><code>vue-router</code> 在实现单页面前端路由时，提供了两种方式：<code>Hash</code> 模式和 <code>History</code> 模式</p><p>vue2 是根据 <code>mode</code> 参数来决定采用哪一种方式</p><p>vue3 则是 <code>history</code> 参数</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>localhost:8080&#x2F;#&#x2F;home</p><ul><li><code>vue-router</code> 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。  <code>hash</code>（#）是 <code>URL</code> 的锚点，代表的是网页中的一个位置，单单改变 <code>#</code> 后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 <code>#</code> 是用来指导浏览器动作的，对服务器端完全无用，<code>HTTP</code> 请求中也不会不包括 <code>#</code> ，同时每一次改变 <code>#</code> 后的部分，都会在浏览器的访问历史中增加一个记录，使用 “后退” 按钮，就可以回到上一个位置，所以说 <code>hash</code> 模式通过锚点值的改变，根据不同的值，渲染指定 <code>DOM</code> 位置的不同数据。</li><li><code>#</code> 符号本身以及它后面的字符称之为 <code>hash</code>，可通过<code> window.location.hash</code> 属性读取。</li><li><code>hash</code> 通过 <code>window.onhashchange</code> 的方式，来监听 <code>hash</code> 的改变，借此实现无刷新跳转的功能。</li></ul><h4 id="设置hash模式"><a href="#设置hash模式" class="headerlink" title="设置hash模式"></a>设置hash模式</h4><p>vue2 中默认为 mode:hash</p><p>vue3 中使用 createWebHashHistory</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue3">import &#123; createWebHashHistory &#125; from &#x27;vue-router&#x27;<br><br>const router = createRouter(&#123;<br>  history: createWebHistory(),<br>  routes<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><h4 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h4><p>localhost:8080&#x2F;home</p><p><code>history</code> 是路由的另一种模式，由于 hash 模式会在 url 中带#，如果不想要带 #的话，我们可以使用路由的 <code>history</code> 模式，只需要在响应的 <code>router</code> 配置规则时加上即可，<code>vue</code> 的路由默认是 <code>hash</code> 模式。</p><p>利用了<code>HTML5 History Interface</code>中新增的 <code>pushState()</code> 和<code> replaceState()</code> 方法。</p><p>这两个方法应用于浏览器的历史记录栈，在当前已有的<code> back、forward、go</code> 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>美观，没有#</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p><strong>需要后端配置（nginx代理转发，找不到就重定向到项目首页）</strong></p><p>否则刷新页面会报404，因为会重新发请求，而此时的 url 已经改变。</p><p>具体的说：当我们把 history 项目部署到服务器中后,此时我们在浏览器输入一个网址(比如是 <a href="https://link.juejin.cn/?target=http://www.test.com">www.test.com</a> ), 此时会经过 dns 解析，拿到 ip 地址后根据 ip 地址向该服务器发起请求,服务器接受到请求后,然后返回相应的结果(html,css,js)。如果我们在前端设置了重定向，此时页面会进行跳转到  <a href="https://link.juejin.cn/?target=http://www.test.com/home">www.test.com/home</a> ,在前端会进行匹配对应的组件然后将其渲染到页面上。此时如果我们刷新页面的话，浏览器会发送新的请求 <a href="https://link.juejin.cn/?target=http://www.test.com/home">www.test.com/home</a>, 如果后端服务器没有 &#x2F;home 对应的接口，那么就会返回404。</p><p>hash模式不会404，因为 #及之后的内容并不会放入请求</p><p>注意：开发环境没有这个问题，因为 webpack 处理好了。生产环境才会有问题。</p><h4 id="设置history模式"><a href="#设置history模式" class="headerlink" title="设置history模式"></a>设置history模式</h4><p>vue2 中设置 mode:history</p><p>vue3 中设置 createWebHistory</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue3">import &#123; createWebHistory &#125; from &#x27;vue-router&#x27;<br><br>const router = createRouter(&#123;<br>  history: createWebHistory(),<br>  routes<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="实际项目中对两种模式的使用"><a href="#实际项目中对两种模式的使用" class="headerlink" title="实际项目中对两种模式的使用"></a>实际项目中对两种模式的使用</h3><img src="/2022/08/28/VueRouter%E7%9A%84hash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F/image-20220911221416987.png" class="" title="image-20220911221416987"><p>我们看 vue3 的官网</p><p>点击左侧的章节，中间部分会被整体替换，使用的是 history 模式。url 如下</p><p><a href="https://cn.vuejs.org/guide/introduction.html">https://cn.vuejs.org/guide/introduction.html</a></p><p>点击右侧的本页目录，中间部分不会替换，而是滚动到对应位置，使用的是 hash 模式。url 如下</p><p><a href="https://cn.vuejs.org/guide/typescript/composition-api.html#typing-component-props">https://cn.vuejs.org/guide/typescript/composition-api.html#typing-component-props</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/7116336664540086286#heading-7">https://juejin.cn/post/7116336664540086286#heading-7</a></p><p><a href="https://juejin.cn/post/7096034733649297421">https://juejin.cn/post/7096034733649297421</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>declare</title>
    <link href="/2022/08/12/declare/"/>
    <url>/2022/08/12/declare/</url>
    
    <content type="html"><![CDATA[<h1 id="Declare"><a href="#Declare" class="headerlink" title="Declare"></a>Declare</h1><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><h3 id="什么是声明文件"><a href="#什么是声明文件" class="headerlink" title="什么是声明文件"></a>什么是声明文件</h3><p><strong>声明文件就是给js代码补充类型标注</strong>. 这样在ts编译环境下就不会提示js文件”缺少类型”.</p><p>声明文件以<code>.d.ts</code>结尾，一般<strong>放在根目录下</strong>。</p><h3 id="查看库的声明文件"><a href="#查看库的声明文件" class="headerlink" title="查看库的声明文件"></a>查看库的声明文件</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 以 jquery 为例</span><br>npm i <span class="hljs-meta">@types</span>/jquery<br></code></pre></td></tr></table></figure><p>安装后, 我们可以在<code>node_modules/@types/jquery</code>中的看到声明文件</p><p>如果找不到，就需要自己手写了</p><h2 id="怎么写声明文件"><a href="#怎么写声明文件" class="headerlink" title="怎么写声明文件"></a>怎么写声明文件</h2><h3 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h3><h4 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h4><p>通过<code>declare</code>我们可以标注js全局变量的类型.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// global.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">o</span>: <span class="hljs-built_in">object</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">enum</span> dir &#123;<br>    top,<br>    right,<br>    bottom,<br>    left<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts">n = <span class="hljs-number">321</span><br>s = <span class="hljs-string">&#x27;文字&#x27;</span><br><span class="hljs-keyword">let</span> o1 = o;<br><span class="hljs-title function_">f</span>(<span class="hljs-string">&#x27;123&#x27;</span>).<span class="hljs-title function_">toFixed</span>();<br>dir.<span class="hljs-property">bottom</span>.<span class="hljs-title function_">toFixed</span>();<br><br><span class="hljs-comment">// 报错</span><br>n = <span class="hljs-string">&#x27;312&#x27;</span><br>s = 123g<span class="hljs-string">&#x27;yo是哟个</span><br></code></pre></td></tr></table></figure><h4 id="declare-namespace"><a href="#declare-namespace" class="headerlink" title="declare namespace"></a><strong>declare namespace</strong></h4><p>这个<code>namespace</code>代表后面的全局变量是一个对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// global.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-attr">n</span>:<span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-attr">f</span>:<span class="hljs-function">(<span class="hljs-params">s:<span class="hljs-built_in">string</span></span>)=&gt;</span><span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">s</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">n</span>.<span class="hljs-title function_">toFixed</span>();<br><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-title function_">f</span>(<span class="hljs-string">&#x27;文字&#x27;</span>).<span class="hljs-title function_">toFixed</span>();<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">s</span>.<span class="hljs-title function_">toFixed</span>();<br><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">n</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-title function_">f</span>(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><h4 id="修改已存在的全局声明"><a href="#修改已存在的全局声明" class="headerlink" title="修改已存在的全局声明"></a>修改已存在的全局声明</h4><p><code>node_modules/typescript/lib</code>下，有很多系统变量的声明文件</p><p>如果你要修改<strong>已存在</strong>的全局变量的声明可以这么写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">global</span> &#123;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">String</span> &#123;<br>        <span class="hljs-title function_">hump</span>(<span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 注意: 修改&quot;全局声明&quot;必须在模块内部, 所以至少要有 export&#123;&#125;字样</span><br><span class="hljs-comment">// 不然会报错❌: 全局范围的扩大仅可直接嵌套在外部模块中或环境模块声明中</span><br><span class="hljs-keyword">export</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>现在<code>String</code>类型在vscode的语法提示下多了一个<code>hump</code>的方法,不过我们只是声明, 并没有用js实现, 所以运行会报错。</p><h3 id="模块声明"><a href="#模块声明" class="headerlink" title="模块声明"></a>模块声明</h3><h4 id="什么是模块声明"><a href="#什么是模块声明" class="headerlink" title="什么是模块声明"></a>什么是模块声明</h4><p>npm下载的”包”自带了声明文件, 如果我们需要对其类型声明进行扩展就可以使用”<strong>declare module</strong>“语法。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br>app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$axios</span> = axios;<br></code></pre></td></tr></table></figure><p>功能上我们实现了”this.axios”,但是ts并不能自动推断出我们添加了axios”, 所以添加如下声明文件:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// global.d.ts</span><br><br><span class="hljs-comment">// axios的实例类型</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AxiosInstance</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 声明要扩充@vue/runtime-core包的声明.</span><br><span class="hljs-comment">// 这里扩充&quot;ComponentCustomProperties&quot;接口, 因为他是vue3中实例的属性的类型.</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;@vue/runtime-core&#x27;</span> &#123;<br>  <br>  <span class="hljs-comment">// 给`this.$http`提供类型</span><br>  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ComponentCustomProperties</span> &#123;<br>    <span class="hljs-attr">$axios</span>: <span class="hljs-title class_">AxiosInstance</span>;<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>这里扩充”<strong>ComponentCustomProperties</strong>“接口, 因为他是vue3中实例的属性的类型.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a href="https://juejin.cn/post/7008710181769084964">参考</a></h2><p>本文绝大部分内容来源于下面两篇文章</p><p><a href="https://juejin.cn/post/6844903993727008776">https://juejin.cn/post/6844903993727008776</a></p><p><a href="https://juejin.cn/post/7008710181769084964">https://juejin.cn/post/7008710181769084964</a></p>]]></content>
    
    
    <categories>
      
      <category>TS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么React官网那么快</title>
    <link href="/2022/08/08/%E4%B8%BA%E4%BB%80%E4%B9%88React%E5%AE%98%E7%BD%91%E9%82%A3%E4%B9%88%E5%BF%AB/"/>
    <url>/2022/08/08/%E4%B8%BA%E4%BB%80%E4%B9%88React%E5%AE%98%E7%BD%91%E9%82%A3%E4%B9%88%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="服务端渲染-SSR"><a href="#服务端渲染-SSR" class="headerlink" title="服务端渲染 SSR"></a>服务端渲染 SSR</h2><p>无论是服务端渲染还是客户端渲染，一开始都是要请求一个 <code>HTML</code> 文本，但是区别就在于这个文本是否已经被服务端组装好了</p><ul><li>客户端渲染还需要去下载和执行<code>Javascript</code>脚本之后才能得到我们想要的页面效果，所以速度会比服务端渲染慢很多</li><li>服务端渲染得到的<code>HTML</code>文档就已经组合好了对应的文本，浏览器请求到之后直接解析渲染出来即可，不需要再去下载和执行额外的<code>Javasript</code> 脚本，所以速度会比客户端渲染快很多</li></ul><p>下图是客户端渲染和服务端渲染的流程图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/610390beb91049e49c897392fe130d3d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="预加载-x2F-预处理资源"><a href="#预加载-x2F-预处理资源" class="headerlink" title="预加载&#x2F;预处理资源"></a>预加载&#x2F;预处理资源</h2><h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h3><p>关键字 <strong>preload</strong> 作为元素 <code>&lt;link&gt;</code> 的属性 <code>rel</code>的值，表示用户十分有可能需要在当前浏览中加载目标资源，所以<strong>浏览器必须预先获取和缓存对应资源</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;script&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/webpack-runtime-732352b70a6d0733ac95.js&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>好处就是让在当前页面中可能被访问到的资源提前加载但并不阻塞页面的初步渲染，进而提升性能。</p><blockquote><p>注意：使用 <code>preload</code>作为 <code>link</code>标签<code>rel</code>属性的属性值的话一定要记得在标签上添加 <code>as</code>属性，其属性值就是要预加载的内容类型</p></blockquote><h3 id="preconnect"><a href="#preconnect" class="headerlink" title="preconnect"></a>preconnect</h3><p><strong>preconnect</strong> 是提示浏览器用户可能需要来自目标域名的资源，因此<strong>浏览器可以通过抢先启动与该域名的连接</strong>来改善用户体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preconnect&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.google-analytics.com&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="dns-prefetch"><a href="#dns-prefetch" class="headerlink" title="dns-prefetch"></a>dns-prefetch</h3><p><strong>DNS-prefetch</strong> (<strong>DNS 预获取</strong>) 是尝试<strong>在请求资源之前解析域名</strong>。这可能是后面要加载的文件，也可能是用户尝试打开的链接目标。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.google-analytics.com&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="prefetch"><a href="#prefetch" class="headerlink" title="prefetch"></a>prefetch</h3><p><strong>prefetch</strong> 作为元素 的属性 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link%23attr-rel">rel</a> 的值，是为了提示浏览器，用户未来的浏览有可能需要加载目标资源，所以<strong>浏览器会事先获取和缓存对应资源</strong>，优化用户体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/page-data/docs/getting-started.html/page-data.json&quot;</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;fetch&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>什么时候使用：</strong></p><p><strong>当你的页面中具有可能跳转到其他页面的路由链接时</strong>，就可以使用<code>prefetch</code> 预请求对应页面的资源了。如果一个页面中路由链接太多，全部发一遍显然浪费流量，也不利于性能优化。</p><p>可以通过监听 <code>Link</code>元素，当其出现到可见区域时动态插入带有<code>prefetch</code>属性值的<code>link</code>标签到<code>HTML</code>文档中，从而去预加载对应路由页面的一些资源，这样当用户点击路由链接跳转过去时由于资源已经请求好所以页面加载会特别快。（<strong>懒加载思想</strong>）</p><h3 id="preload-和-prefetch-的区别"><a href="#preload-和-prefetch-的区别" class="headerlink" title="preload 和 prefetch 的区别"></a>preload 和 prefetch 的区别</h3><p>两者都用于提前获取和缓存对应资源</p><p>preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度</p><p>prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7128369638794231839">https://juejin.cn/post/7128369638794231839</a> 本文绝大部分内容来源于这篇文章</p>]]></content>
    
    
    <categories>
      
      <category>优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSR</tag>
      
      <tag>预加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实习记录</title>
    <link href="/2022/08/01/%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/08/01/%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h2><p>npm install 失败</p><p>将 package-lock.json 文件删去后，再 install 才成功</p><p>原因大概是团队中的 node 版本不同</p><p><strong><a href="https://juejin.cn/post/7078233610683170824">package-lock.json</a></strong></p><p>package-lock.json 会<strong>在 npm 更改 node_modules 目录树 或者 package.json 时自动生成</strong> ，它准确的描述了当前项目npm包的依赖树，并且在随后的安装中会根据 package-lock.json 来安装，保证是相同的一个依赖树，不考虑这个过程中是否有某个依赖有小版本的更新。（安装依赖时，优先 package-lock.json ，没有时再看 package.json）</p><p>它的产生就是来对整个依赖树进行版本固定的（锁死）。</p><p>注意，使用<code>cnpm install</code>时候，并不会生成 <code>package-lock.json</code> 文件，也不会根据 <code>package-lock.json</code> 来安装依赖包，还是会使用 <code>package.json</code> 来安装。</p><h2 id="修复漏洞"><a href="#修复漏洞" class="headerlink" title="修复漏洞"></a>修复漏洞</h2><p>修复上线前检测出的漏洞，主要是<strong>基于 DOM 的 XSS 攻击的安全隐患</strong>。</p><p><a href="https://blog.csdn.net/lgxzzz/article/details/125010336">https://blog.csdn.net/lgxzzz/article/details/125010336</a></p><p>相关插件 xss &#x2F; vue-xss(只支持 js) &#x2F; vue-dompurify-html</p><p>发现问题主要是因为使用了 v-html</p><p><strong>1.通过 vue-dompurify-html 插件 实现</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> vue-dompurify-<span class="hljs-selector-tag">html</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">import VueDOMPurifyHTML from &#x27;vue-dopurify-html&#x27;<br><br>app.use(VueDOMPurifyHTML)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">v-dompurify-html = <span class="hljs-string">&quot;rawHtml&quot;</span><br></code></pre></td></tr></table></figure><p><strong>2.通过 xss 插件实现</strong></p><p><a href="https://github.com/leizongmin/js-xss">https://github.com/leizongmin/js-xss</a></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> xss<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置白名单</span><br><span class="hljs-keyword">var</span> options = &#123;<br>    <span class="hljs-attr">whiteList</span>: &#123;<br>        <span class="hljs-attr">a</span>: [<span class="hljs-string">&quot;href&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>],<br>    &#125;,<br>&#125;<br><br><span class="hljs-comment">// 实例化</span><br>myxss = <span class="hljs-keyword">new</span> xss.<span class="hljs-title class_">FilterXSS</span>(options);<br><br><span class="hljs-comment">// 对需要转义的部分调用myxss.process()</span><br>html = myxss.<span class="hljs-title function_">process</span>(<span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="后台管理系统新增页面"><a href="#后台管理系统新增页面" class="headerlink" title="后台管理系统新增页面"></a>后台管理系统新增页面</h2><h3 id="曲库管理"><a href="#曲库管理" class="headerlink" title="曲库管理"></a>曲库管理</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于从后台管理系统将音乐资源导入数据库，从而显示在 APP 中。</p><h4 id="主要需求"><a href="#主要需求" class="headerlink" title="主要需求"></a>主要需求</h4><p>资源有三个级别：教材 &gt; 专辑 &gt; 单曲，每个级别都可以新增（上传）或删除。</p><p>输入框用于搜索教材，单选框用于固定乐器</p><p>可以下载教材到本地</p><h3 id="APP版本管理"><a href="#APP版本管理" class="headerlink" title="APP版本管理"></a>APP版本管理</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>用于记录与管理 APP 版本的迭代信息。</p><p>两个 APP ：调音器 &#x2F; 好乐器</p><p>两个 os：ios &#x2F; 安卓</p><h4 id="主要需求-1"><a href="#主要需求-1" class="headerlink" title="主要需求"></a>主要需求</h4><p>新增版本</p><p>查看版本详情</p><h2 id="首页新增陪练总览部分"><a href="#首页新增陪练总览部分" class="headerlink" title="首页新增陪练总览部分"></a>首页新增陪练总览部分</h2><p>查看陪练的用户信息以及答题信息</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>技术上没什么太难的地方</p><p>但是当时有两个问题花了我比较久的时间。</p><p>一个问题是在上传资源的时候，资源会丢失，我找了很久问题的原因，后面问了 leader 才知道是被平安拦截掉了，平安的安全措施比较严格，不能从内网向外网传稍大的资源。这个问题要完全解决非常麻烦，可能架构上要改，所以就没有从技术层面去解决，而是在上传资源的时候切到外网。</p><h2 id="音乐基础新增试唱功能"><a href="#音乐基础新增试唱功能" class="headerlink" title="音乐基础新增试唱功能"></a>音乐基础新增试唱功能</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>一种新题型，原先的题型主要都是选择题。</p><h3 id="主要需求-2"><a href="#主要需求-2" class="headerlink" title="主要需求"></a>主要需求</h3><p>给一个谱子，用户点击 button 倒计时后开始清唱，用户开始唱的时候会录音，同时会有一个小方块来提示用户唱到哪一个音符了。这个小方块会随着时间移动，当它移动到某个音符的上面，就说明应该唱到这个音了。唱完之后会将录音传给后端，使用算法比对进行打分，然后返回一个分数给用户。</p><p>两种谱子：五线谱 &#x2F; 简谱</p><p>两种谱子给的资源不一致</p><p>五线谱有 xml 文件，将其转为 json 后，解构获得有效信息，主要是每个音符的 起始时间、终止时间、和在谱子中的位置</p><p>简谱没有 xml 文件，因此需要 解析 mid 文件来获取每个音符的时间信息，而位置信息要根据谱子来计算，因为谱子的制定是有规则的，谱子里的距离和时间是线性的，我们可以通过音符的时间信息计算出他们的位置。</p><p>而有每个音符触发的时间有音符在谱子中所处的位置，我们就可以控制方块在正确的时间处于正确的位置上来提醒用户。</p><h3 id="零碎的需求"><a href="#零碎的需求" class="headerlink" title="零碎的需求"></a>零碎的需求</h3><p>五线谱 &#x2F; 简谱 的切换</p><p>播放录音</p><p>播放范唱（midi，人声）</p><p>控制速度</p><p>节拍器</p><h3 id="难点-1"><a href="#难点-1" class="headerlink" title="难点"></a>难点</h3><p>控制方块的位置，花了些时间计算</p><p>对于 midi 文件的理解与处理，npm 上找了很多包来解析 midi 和播放 midi</p>]]></content>
    
    
    <categories>
      
      <category>实习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解ES6</title>
    <link href="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    <url>/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/</url>
    
    <content type="html"><![CDATA[<h1 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721192756233.png" class="" title="image-20220721192756233"><p>没什么新的东西 就不写了</p><p>不知道为什么这本书后面都用的 var</p><h1 id="字符串与正则表达式"><a href="#字符串与正则表达式" class="headerlink" title="字符串与正则表达式"></a>字符串与正则表达式</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721192733715.png" class="" title="image-20220721192733715"><h2 id="更好的-Unicode-支持"><a href="#更好的-Unicode-支持" class="headerlink" title="更好的 Unicode 支持"></a>更好的 Unicode 支持</h2><h3 id="关于-Unicode"><a href="#关于-Unicode" class="headerlink" title="关于 Unicode"></a><a href="https://www.cnblogs.com/yongG/p/12153646.html">关于 Unicode</a></h3><p>Unicode使用16位二进制来存储文字。我们将一个16位的二进制编码叫做一个码元（Code Unit），Unicode编码范围在0 - 2^16。也就是我们所说的占一个字节。</p><p>由于技术的发展，Unicode对文字编码进行了扩展，将某些文字扩展到了32位（占用两个码元），并且，将某个文字对应的二进制数字叫做码点（Code Point），Unicode编码范围在0 - 2^32，占2个字节。</p><p>特别要注意，码点可以是一个码元，也可以是两个码元。</p><p>字符串的length属性返回的是码元。所以在对一些字符串如果要处理长度的时候要注意这一点。</p><p><strong>ES6 为了支持 Unicode 的发展也新增了一些方法</strong></p><h3 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h3><p>可以在给定字符串中按位置提取 Unicode 代码点。该方法接受的是<strong>码元位置</strong>而非字符位置，并返回一个整数值。</p><p><strong>charCodeAt 的优化版</strong></p><p>charCodeAt是根据码元来匹配，codePointAt是根据码点来进行匹配的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;𘚠a&quot;</span> ;<span class="hljs-comment">// 特殊字符显示不出来</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 55329</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 56992</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 97</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 100000</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 56992</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 97</span><br></code></pre></td></tr></table></figure><p><strong>判断字符包含了一个还是两个码元</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 16 位字符的上边界用十六进制表示就是 FFFF ，因此任何大于该数字的代码点必须用两个码元（共 32 位）来表示。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">is32Bit</span>(<span class="hljs-params">c</span>) &#123;<br>    <span class="hljs-keyword">return</span> c.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>) &gt; <span class="hljs-number">0xFFFF</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>String.fromCodePoint</strong></p><p>codePointAt() 的逆操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCodePoint</span>(<span class="hljs-number">134071</span>))   <span class="hljs-comment">// 𠮷</span><br></code></pre></td></tr></table></figure><p>codePointAt &lt;—&gt; fromCodePoint</p><p>charCodeAt &lt;—&gt; fromCharCode</p><h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h3><p>开发国际化应用时，这个方法很重要</p><p>在比较字符串时，必须被标准化为同一种形式</p><h3 id="正则表达式-u-标志"><a href="#正则表达式-u-标志" class="headerlink" title="正则表达式 u 标志"></a>正则表达式 u 标志</h3><p>正则表达式假定单个字符由一个16位的码元表示。为了解决这个问题，ES6 定义了用于处理 Unicode 的 u 标志</p><p>当一个正则表达式设置了 u 标志后看，工作表模式将切换到针对字符，而不是针对码元</p><p><strong>计算码点数量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">codePointLength</span>(<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = text.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[\s\S]/gu</span>)<br>    <span class="hljs-keyword">return</span> result ? result.<span class="hljs-property">length</span> : <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>判断是否支持 u 标志</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasRegExpU</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> pattern = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串的其他改动"><a href="#字符串的其他改动" class="headerlink" title="字符串的其他改动"></a>字符串的其他改动</h2><h3 id="识别子字符串的方法"><a href="#识别子字符串的方法" class="headerlink" title="识别子字符串的方法"></a>识别子字符串的方法</h3><p><strong>includes()</strong> 方法，在给定文本存在于字符串中的任意位置时会返回 true ，否则返回false ；</p><p><strong>startsWith()</strong> 方法，在给定文本出现在字符串起始处时返回 true ，否则返回 false ；</p><p><strong>endsWith()</strong> 方法，在给定文本出现在字符串结尾处时返回 true ，否则返回 false 。</p><p>每个方法都接受两个参数：<strong>需要搜索的文本</strong>，以及<strong>可选的搜索起始位置索引</strong>。</p><p>当提供了第二个参数时， includes() 与 startsWith() 方法会从该索引位置开始尝试匹配；而<strong>endsWith() 方法会将字符串长度减去该参数</strong>，以此为起点开始尝试匹配。</p><p>当第二个参数未提供时， includes() 与 startsWith() 方法会从字符串起始处开始查找，而 endsWith() 方法则从尾部开始。实际上，第二个参数减少了搜索字符串的次数。以下是使用这些方法的演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&quot;Hello world!&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;Hello&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;!&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;o&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;o&quot;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;world!&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;x&quot;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>若你需要找到它们在另一个字符串中的确切位置，则需要使用 indexOf() 和 lastIndexOf() 。</strong></p><p>如果向 startsWith() 、 endsWith() 或 includes() 方法传入了正则表达式,会抛出错误。</p><p>而 indexOf() 以及 lastIndexOf() 会将正则表达式转换为字符串并搜索它。</p><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>ES6 还为字符串添加了一个 repeat() 方法，它接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;x&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// &quot;xxx&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;hellohello&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;abc&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;abcabcabcabc&quot;</span><br></code></pre></td></tr></table></figure><h2 id="正则表达式的其他改动"><a href="#正则表达式的其他改动" class="headerlink" title="正则表达式的其他改动"></a>正则表达式的其他改动</h2><h3 id="y-标志"><a href="#y-标志" class="headerlink" title="y 标志"></a>y 标志</h3><p>y 标志影响正则表达式搜索时的粘连（ sticky ）属性，它表示从正则表达式的 lastIndex 属性值的位置开始检索字符串中的匹配字符。如果在该位置没有匹配成功，那么正则表达式将停止检索</p><h3 id="复制正则表达式"><a href="#复制正则表达式" class="headerlink" title="复制正则表达式"></a>复制正则表达式</h3><p>允许复制正则表达式时修改标志</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re1 = <span class="hljs-regexp">/ab/i</span>,<br><span class="hljs-comment">// ES5 中会抛出错误, ES6 中可用</span><br>re2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(re1, <span class="hljs-string">&quot;g&quot;</span>);<span class="hljs-comment">// 如果没有第二个参数, re2 就会拥有与 re1 相同的标志。</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &quot;/ab/i&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re2.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &quot;/ab/g&quot;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;ab&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;ab&quot;</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;AB&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;AB&quot;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="flags-属性"><a href="#flags-属性" class="headerlink" title="flags 属性"></a>flags 属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/ab/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re.<span class="hljs-property">source</span>); <span class="hljs-comment">// &quot;ab&quot; ES5就有</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re.<span class="hljs-property">flags</span>); <span class="hljs-comment">// &quot;g&quot;</span><br></code></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p><strong>模板字符串解决了什么问题：</strong></p><p>多行字符串：针对多行字符串的形式概念；</p><p>基本的字符串格式化：将字符串部分替换为已存在的变量值的能力；</p><p>HTML 转义：能转换字符串以便将其安全插入到 HTML 中的能力。</p><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = <span class="hljs-string">`Multiline</span><br><span class="hljs-string">string`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <br><span class="hljs-comment">// &quot;Multiline</span><br><span class="hljs-comment">// string&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">length</span>); <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure><p>反引号之内的所有空白符都是字符串的一部分，因此需要留意缩进</p><p>如果让多行文本保持合适的缩进很重要，考虑将多行模板字面量的第一行空置并在此后进行缩进</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> html = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;div&gt;</span><br><span class="hljs-string">&lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="hljs-string">&lt;/div&gt;`</span>.<span class="hljs-title function_">trim</span>();<br></code></pre></td></tr></table></figure><h3 id="制造替代位"><a href="#制造替代位" class="headerlink" title="制造替代位"></a>制造替代位</h3><p>${任意表达式}</p><p>模板字面量本身也是 JS 表达式，因此可嵌套</p><h3 id="标签化模板"><a href="#标签化模板" class="headerlink" title="标签化模板"></a>标签化模板</h3><p>一个模板标签（ template tag ）能对模板字面量进行转换并返回最终的字符串值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = tag<span class="hljs-string">`Hello world`</span>;<br></code></pre></td></tr></table></figure><p>标签（ tag ）是函数，它被调用时接收需要处理的模板字面量数据。标签所接收的数据被划分为独立片段，并且必须将它们组合起来以创建结果。第一个参数是个数组，包含被 JS 解释过的字面量字符串，随后的参数是每个替换位的解释值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span>(<span class="hljs-params">literals, ...substitutions</span>) &#123;<br>    <span class="hljs-comment">// 返回一个字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内置的标签 String.raw()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message1 = <span class="hljs-string">`Multiline\nstring`</span>,<br>message2 = <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`Multiline\nstring`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message1);<br><span class="hljs-comment">// &quot;Multiline</span><br><span class="hljs-comment">// string&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message2); <span class="hljs-comment">// &quot;Multiline\\nstring&quot;</span><br></code></pre></td></tr></table></figure><p>内部实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">raw</span>(<span class="hljs-params">literals, ...substitutions</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">// 仅使用 substitution 的元素数量来进行循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; substitutions.<span class="hljs-property">length</span>; i++) &#123;<br>        result += literals.<span class="hljs-property">raw</span>[i]; <span class="hljs-comment">// 改为使用原始值</span><br>        result += substitutions[i];<br>    &#125;<br>    <span class="hljs-comment">// 添加最后一个字面量</span><br>    result += literals.<span class="hljs-property">raw</span>[literals.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">let</span> message = raw<span class="hljs-string">`Multiline\nstring`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// &quot;Multiline\\nstring&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">length</span>); <span class="hljs-comment">// 17</span><br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721204939237.png" class="" title="image-20220721204939237"><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>参数默认值的存在触发了 arguments 对象与具名参数的分离</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 非严格模式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mixArgs</span>(<span class="hljs-params">first, second = <span class="hljs-string">&quot;b&quot;</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>);          <span class="hljs-comment">// 1</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// true  </span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// false</span><br>    first = <span class="hljs-string">&quot;c&quot;</span>;<br>    second = <span class="hljs-string">&quot;d&quot;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// false</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// false</span><br>&#125;<br><span class="hljs-title function_">mixArgs</span>(<span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure><p>参数默认值可以使用表达式</p><p>参数默认值存在暂时性死区</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">first = second, second</span>) &#123;<br>    <span class="hljs-keyword">return</span> first + second;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 抛出错误</span><br></code></pre></td></tr></table></figure><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>…具名参数</p><p>是包含传递给函数的其余参数的一个数组</p><p>函数的 length 属性用于指示剧名参数的数量，而剩余参数对其毫无影响</p><p><strong>剩余参数的限制条件：</strong></p><p>一、函数只能有一个剩余参数，并且它必须被放在最后。</p><p>二、剩余参数不能在对象字面量的 setter 属性中使用。（对象字面量的 setter 被限定只能使用单个参数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> object = &#123;<br><span class="hljs-comment">// 语法错误：不能在 setter 中使用剩余参数</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">...value</span>) &#123;<br>        <span class="hljs-comment">// 一些操作</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>设计剩余参数是为了替代 ES 中的 arguments</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkArgs</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args.<span class="hljs-property">length</span>);<span class="hljs-comment">// 2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>);<span class="hljs-comment">// 2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args[<span class="hljs-number">0</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);<span class="hljs-comment">// a a</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args[<span class="hljs-number">1</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<span class="hljs-comment">// b b</span><br>&#125;<br><span class="hljs-title function_">checkArgs</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>拓展运算符</strong></p><p>拓展运算符常和剩余参数一起使用</p><p>以一个例子为例，查找数组最大值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES5及以前</span><br><span class="hljs-keyword">let</span> values = [<span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">75</span>, <span class="hljs-number">100</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Math</span>, values)); <span class="hljs-comment">// 100</span><br><br><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">let</span> values = [<span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">75</span>, <span class="hljs-number">100</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...values)); <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><h2 id="ES6-的名称属性"><a href="#ES6-的名称属性" class="headerlink" title="ES6 的名称属性"></a>ES6 的名称属性</h2><p>匿名函数使得调试困难，因此 ES6 给所有函数添加了 name 属性。name 仅用于在调试时获得函数的相关信息，不能获取对函数的引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">var</span> doAnotherThing = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doSomething.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;doSomething&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doAnotherThing.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;doAnotherThing&quot;</span><br></code></pre></td></tr></table></figure><p><strong>特殊情况</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> doSomething = <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingElse</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">firstName</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Nicholas&quot;</span><br>&#125;,<br>    <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doSomething.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;doSomethingElse&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">sayName</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;sayName&quot;</span><br><span class="hljs-keyword">var</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(person, <span class="hljs-string">&quot;firstName&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">get</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;get firstName&quot;</span><br></code></pre></td></tr></table></figure><p>getter 函数会有 get 前缀，setter 函数会有 set 前缀</p><p>getter 与 setter 函数都必须使用 Object.getOwnPropertyDescriptor 来检索</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> doSomething = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doSomething.<span class="hljs-title function_">bind</span>().<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;bound doSomething&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>()).<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;anonymous&quot;</span><br></code></pre></td></tr></table></figure><p>使用 bind() 创建的函数会有 bound 前缀</p><p>使用 Function 构造器创建的函数会有 anonymous 前缀</p><h2 id="明确函数的双重用途"><a href="#明确函数的双重用途" class="headerlink" title="明确函数的双重用途"></a>明确函数的双重用途</h2><p>一般函数 和 构造函数(new)，构造函数名首字母大写</p><p>JS 为函数提供了两个内部方法，[[Call]] 和 [[Construct]]</p><p>函数未使用 new 调用时，[[call]] 方法执行，运行函数体</p><p>函数使用 new 调用时，[[Construct]] 方法调用，创建一个新的对象，并且以该对象为 this 执行函数体</p><p>拥有 [[Constructor]] 方法的函数被称为构造器</p><p><strong>判断调用的是什么方法</strong></p><p>当 [[Constructor]] 被调用时，new.target 为 new 调用的构造函数</p><p>当 [[Call]] 被调用时，new.target 为 undefiend</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>)<span class="hljs-comment">// [Function: Person]</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 使用 new</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You must use new with Person.&quot;</span>)<br>    &#125;   <br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><span class="hljs-keyword">var</span> notAPerson = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">&quot;Michael&quot;</span>); <span class="hljs-comment">// 出错！</span><br></code></pre></td></tr></table></figure><h2 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h2><p>块级函数会被提升到所在代码块的顶部</p><p>而使用 let 的函数表达式不会</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>没有 this 、 super 、 arguments ，也没有 new.target 绑定。this 、 super 、arguments 、以及函数内部的 new.target 的值由所在的、最靠近的非箭头函数来决定。</p><p>不能被使用 new 调用： 箭头函数没有 [[Construct]] 方法，因此不能被用为构造函数，使用 new 调用箭头函数会抛出错误。</p><p>没有原型： 既然不能对箭头函数使用 new ，那么它也不需要原型，也就是没有prototype 属性。</p><p>不能更改 this ： this 的值在函数内部不能被修改，在函数的整个生命周期内其值会保持不变。</p><p>没有 arguments 对象： 既然箭头函数没有 arguments 绑定，你必须依赖于具名参数或剩余参数来访问函数的参数。</p><p>不允许重复的具名参数： 箭头函数不允许拥有重复的具名参数，无论是否在严格模式下；而相对来说，传统函数只有在严格模式下才禁止这种重复。</p><p>箭头函数也拥有 name 属性，并且遵循与其他函数相同的规则</p><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>这是一项引擎优化，改变了尾部调用的系统。</p><p>尾调用（tail call ）指的是调用函数的语句是另一个函数的最后语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">doSomethingElse</span>(); <span class="hljs-comment">// 尾调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 ES5 引擎中实现的尾调用，其处理就像其他函数调用一样：<strong>一个新的栈帧</strong>（ stack frame）被创建并推到调用栈之上，用于表示该次函数调用。这意味着<strong>之前每个栈帧都被保留在内存中，当调用栈太大时会出问题。</strong></p><p>ES6 在严格模式下力图为特定尾调用减少调用栈的大小（非严格模式的尾调用则保持不变）。<strong>当满足以下条件时，尾调用优化会清除当前栈帧并再次利用它，而不是为尾调用创建新的栈帧</strong>：</p><ol><li>尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）；</li><li>进行尾调用的函数在尾调用返回结果后不能做额外操作；</li><li>尾调用的结果作为当前函数的返回值。</li></ol><p><strong>尾调用优化主要是用在递归中</strong></p><p>不考虑尾调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 未被优化：在返回之后还要执行乘法</span><br>    <span class="hljs-keyword">return</span> n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑尾调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 未被优化：在返回之后还要执行乘法</span><br>        <span class="hljs-keyword">return</span> n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在重写的 factorial() 函数中，添加了第二个参数 p ，其默认值为 1 。 p 参数保存着前一次乘法的结果，因此下一次的结果就能在进行函数调用之前被算出。</p><p><strong>尾调用优化是你在书写任意递归函数时都需要考虑的因素</strong>，因为它能提供显著的性能提升，尤其是被应用到计算复杂度很高的函数时。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220722162911548.png" class="" title="image-20220722162911548"><h2 id="需计算属性名"><a href="#需计算属性名" class="headerlink" title="需计算属性名"></a>需计算属性名</h2><p>方括号允许你将变量或字符串字面量指定为属性名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 变量</span><br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&quot;last name&quot;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-string">&quot;first name&quot;</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    [lastName]: <span class="hljs-string">&quot;Zakas&quot;</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;first name&quot;</span>]); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[lastName]); <span class="hljs-comment">// &quot;Zakas&quot;</span><br><br><span class="hljs-comment">// 字符串字面量</span><br><span class="hljs-keyword">var</span> suffix = <span class="hljs-string">&quot; name&quot;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    [<span class="hljs-string">&quot;first&quot;</span> + suffix]: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    [<span class="hljs-string">&quot;last&quot;</span> + suffix]: <span class="hljs-string">&quot;Zakas&quot;</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;first name&quot;</span>]); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;last name&quot;</span>]); <span class="hljs-comment">// &quot;Zakas&quot;</span><br></code></pre></td></tr></table></figure><h2 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h2><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>Object.is() 用来判断两个值是否相等，修复了 &#x3D;&#x3D;&#x3D; 的一些问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-number">0</span> == -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(+<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>用于混入对象</p><p>Object.assign() 方法接受任意数量的供应者，而接收者会按照供应者在参数中的顺序来依次接收它们的属性。这意味着在接收者中，第二个供应者的属性可能会覆盖第一个供应者的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> receiver = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(receiver,<br>    &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;js&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;file.js&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;css&quot;</span><br>    &#125;<br>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver.<span class="hljs-property">type</span>); <span class="hljs-comment">// &quot;css&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;file.js&quot;</span><br></code></pre></td></tr></table></figure><p><strong>由于 Object.assign() 使用赋值运算符，供应者的访问器属性就会转变成接收者的数据属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> receiver = &#123;&#125;,<br>supplier = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;file.js&quot;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(receiver, supplier);<br><br><span class="hljs-keyword">var</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(receiver, <span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">value</span>); <span class="hljs-comment">// &quot;file.js&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">get</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h2 id="自有属性的枚举顺序"><a href="#自有属性的枚举顺序" class="headerlink" title="自有属性的枚举顺序"></a>自有属性的枚举顺序</h2><p>ES6 则严格定义了对象自有属性在被枚举时返回的顺序。</p><p>对 Object.getOwnPropertyNames() 与 Reflect.ownKeys 如何返回属性造成了影响，还同样影响了 Object.assign() 处理属性的顺序。</p><p><strong>自有属性枚举时基本顺序如下：</strong></p><ol><li>所有的数字类型键，按升序排列。</li><li>所有的字符串类型键，按被添加到对象的顺序排列。</li><li>所有的符号类型（详见第六章）键，也按添加顺序排列。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span><br>&#125;;<br><br>obj.<span class="hljs-property">d</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// &quot;012acbd&quot;</span><br></code></pre></td></tr></table></figure><p>数值类型的键会被合并并排序；字符串类型的键会跟在数值类型的键之后</p><p>for-in 循环的枚举顺序仍未被明确规定，因为并非所有的 JS 引擎都采用相同的方式。而 Object.keys() 和 JSON.stringify() 也使用了与 for-in 一样的枚举顺序。</p><h2 id="更强大的原型"><a href="#更强大的原型" class="headerlink" title="更强大的原型"></a>更强大的原型</h2><h3 id="修改对象的原型"><a href="#修改对象的原型" class="headerlink" title="修改对象的原型"></a><strong>修改对象的原型</strong></h3><p>直到 ES5 为止， JS 编程最重要的假定之一就是对象的原型在初始化完成后会保持不变。</p><p>ES6 通过添加 <strong>Object.setPrototypeOf()</strong> 方法而改变了这种假定，此方法允许你修改任意指定对象的原型。</p><p>它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h3><p>super 使得在对象原型上的功能调用变得更容易</p><p>super 是指向当前对象的原型的一个指针，实际上就是 Object.getPrototypeOf(this) 的值</p><h2 id="正式的“方法”定义"><a href="#正式的“方法”定义" class="headerlink" title="正式的“方法”定义"></a>正式的“方法”定义</h2><p>在 ES6 之前，“方法”的概念从未被正式定义，它此前仅指对象的函数属性（而非数据属性）。</p><p>ES6 则正式做出了定义：<strong>方法是一个拥有 [[HomeObject]] 内部属性的函数</strong>，此内部属性指向该方法所属的对象。</p><p>任何对 super 的引用都会使用 [[HomeObject]] 属性来判断要做什么。第一步是在 [[HomeObject]] 上调用 Object.getPrototypeOf() 来获取对原型的引用；接下来，在该原型上查找同名函数；最后，创建 this 绑定并调用该方法。</p><h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220722201416156.png" class="" title="image-20220722201416156"><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p><strong>当使用解构来配合 var 、 let 或 const 来声明变量时，必须提供初始化器</strong>（即等号右边的值）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 语法错误！</span><br><span class="hljs-keyword">var</span> &#123; type, name &#125;;<br><br><span class="hljs-comment">// 语法错误！</span><br><span class="hljs-keyword">let</span> &#123; type, name &#125;;<br><br><span class="hljs-comment">// 语法错误！</span><br><span class="hljs-keyword">const</span> &#123; type, name &#125;;<br></code></pre></td></tr></table></figure><p><strong>解构赋值表达式的值为表达式右侧（在 &#x3D; 之后）的值。</strong></p><p>也就是说在任何期望有个值的位置都可以使用解构赋值表达式。例如，传递值给函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> node = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Identifier&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span><br>&#125;,<br>type = <span class="hljs-string">&quot;Literal&quot;</span>,<br>name = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outputInfo</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value === node); <span class="hljs-comment">// true</span><br>&#125;<br><br><span class="hljs-title function_">outputInfo</span>(&#123; type, name &#125; = node);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(type); <span class="hljs-comment">// &quot;Identifier&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// &quot;foo&quot;</span><br></code></pre></td></tr></table></figure><p><strong>可以给默认值，也可以给不同的变量名</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> node = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Identifier&quot;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">type</span>: localType, <span class="hljs-attr">name</span>: localName = <span class="hljs-string">&quot;bar&quot;</span>&#125; = node<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localType); <span class="hljs-comment">// &quot;Identifier&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localName); <span class="hljs-comment">// &quot;bar&quot;</span><br></code></pre></td></tr></table></figure><p><strong>嵌套解构</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> node = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Identifier&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,<br>        <span class="hljs-attr">loc</span>: &#123;<br>        <span class="hljs-attr">start</span>: &#123;<br>            <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">column</span>: <span class="hljs-number">1</span><br>        &#125;,<br>        <span class="hljs-attr">end</span>: &#123;<br>            <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">column</span>: <span class="hljs-number">4</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 提取 node.loc.start</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">loc</span>: &#123; <span class="hljs-attr">start</span>: localStart &#125;&#125; = node;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localStart.<span class="hljs-property">line</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localStart.<span class="hljs-property">column</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>与对象差别不大，也有默认值、嵌套解构等</p><p><strong>可以用来交换两个值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[a,b] = [b,a]<br></code></pre></td></tr></table></figure><p><strong>剩余项</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [ <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span> ];<br><span class="hljs-keyword">let</span> [ firstColor, ...restColors ] = colors;<span class="hljs-comment">// restColors 是一个数组</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstColor); <span class="hljs-comment">// &quot;red&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restColors.<span class="hljs-property">length</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restColors[<span class="hljs-number">0</span>]); <span class="hljs-comment">// &quot;green&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restColors[<span class="hljs-number">1</span>]); <span class="hljs-comment">// &quot;blue&quot;</span><br></code></pre></td></tr></table></figure><p><strong>克隆数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在 ES6 中克隆数组</span><br><span class="hljs-keyword">let</span> colors = [ <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span> ];<br><span class="hljs-keyword">let</span> [ ...clonedColors ] = colors;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clonedColors); <span class="hljs-comment">//&quot;[red,green,blue]&quot;</span><br></code></pre></td></tr></table></figure><h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setCookie</span>(<span class="hljs-params">name, value,</span><br><span class="hljs-params">    &#123;</span><br><span class="hljs-params">        secure = <span class="hljs-literal">false</span>,</span><br><span class="hljs-params">        path = <span class="hljs-string">&quot;/&quot;</span>,</span><br><span class="hljs-params">        domain = <span class="hljs-string">&quot;example.com&quot;</span>,</span><br><span class="hljs-params">        expires = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.now() + <span class="hljs-number">360000000</span>)</span><br><span class="hljs-params">    &#125; = &#123;&#125;</span><br><span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>此代码中参数解构给每个属性都提供了默认值</strong>，所以你可以避免检查指定属性是否已被传入（以便在未传入时使用正确的值）。<strong>而整个解构的参数同样有一个默认值，即一个空对象</strong>，令该参数成为可选参数。</p><h1 id="Set-与-Map"><a href="#Set-与-Map" class="headerlink" title="Set 与 Map"></a>Set 与 Map</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220724205823067.png" class="" title="image-20220724205823067"><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="判断值是否重复"><a href="#判断值是否重复" class="headerlink" title="判断值是否重复"></a>判断值是否重复</h3><p>Set 和 Map 不会使用强制类型转换来判断值是否重复，而是使用 Object.is() 方法（唯一例外时 +0 与 -0 被判断为相等)</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a><strong>forEach()</strong></h3><p>forEach() 方法会被传递一个回调函数，该回调接受三个参数：</p><ol><li>Set 中下个位置的值；</li><li>Set 中下个位置的键；</li><li>目标 Set 自身。</li></ol><p>因为 Set 中 每一项同时认定为键与值，因此 1 和 2 是相同的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, ownerSet</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot; &quot;</span> + value);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ownerSet === set);<br>&#125;);<br><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-literal">true</span><br><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>如果想在回调函数中使用 this ，你可以给 forEach() 传入一个 this 值作为第二个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-keyword">let</span> processor = &#123;<br>    <span class="hljs-title function_">output</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;,<br>    <span class="hljs-title function_">process</span>(<span class="hljs-params">dataSet</span>) &#123;<br>        dataSet.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">output</span>(value);<br>        &#125;, <span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;;<br>processor.<span class="hljs-title function_">process</span>(set);<br></code></pre></td></tr></table></figure><h2 id="Weak-Set"><a href="#Weak-Set" class="headerlink" title="Weak Set"></a>Weak Set</h2><p>只允许存储对象弱引用，不能存储基本类型。add(基本类型)会报错，has()或delete()会返回 false</p><p>Weak Set 不可迭代，不能用于 for-of 循环，没有 keys() 与 values() 方法，没有 forEach()，没有 size 属性</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map-的初始化"><a href="#Map-的初始化" class="headerlink" title="Map 的初始化"></a>Map 的初始化</h3><p><strong>你能将数组传递给 Map 构造器，以便使用数据来初始化一个 Map</strong> 。该<strong>数组中的每一项也必须是数组</strong>，内部数组的首个项会作为键，第二项则为对应值。因此整个Map 就被这些双项数组所填充。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>], [<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">25</span>]]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;age&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;age&quot;</span>)); <span class="hljs-comment">// 25</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h2 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h2><p>所有键都必须是对象，都是弱引用，不会干扰垃圾回收。</p><p>没有 size 属性，没有 clear() 方法</p><p><strong>实际应用：在对象实例中存储私有数据</strong></p><p>在 ES6 中对象的所有属性都是公开的，因此若想让数据对于对象自身可访问、而在其他条件下不可访问，那么你就需要使用一些创造力。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 一般用 _属性 表示私有属性, 但并不能做到真正私有</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = name;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>        privateData.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, &#123; <span class="hljs-attr">name</span>: name &#125;);<br>    &#125;<br>    <br>    <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">name</span>;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Person</span>;<br>&#125;());<br></code></pre></td></tr></table></figure><p>当 Person 构造器被调用时，将 this 作为键在 Weak Map 上建立了一个入口，而包含私有信息的对象成为了对应的值，其中只存放了 name 属性。通过将 this 传递给 privateData.get() 方法，以获取值对象并访问其 name 属性， getName() 函数便能提取私有信息。这种技术让私有信息能够保持私有状态，并且当与之关联的对象实例被销毁时，私有信息也会被同时销毁。</p><h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><p><strong>意义：</strong></p><p>for 循环需要初始化变量以便追踪集合内的位置，而迭代器则以编程方式返回集合中的下一个项。</p><p><strong>作用：</strong></p><p>新增的 for-of 与它协同工作，扩展运算符（ … ）也使用了它，而它甚至还能让异步操作更易完成。</p><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726144254499.png" class="" title="image-20220726144254499"><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="何为迭代器"><a href="#何为迭代器" class="headerlink" title="何为迭代器"></a>何为迭代器</h3><p>迭代器是被设计专用于迭代的对象，带有特定接口。所有的迭代器对象都拥有 next() 方法，会返回一个结果对象。该结果对象有两个属性：对应下一个值的 value ，以及一个布尔类型的 done ，其值为 true 时表示没有更多值可供使用。迭代器持有一个指向集合位置的内部指针，每当调用了 next() 方法，迭代器就会返回相应的下一个值。</p><p>若你在最后一个值返回后再调用 next() ，所返回的 done 属性值会是 true ，并且 value 属性值会是迭代器自身的返回值（ return value ，即使用 return 语句明确返回的值）。该“返回值”不是原数据集的一部分，却会成为相关数据的最后一个片段，或在迭代器未提供返回值的时候使用 undefined 。迭代器自身的返回值类似于函数的返回值，是向调用者返回信息的最后手段。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><h3 id="何为生成器"><a href="#何为生成器" class="headerlink" title="何为生成器"></a>何为生成器</h3><p>生成器（ generator ）是能返回一个迭代器的函数。生成器函数由放在 function 关键字之后的一个星号（ * ）来表示，并能使用新的 yield 关键字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 生成器</span><br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">// 生成器能像正规函数那样被调用，但会返回一个迭代器</span><br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>yield 关键字也是 ES6 新增的，指定了迭代器在被 next() 方法调用时应当按顺序返回的值，传递给 next() 的参数会成为 yield 语句的值。</p><p><strong>生成器函数最有意思的方面可能就是它们会在每个 yield 语句后停止执行，在函数中停止执行的能力是极其强大的。</strong></p><p>yield 关键字只能用在生成器内部，用于其他位置都时语法错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params">items</span>) &#123;<br>    items.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>        <span class="hljs-comment">// 语法错误</span><br>        <span class="hljs-keyword">yield</span> item + <span class="hljs-number">1</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 星号放置在 function 关键字与圆括号之间，是因为这个函数表达式是匿名的</span><br><span class="hljs-keyword">let</span> createIterator = <span class="hljs-keyword">function</span> *(items) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">yield</span> items[i];<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>不能将箭头函数创建为生成器</p><h3 id="生成器对象方法"><a href="#生成器对象方法" class="headerlink" title="生成器对象方法"></a>生成器对象方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6 方法的速记法，只要在方法名之前加上一个星号*</span><br><span class="hljs-keyword">var</span> o = &#123;<br>    *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params">items</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">yield</span> items[i];<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> iterator = o.<span class="hljs-title function_">createIterator</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><h2 id="可迭代对象与-for-of-循环"><a href="#可迭代对象与-for-of-循环" class="headerlink" title="可迭代对象与 for-of 循环"></a>可迭代对象与 for-of 循环</h2><p>可迭代对象时包含 Symbol.iterator 属性的对象。</p><p>ES6 中，所有的集合对象（数组、Set与Map）以及字符串都是可迭代对象。</p><p>生成器创建的所有迭代器都是可迭代对象，因为生成器默认就会为 Symbol.iterator 属性赋值。</p><p>可迭代对象被设计用于与 ES 新增的 for-of 循环配合使用。</p><p><strong>for-of 循环会调用当前对象的 Symbol.Iterator 方法（发生在后台），获取一个迭代器 iterator，然后在调用 iterator 的 next</strong></p><p>在不可迭代对象、 null 或 undefined 上使用 for-of 语句，会抛出错误。</p><h3 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h3><p>可以使用 Symbol.iterator 来访问对象上的默认迭代器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> iterator = values[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<br></code></pre></td></tr></table></figure><p>既然 Symbol.iterator 指定了默认迭代器，你就可以使用它来检测一个对象是否能进行迭代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isIterable</span>(<span class="hljs-params">object</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> object[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] === <span class="hljs-string">&quot;function&quot;</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-string">&quot;Hello&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>())); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>())); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>())); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>())); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>for-of 循环在执行之前会做类似的检查，因此在遇到不可迭代对象是才会抛出错误</p><p>Weak Set 与 Weak Map 并未拥有内置的迭代器，使用弱引用意味着无法获知这些集合内部到底有多少个值，同时意味着没有方法可以迭代这些值。</p><h3 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h3><p>开发者自定义对象默认情况下不是可迭代对象，但你可以创建一个包含生成器的 Symbol.iterator 属性，让它们成为可迭代对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> collection = &#123;<br>    <span class="hljs-attr">items</span>: [],<br>    *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>) &#123;<br>            <span class="hljs-keyword">yield</span> item;<br>        &#125;<br>    &#125;<br>&#125;;<br><br>collection.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);<br>collection.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);<br>collection.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> collection) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>当使用 let-of 迭代 collection 时，会调用内部的 Symbol.iterator，从而迭代 this.items。</p><p><strong>只有当内置的迭代器无法满足你的需要时，才有必要创建自定义迭代器，这最常发生在定义你自己的对象或类时</strong></p><h2 id="内置的迭代器"><a href="#内置的迭代器" class="headerlink" title="内置的迭代器"></a>内置的迭代器</h2><h3 id="集合的迭代器"><a href="#集合的迭代器" class="headerlink" title="集合的迭代器"></a>集合的迭代器</h3><p>ES6 的三种集合对象：数组、Map、Set，都拥有如下迭代器</p><p>entries() ：返回一个包含键值对的迭代器；<br>values() ：返回一个包含集合中的值的迭代器；<br>keys() ：返回一个包含集合中的键的迭代器。</p><p><strong>集合的默认迭代器</strong></p><p>当 for-of 循环没有显式指定迭代器时，每种集合类型都有一个默认的迭代器供循环使用。</p><p><strong>values() 方法是数组与 Set 的默认迭代器，而 entries() 方法则是 Map 的默认迭代器。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [ <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span> ];<br><span class="hljs-keyword">let</span> tracking = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1234</span>, <span class="hljs-number">5678</span>, <span class="hljs-number">9012</span>]);<br><span class="hljs-keyword">let</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br>data.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;Understanding ES6&quot;</span>);<br>data.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;format&quot;</span>, <span class="hljs-string">&quot;print&quot;</span>);<br><br><span class="hljs-comment">// 与使用 colors.values() 相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> colors) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><br><span class="hljs-comment">// 与使用 tracking.values() 相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> tracking) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>&#125;<br><br><span class="hljs-comment">// 与使用 data.entries() 相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> data) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串的迭代器"><a href="#字符串的迭代器" class="headerlink" title="字符串的迭代器"></a>字符串的迭代器</h3><p><strong>方括号表示法工作在码元而非字符上</strong>，因此它不能被用于正确访问双字节的字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;A B&quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i &lt; message.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message[i]);<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">A</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">B</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>ES6 旨在为 Unicode 提供完全支持，字符串的默认迭代器就是解决字符串迭代问题的一种尝试。这样一来，<strong>借助字符串默认迭代器就能处理字符而不是码元。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;A B&quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> message) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">A</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">B</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="NodeList-的迭代器"><a href="#NodeList-的迭代器" class="headerlink" title="NodeList 的迭代器"></a>NodeList 的迭代器</h3><p>随着默认迭代器被附加到 ES6 ， DOM 关于 NodeList 的规定也包含了一个默认迭代器（此规定在 HTML 规范而非 ES6 规范中），其表现方式与数组的默认迭代器一致。</p><h2 id="扩展运算符与非数组的可迭代对象"><a href="#扩展运算符与非数组的可迭代对象" class="headerlink" title="扩展运算符与非数组的可迭代对象"></a>扩展运算符与非数组的可迭代对象</h2><p>扩展运算符能作用于所有可迭代对象，并且会使用默认迭代器来判断需要使用哪些值。所有的值都从迭代器中被读取出来并插入数组，遵循迭代器返回值的顺序。</p><p>扩展运算符是将可迭代对象转换为数组的最简单方法。你可以将字符串转换为包含字符（而非码元）的数组，也能将浏览器中的 NodeList 对象转换为节点数组。</p><h2 id="迭代器高级功能"><a href="#迭代器高级功能" class="headerlink" title="迭代器高级功能"></a>迭代器高级功能</h2><h3 id="传递参数给迭代器"><a href="#传递参数给迭代器" class="headerlink" title="传递参数给迭代器"></a>传递参数给迭代器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 关键在于：传递给 next() 的参数会成为 yield 语句的值</span><br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> first = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> second = <span class="hljs-keyword">yield</span> first + <span class="hljs-number">2</span>; <span class="hljs-comment">// 4 + 2</span><br>    <span class="hljs-keyword">yield</span> second + <span class="hljs-number">3</span>; <span class="hljs-comment">// 5 + 3</span><br>&#125;<br><br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;&#123; value: 6, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// &quot;&#123; value: 8, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726152259722.png" class="" title="image-20220726152259722"><h3 id="在迭代器中抛出错误"><a href="#在迭代器中抛出错误" class="headerlink" title="在迭代器中抛出错误"></a>在迭代器中抛出错误</h3><p>能传递给迭代器的不仅是数据，还可以是错误条件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> first = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> second = <span class="hljs-keyword">yield</span> first + <span class="hljs-number">2</span>; <span class="hljs-comment">// yield 4 + 2 ，然后抛出错误</span><br>    <span class="hljs-keyword">yield</span> second + <span class="hljs-number">3</span>; <span class="hljs-comment">// 永不会被执行</span><br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;&#123; value: 6, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Boom&quot;</span>))); <span class="hljs-comment">// 从生成器中抛出了错误</span><br></code></pre></td></tr></table></figure><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726152623070.png" class="" title="image-20220726152623070"><p><strong>可以在内部使用 try…catch 捕获错误</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> first = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> second;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        second = <span class="hljs-keyword">yield</span> first + <span class="hljs-number">2</span>; <span class="hljs-comment">// yield 4 + 2 ，然后抛出错误</span><br>    &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>        second = <span class="hljs-number">6</span>; <span class="hljs-comment">// 当出错时，给变量另外赋值</span><br>    &#125;<br>    <span class="hljs-keyword">yield</span> second + <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;&#123; value: 6, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Boom&quot;</span>))); <span class="hljs-comment">// &quot;&#123; value: 9, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure><p>将 next() 与 throw() 都当作迭代器的指令，会有助于思考。</p><p>next() 方法指示迭代器继续执行（可能会带着给定的值），而 throw() 方法则指示迭代器通过抛出一个错误继续执行。<strong>在调用点之后会发生什么，根据生成器内部的代码来决定。</strong></p><h3 id="生成器的-return-语句"><a href="#生成器的-return-语句" class="headerlink" title="生成器的 return 语句"></a>生成器的 return 语句</h3><p><strong>return 会终止后续的程序</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>return 可以指定返回值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 42, done: true &#125;&quot; 非常特殊，value 不为 undefined，done 为 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>扩展运算符与 for-of 循环会忽略 return 语句所指定的任意值。</strong>一旦它们看到 done的值为 true ，它们就会停止操作而不会读取对应的 value 值。不过，在生成器进行委托时，迭代器的返回值会非常有用。</p><h3 id="生成器委托"><a href="#生成器委托" class="headerlink" title="生成器委托"></a>生成器委托</h3><p>一些情况下，将两个迭代器的值合并在一起会更有用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createNumberIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createColorIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;red&quot;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;green&quot;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createCombinedIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> *<span class="hljs-title function_">createNumberIterator</span>();<br>    <span class="hljs-keyword">yield</span> *<span class="hljs-title function_">createColorIterator</span>();<br>    <span class="hljs-keyword">yield</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">var</span> iterator = <span class="hljs-title function_">createCombinedIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 2, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: &quot;red&quot;, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: &quot;green&quot;, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: true, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="异步任务运行"><a href="#异步任务运行" class="headerlink" title="异步任务运行"></a>异步任务运行</h2><p><strong>由于生成器能让你在执行过程中有效地暂停代码操作，它就开启了与异步编程相关的许多可能性。</strong></p><p>由于 yield 能停止运行，并在重新开始运行前等待 next() 方法被调用，你就可以在没有回调函数的情况下实现异步调用。</p><p><strong>传统异步操作</strong></p><p>调用一个包含回调的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;config.json&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, contents</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">throw</span> err;<br>    &#125;<br>        <br>    <span class="hljs-title function_">doSomethingWith</span>(contents);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Done&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>使用 yield</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">taskDef</span>) &#123;<br>    <span class="hljs-comment">// 创建迭代器，让它在别处可用</span><br>    <span class="hljs-keyword">let</span> task = <span class="hljs-title function_">taskDef</span>();<br>    <span class="hljs-comment">// 启动任务</span><br>    <span class="hljs-keyword">let</span> result = task.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-comment">// 递归使用函数来保持对 next() 的调用</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">step</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 如果还有更多要做的</span><br>        <span class="hljs-keyword">if</span> (!result.<span class="hljs-property">done</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result.<span class="hljs-property">value</span> === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>                result.<span class="hljs-title function_">value</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (err) &#123;<br>                        result = task.<span class="hljs-keyword">throw</span>(err);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><br>                    result = task.<span class="hljs-title function_">next</span>(data);<br>                    <span class="hljs-title function_">step</span>();<br>                &#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result = task.<span class="hljs-title function_">next</span>(result.<span class="hljs-property">value</span>);<br>                <span class="hljs-title function_">step</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 开始处理过程</span><br>    <span class="hljs-title function_">step</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">run</span>(<span class="hljs-keyword">function</span>*() &#123;<br>    <span class="hljs-keyword">let</span> contents = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;config.json&quot;</span>);<br>    <span class="hljs-title function_">doSomethingWith</span>(contents);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Done&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>此例执行了异步的 readFile() 操作，而在<strong>主要代码中并未暴露出任何回调函数</strong>。除了 yield 之外，<strong>此代码看起来与同步代码并无二致</strong>。既然执行异步操作的函数都遵循了同一接口，你就可以用貌似同步的代码来书写处理逻辑。</p><p>看上去好像更复杂了，但这是因为当前回调任务少，<strong>如果需要嵌套回调函数，或者需要按顺序处理一系列的异步任务时，使用生成器和迭代器会方便很多</strong>。</p><h1 id="JS-的类"><a href="#JS-的类" class="headerlink" title="JS 的类"></a>JS 的类</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726161901329.png" class="" title="image-20220726161901329"><h2 id="ES5-中的仿类结构"><a href="#ES5-中的仿类结构" class="headerlink" title="ES5 中的仿类结构"></a>ES5 中的仿类结构</h2><p><strong>自定义类型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PersonType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">PersonType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>person.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PersonType</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonClass</span> &#123;<br>    <span class="hljs-comment">// 等价于 PersonType 构造器</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-comment">// 自有属性</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-comment">// 等价于 PersonType.prototype.sayName</span><br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonClass</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>person.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// &quot;function&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span>); <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure><p><strong>自有属性：该属性出现在实例上而不是原型上，只能在类的构造器或方法内部进行创建。</strong></p><p><strong>类与自定义类型的区别</strong></p><ol><li><strong>类声明不会被提升，这与函数定义不同</strong>。类声明的行为与 let 相似，因此在程序的执行到达声明处之前，类会存在于暂时性死区内。</li><li><strong>类声明中的所有代码会自动运行在严格模式下</strong>，并且也无法退出严格模式。</li><li><strong>类的所有方法都是不可枚举的</strong>，这是对于自定义类型的显著变化，后者必须用Object.defineProperty() 才能将方法改变为不可枚举。</li><li><strong>类的所有方法内部都没有 [[Construct]]</strong> ，因此使用 new 来调用它们会抛出错误。</li><li><strong>调用类构造器时不使用 new</strong> ，会抛出错误。</li><li><strong>试图在类的方法内部重写类名</strong>，会抛出错误。</li></ol><p><strong>如果我们不使用类来定义上面的 PersonClass</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 直接等价于 PersonClass</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">PersonType2</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">PersonType2</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>        <br>        <span class="hljs-comment">// 确认函数被调用时使用了 new</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Constructor must be called with new.&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">PersonType2</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;sayName&quot;</span>, &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <br>            <span class="hljs-comment">// 确认函数被调用时没有使用 new</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Method cannot be called with new.&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>        &#125;,<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">PersonType2</span>;<br>&#125;());<br></code></pre></td></tr></table></figure><h2 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h2><p>类与函数有相似之处，即它们都有两种形式：声明与表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title class_">PersonClass</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonClass2</span> &#123;<span class="hljs-comment">// PersonClass2 可省略，匿名和具名</span><br>    <span class="hljs-comment">// 等价于 PersonType 构造器</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 等价于 PersonType.prototype.sayName</span><br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonClass</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>person.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// &quot;function&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span>); <span class="hljs-comment">// &quot;function&quot;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass2</span>); <span class="hljs-comment">// &quot;undefined&quot;外部是访问不到 PersonClass2 的</span><br></code></pre></td></tr></table></figure><h2 id="作为一级公民的类"><a href="#作为一级公民的类" class="headerlink" title="作为一级公民的类"></a>作为一级公民的类</h2><p>能被当作值来使用的就称为一级公民</p><p>JS的函数就是一级公民，类也延续了下来。</p><p>类能作为参数传入函数；也有立即调用类构造器的用法。</p><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js设计与实现</title>
    <link href="/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="框架设计概览"><a href="#框架设计概览" class="headerlink" title="框架设计概览"></a>框架设计概览</h2><h3 id="权衡的艺术"><a href="#权衡的艺术" class="headerlink" title="权衡的艺术"></a>权衡的艺术</h3><h4 id="命令式和声明式"><a href="#命令式和声明式" class="headerlink" title="命令式和声明式"></a>命令式和声明式</h4><p>命令式 关注过程</p><p>声明式 关注结果</p><p>Vue.js 帮我们封装了过程，内部实现是命令式的，而暴露给用户的却更加声明式</p><h4 id="性能与可维护性的权衡"><a href="#性能与可维护性的权衡" class="headerlink" title="性能与可维护性的权衡"></a>性能与可维护性的权衡</h4><p>声明式代码的性能不优于命令式代码的性能</p><p>命令式代码的更新性能消耗 &#x3D; 直接修改的性能消耗</p><p>声明式代码的更新性能消耗 &#x3D; 直接修改的性能消耗 + <strong>找出差异的性能消耗</strong></p><p>但声明式代码的可维护性更强</p><p>设计框架时 要保证可维护性的同时让性能损失最小化</p><h4 id="虚拟-DOM-的性能到底如何"><a href="#虚拟-DOM-的性能到底如何" class="headerlink" title="虚拟 DOM 的性能到底如何"></a>虚拟 DOM 的性能到底如何</h4><p>虚拟 DOM 就是为了<strong>最小化找出差异</strong>这一步的性能消耗而出现的 (diff算法)</p><p><strong>创建页面差异不大</strong></p><img src="/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20220718191653483.png" class="" title="image-20220718191653483"><p><strong>更新页面性能差异大</strong></p><img src="/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20220718191710254.png" class="" title="image-20220718191710254"><p><strong>更新页面的性能效果总结</strong></p><img src="/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20220718171611741.png" class="" title="image-20220718171611741"><h4 id="运行时和编译时"><a href="#运行时和编译时" class="headerlink" title="运行时和编译时"></a>运行时和编译时</h4><p>纯运行时，没有编译的过程，没办法分析用户提供的内容</p><p>纯编译时，可以分析用户提供的内容，性能更好，但用户提供的内容必须编译后才能用，有损灵活性</p><p>Vue.js 是运行时 + 编译时的架构</p><h3 id="框架设计的核心要素"><a href="#框架设计的核心要素" class="headerlink" title="框架设计的核心要素"></a>框架设计的核心要素</h3><h4 id="提供用户的开发体验"><a href="#提供用户的开发体验" class="headerlink" title="提供用户的开发体验"></a>提供用户的开发体验</h4><p>更友好的警告</p><p>自定义输出形式</p><h4 id="控制框架代码的体积"><a href="#控制框架代码的体积" class="headerlink" title="控制框架代码的体积"></a>控制框架代码的体积</h4><p>利用 Tree-shaking 机制，配合构建工具预定义常量的能力，如预定义 __DEV__常量，从而实现仅在开发环境中打印警告信息，从而控制线上代码体积</p><h4 id="良好的-Tree-Shaking"><a href="#良好的-Tree-Shaking" class="headerlink" title="良好的 Tree-Shaking"></a>良好的 Tree-Shaking</h4><p>利用 &#x2F;*#__PURE__*&#x2F; 注释 来让 webpack 相信这段代码不会产生副作用，从而 tree-shaking 掉</p><p>副作用：当调用函数的时候会对外部产生影响</p><p>Vue.js 3 源码中，基本都是在一些顶级调用的函数中使用 &#x2F;*#__PURE__*&#x2F; 注释掉</p><h4 id="框架应该输出怎样的构建产物"><a href="#框架应该输出怎样的构建产物" class="headerlink" title="框架应该输出怎样的构建产物"></a>框架应该输出怎样的构建产物</h4><p>为了让用户能够通过 <script> 标签直接引用并使用，需要输出 IIFE 格式的资源</p><p>为了让用户能够通过 <script type="module"> 引用并使用，需要输出 ESM 格式的资源</p><p>ESM格式的资源有两种：</p><p>esm-browser.js 用于浏览器使用 __DEV__  true/false 来判断环境</p><p>esm-bundler.js 用于打包工具 使用 process.env.NODE_ENV !== ‘production’ 来判断</p><p>为了让用户能够通过在服务端通过</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">const</span> <span class="hljs-variable">Vue</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;vue&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>使用，需要输出 CommonJS 格式的资源（一般用于服务端渲染）</p><h4 id="特性开关"><a href="#特性开关" class="headerlink" title="特性开关"></a>特性开关</h4><p>Vue.js 提供了很多功能，如果不需要可以通过特性开关关闭，这样打包时代码就不会出现在最终资源中，文件体积减小</p><p>比如 Vue3.js 中我们仍可使用 options API，可以关闭，通过 __VUE_OPTIONS_API__ 控制。</p><p>实现特性开关的方法和 __DEV__ 是一样的，本质上是通过 rollup.js(webpack) 的预定义常量插件来实现</p><p>可以使用 webpack.DefinePlugin 插件来控制是否开启</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> webpack.DefinePlugin (&#123;<br>__VUE_OPTIONS_API__: <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-literal">true</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Vue3.js 中将错误处理程序封装为一个函数 callWithErrorHandling</p><p>还提供了 registerErrorHandler 函数，用户可以使用它注册错误处理程序</p><h4 id="良好的-TS-支持"><a href="#良好的-TS-支持" class="headerlink" title="良好的 TS 支持"></a>良好的 TS 支持</h4><p>使用 TS 编写框架 和 框架对 TS 类型 支持友好是完全不同的</p><h3 id="Vue3-js-的设计思路"><a href="#Vue3-js-的设计思路" class="headerlink" title="Vue3.js 的设计思路"></a>Vue3.js 的设计思路</h3><h4 id="声明式描述-UI"><a href="#声明式描述-UI" class="headerlink" title="声明式描述 UI"></a>声明式描述 UI</h4><p>描述 UI 的两种方式：模板和虚拟 DOM</p><p>组件中的 render 函数就是使用虚拟 DOM 来描述 UI</p><p>h 函数就是一个辅助创建虚拟 DOM 的工具函数</p><h4 id="初始渲染器"><a href="#初始渲染器" class="headerlink" title="初始渲染器"></a>初始渲染器</h4><p><strong>渲染器</strong>的作用就是把 <strong>虚拟 DOM 转为 真实 DOM</strong></p><p>代码部分看书上的 renderer 函数</p><h4 id="组件的本质"><a href="#组件的本质" class="headerlink" title="组件的本质"></a>组件的本质</h4><p>组件就是一组 DOM 元素的封装</p><h4 id="模板的工作原理"><a href="#模板的工作原理" class="headerlink" title="模板的工作原理"></a>模板的工作原理</h4><img src="/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20220718204108277.png" class="" title="image-20220718204108277"><h4 id="编译器分析动态内容"><a href="#编译器分析动态内容" class="headerlink" title="编译器分析动态内容"></a>编译器分析动态内容</h4><p>代码中有静态内容（如写死的字符串），有动态内容（如双向绑定的变量）</p><p>动态内容改变时，渲染器会自动寻找变更点，找起来比较麻烦。</p><p>如果编译器有能力分析动态内容，获取更多信息，就会方便很多。</p><p>编译器能够识别出哪些是静态属性，哪些是动态属性（代码显然不一样），在生成虚拟 DOM 的时候就会携带额外的 patchFlags 信息。(patchFlags 应该是 vue3 新增的)</p>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类型转换</title>
    <link href="/2022/07/15/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/07/15/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>JS 没有严格的数据类型，所以可以互相转换</p><ul><li>显示类型转换：<code>Number()</code>, <code>String()</code>, <code>Boolean()</code></li><li>隐式类型转换：四则运算，判断语句，<code>Native</code> 调用，<code>JSON</code> 方法</li></ul><h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><h3 id="1-Number"><a href="#1-Number" class="headerlink" title="1. Number()"></a><strong>1. Number()</strong></h3><h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><ul><li>数字：转换后还是原来的值</li><li>字符串：如果能被解析成数字，就得到数字，否则就是 <code>NaN</code>，空字符串为0</li><li>布尔值：<code>true</code> 转为1，false 转为0</li><li><code>undefined</code>: 转为 <code>NaN</code></li><li><code>null</code>：转为0 引用类型转换</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;1&quot;</span>)) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;1a&quot;</span>)) <span class="hljs-comment">// NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;)) <span class="hljs-comment">// NaN 原因往下看</span><br></code></pre></td></tr></table></figure><h4 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><p>先调用对象自身的 <code>valueOf</code> 方法，如果该方法返回原始类型的值(数值、字符串和布尔值)，则直接对该值使用 <code>Number</code> 方法，不再继续</p><p>如果 <code>valueOf</code> 方法返回复合类型的值，再调用对象自身的 <code>toString</code> 方法，如果 <code>toString</code> 方法返回原始类型的值，则对该值使用 <code>Number</code> 方法，不再继续</p><p>如果 <code>toString</code> 方法返回的还是复合类型的值，则报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(a)) <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 原理</span><br>a.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// &#123;a:1&#125;</span><br>a.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;[object Object]&quot;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h3 id="2-String"><a href="#2-String" class="headerlink" title="2. String()"></a><strong>2. String()</strong></h3><h4 id="简单数据类型-1"><a href="#简单数据类型-1" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><ul><li>数字：转换成相应字符串</li><li>字符串：转换后还是原来的值</li><li>布尔值：<code>true</code> 转为”true”，<code>false</code> 转为”false”</li><li><code>undefined</code>: 转为”undefined”</li><li><code>null</code>：转为”null” 引用类型转换</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// &quot;1&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>)) <span class="hljs-comment">// &quot;1&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// &quot;true&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// &quot;null&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(&#123;<span class="hljs-attr">b</span>:<span class="hljs-number">1</span>&#125;)) <span class="hljs-comment">// &quot;[object Object]&quot; 原因往下看</span><br></code></pre></td></tr></table></figure><h4 id="复杂数据类型-1"><a href="#复杂数据类型-1" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><p>先调用 <code>toString</code> 方法，如果 <code>toString</code> 方法返回的是原始类型的值，则对该值使用 <code>String</code> 方法，不再继续</p><p>如果 <code>toString</code> 方法返回的是复合类型的值，再调用 <code>valueOf</code> 方法，如果 <code>valueOf</code> 方法返回的是原始类型的值，则对该值使用 <code>String</code> 方法，不再继续</p><p>如果 <code>valueOf</code> 方法返回的是复合类型的值，则报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> b = &#123;<span class="hljs-attr">b</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(b)) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-comment">// 原理</span><br>b.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-comment">// b.valueOf() 由于返回的不是复合类型所以没有调valueOf()</span><br><span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;[object Object]&quot;</span>) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-Boolean"><a href="#3-Boolean" class="headerlink" title="3. Boolean()"></a><strong>3. Boolean()</strong></h3><h4 id="简单数据类型-2"><a href="#简单数据类型-2" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><ul><li>0</li><li>-0</li><li>“”</li><li>null</li><li>undefined</li><li>NaN</li></ul><p>以上统一转为false，其他一律为true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(-<span class="hljs-number">0</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&quot;&quot;</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-title class_">NaN</span>)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="复杂数据类型-2"><a href="#复杂数据类型-2" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><p>都转为 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(obj1))<span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(obj2))<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 四则运算  如把String隐式转换成Number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-string">&#x27;1&#x27;</span> === <span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 判断语句  如把String隐式转为Boolean</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// Native调用  如把Object隐式转为String</span><br><span class="hljs-title function_">alert</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]]) <span class="hljs-comment">// &quot;nb&quot;</span><br><br><span class="hljs-comment">// JSON方法 如把String隐式转为Object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&quot;&#123;a:1&#125;&quot;</span>)) <span class="hljs-comment">// &#123;a:1&#125;</span><br></code></pre></td></tr></table></figure><p>几道隐式转换题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-literal">true</span>+<span class="hljs-literal">true</span>  ) <span class="hljs-comment">// 2                   解：true相加是用四则运算隐式转换Number 就是1+1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(  <span class="hljs-number">1</span>+&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;   ) <span class="hljs-comment">// &quot;1[object Object]&quot;  解：上面说了Native调用&#123;a:1&#125;为&quot;[object Object]&quot;  数字1+字符串直接拼接</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(   []+[]    ) <span class="hljs-comment">// &quot;&quot;                  解：String([]) =》 [].toString() = &quot;&quot; =》 &quot;&quot;+&quot;&quot; =》 &quot;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(   []+&#123;&#125;    ) <span class="hljs-comment">// &quot;[object Object]&quot;   解：&quot;&quot; + String(&#123;&#125;) =》 &quot;&quot; + &#123;&#125;.toString() = &quot;&quot; + &quot;[object Object]&quot; =》 &quot;[object Object]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(   &#123;&#125;+&#123;&#125;    ) <span class="hljs-comment">// &quot;[object Object][object Object]&quot; 和上面同理</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文大部分内容来自于这篇文章<a href="https://juejin.cn/post/6995591618371780622">https://juejin.cn/post/6995591618371780622</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>定位</title>
    <link href="/2022/07/14/%E5%AE%9A%E4%BD%8D/"/>
    <url>/2022/07/14/%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>一种布局方式</p><p>定位 &#x3D; 定位模式 + 边偏移</p><h2 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h2><table><thead><tr><th>边偏移属性</th><th align="left">示例</th><th>描述</th></tr></thead><tbody><tr><td><code>top</code></td><td align="left"><code>top: 80px / 50%</code></td><td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td></tr><tr><td><code>bottom</code></td><td align="left"><code>bottom: 80px</code></td><td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td></tr><tr><td><code>left</code></td><td align="left"><code>left: 80px</code></td><td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td></tr><tr><td><code>right</code></td><td align="left"><code>right: 80px</code></td><td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td></tr></tbody></table><h2 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h2><table><thead><tr><th>值</th><th align="center">语义</th><th></th></tr></thead><tbody><tr><td>static</td><td align="center"><strong>静态</strong>定位</td><td>标准流 无定位</td></tr><tr><td>relative</td><td align="center"><strong>相对</strong>定位</td><td>标准流 相对自身定位 标准流区域的位置仍占有</td></tr><tr><td>absolute</td><td align="center"><strong>绝对</strong>定位</td><td>脱离标准流 相对最近的有定位且不为 static 的祖先元素定位，若没有则相对 body 定位</td></tr><tr><td>fixed</td><td align="center"><strong>固定</strong>定位</td><td>脱离标准流 相对于浏览器窗口定位</td></tr><tr><td>sticky</td><td align="center"><strong>粘性</strong>定位</td><td>根据窗口滚动自动切换 relative 和 fixed，由设置的边偏移决定</td></tr></tbody></table><h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p>在使用<strong>定位</strong>布局时，可能会<strong>出现盒子重叠的情况</strong>。</p><p>加了定位的盒子，默认<strong>后来者居上</strong>， 后面的盒子会压住前面的盒子。</p><p>使用 <code>z-index</code> 层叠等级属性可以<strong>调整盒子的堆叠顺序</strong>。</p><p><code>z-index</code> 的特性如下：</p><ol><li><strong>属性值</strong>：<strong>整数</strong>，默认值是 0，数值越大，盒子越靠上；</li><li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li><li><strong>数字后面不能加单位</strong>。</li></ol><p><strong>注意</strong>：<code>z-index</code> 只能应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>设定 position ＝ absolute 或 fixed 可以创建 BFC 解决高度塌陷, 外边距重叠，清除浮动问题</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>scoped和样式穿透</title>
    <link href="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/"/>
    <url>/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="scoped-和样式穿透"><a href="#scoped-和样式穿透" class="headerlink" title="scoped 和样式穿透"></a>scoped 和样式穿透</h1><h2 id="scoped"><a href="#scoped" class="headerlink" title="scoped"></a>scoped</h2><h3 id="不使用-scoped"><a href="#不使用-scoped" class="headerlink" title="不使用 scoped"></a>不使用 scoped</h3><p>顺便复习一下 vue3 中路由的使用</p><p><strong>配置路由并导出</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/router/router.ts</span><br><span class="hljs-comment">// 配置路由并导出</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">NoRed</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/nored.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Red</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/red.vue&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123; createRouter,createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><br><span class="hljs-keyword">const</span> routes = [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/red&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Red</span>&#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/no_red&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">NoRed</span>&#125;<br>]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<span class="hljs-comment">// vue3 的 history 模式对应 createWebHashHistory hash 模式</span><br>    routes<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><p><strong>引入并使用组件</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/main.ts</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">// 引入路由</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router/router&#x27;</span><br><br><span class="hljs-comment">// use 路由</span><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>写组件</strong></p><p>只在 red 中写样式并不加 scoped</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src/components/nored.vue --&gt;<br>&lt;template&gt;<br>    &lt;div&gt; <br>      &lt;h1&gt;我应该不是红色&lt;/h1&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br><br>&lt;/script&gt;<br><br>&lt;style&gt; <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src/components/red.vue --&gt;<br>&lt;template&gt;<br>    &lt;div&gt; <br>      &lt;h1&gt;我应该是红色&lt;/h1&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br><br>&lt;/script&gt;<br><br>&lt;style&gt; <br>  a &#123;<br>    color: red<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>显示组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src/App.vue --&gt;<br>&lt;script setup lang=&quot;ts&quot;&gt;<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;p&gt;<br>     &lt;router-link to=&quot;/red&quot;&gt;red&lt;/router-link&gt;<br>     &lt;router-link to=&quot;/no_red&quot; style=&quot;margin-left: 20px;&quot;&gt;nored&lt;/router-link&gt;<br>     &lt;router-view&gt;&lt;/router-view&gt;<br>   &lt;/p&gt;<br>&lt;/template&gt;<br><br>&lt;style&gt;<br><br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>效果是</strong></p><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713222944618.png" class="" title="image-20220713222944618"><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713223018761.png" class="" title="image-20220713223018761"><p>只在 red 组件中写了样式 结果 nored 也有了样式</p><h3 id="使用-scoped"><a href="#使用-scoped" class="headerlink" title="使用 scoped"></a>使用 scoped</h3><p>在 red 组件的 style 标签中加上 scoped</p><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713222944618.png" class="" title="image-20220713222944618"><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713222951713.png" class="" title="image-20220713222951713"><p><strong>原理上就是 vue 在该组件的标签中加了一串字符</strong></p><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713223437121.png" class="" title="image-20220713223437121"><p><strong>该组件中的样式中也会以属性选择器的方式拼接上</strong></p><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713223714421.png" class="" title="image-20220713223714421"><p><strong>实际的步骤</strong></p><p>给HTML的DOM节点加一个不重复data属性(形如：data-v-123)来表示他的唯一性</p><p>在每句css选择器的末尾（编译后的生成的css语句）加一个当前组件的data属性选择器（如[data-v-123]）来私有化样式</p><p>如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的data属性</p><h3 id="scoped-的副作用"><a href="#scoped-的副作用" class="headerlink" title="scoped 的副作用"></a>scoped 的副作用</h3><p>如果我们在使用第三方库时企图修改其样式且使用 scoped（尤其是一些 ui 库）</p><p>会发现标签上并没有加上字符串，而样式中却加上了，因此样式会失效。</p><h2 id="样式穿透"><a href="#样式穿透" class="headerlink" title="样式穿透"></a>样式穿透</h2><p>不使用样式穿透</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.lei</span> &#123;<br>    <span class="hljs-selector-tag">input</span> &#123;<br>        <span class="hljs-attribute">background</span>: red<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用样式穿透 <strong>:deep()</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.lei</span> &#123;<br>    :<span class="hljs-selector-tag">deep</span>(input) &#123;<br>        <span class="hljs-attribute">background</span>: red<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以修改第三方库的样式了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7083051766874374174">https://juejin.cn/post/7083051766874374174</a></p><p><a href="https://blog.csdn.net/qq1195566313/article/details/123319462">https://blog.csdn.net/qq1195566313/article/details/123319462</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则</title>
    <link href="/2022/07/11/%E6%AD%A3%E5%88%99/"/>
    <url>/2022/07/11/%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Regular Expression</p><p>正则表达式是用于<strong>匹配字符串中字符组合的模式</strong>（文本搜索&#x2F;替换）</p><p>正则表达式是<strong>对象</strong></p><p>这些模式被用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a> 方法，以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><code>matchAll</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a> 方法。</p><p>可以简化字符串操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 举个例子, 提取字符串中的数字</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abas3244sda5552&quot;</span><br><br><span class="hljs-comment">// 使用 api</span><br><span class="hljs-keyword">let</span> nums = [...str].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> !<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">parseInt</span>(a)))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nums.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>))<br><br><span class="hljs-comment">// 使用 正则表达式</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1.使用双斜杠 /pattern/attributes</span><br><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/ab+c/</span><br><br><span class="hljs-comment">// 2.使用构造函数 new RegExp(pattern, attributes)</span><br><span class="hljs-keyword">let</span> re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;ab+c&quot;</span>)<br></code></pre></td></tr></table></figure><p>参数 <em><strong>pattern</strong></em> 是一个<strong>字符串</strong>，指定了正则表达式的模式或其他正则表达式。</p><p>参数 <em>attributes</em> 是一个可选的字符串，包含属性 “g”、”i” 和 “m”。</p><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_i.asp">i</a></td><td align="left">执行对大小写不敏感的匹配。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_g.asp">g</a></td><td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td align="left">m</td><td align="left">执行多行匹配。</td></tr></tbody></table><h2 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h2><p>方括号用于查找某个范围内的字符：</p><table><thead><tr><th align="left">表达式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[<a href="https://www.w3school.com.cn/jsref/jsref_regexp_charset.asp">abc]</a></td><td align="left">查找方括号之间的任何字符。</td></tr><tr><td align="left">[<a href="https://www.w3school.com.cn/jsref/jsref_regexp_charset_not.asp">^abc]</a></td><td align="left">查找任何不在方括号之间的字符。</td></tr><tr><td align="left">[0-9]</td><td align="left">查找任何从 0 至 9 的数字。</td></tr><tr><td align="left">[a-z]</td><td align="left">查找任何从小写 a 到小写 z 的字符。</td></tr><tr><td align="left">[A-Z]</td><td align="left">查找任何从大写 A 到大写 Z 的字符。</td></tr><tr><td align="left">[A-z]</td><td align="left">查找任何从大写 A 到小写 z 的字符。</td></tr><tr><td align="left">[adgk]</td><td align="left">查找给定集合内的任何字符。</td></tr><tr><td align="left">[^adgk]</td><td align="left">查找给定集合外的任何字符。</td></tr><tr><td align="left">(red|blue|green)</td><td align="left">查找任何指定的选项。</td></tr></tbody></table><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>元字符（Metacharacter）是拥有特殊含义的字符：</p><table><thead><tr><th align="left">元字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_dot.asp">.</a></td><td align="left">查找单个字符，除了换行和行结束符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_wordchar.asp">\w</a></td><td align="left">查找单词字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_wordchar_non.asp">\W</a></td><td align="left">查找非单词字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_digit.asp">\d</a></td><td align="left">查找数字。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_digit_non.asp">\D</a></td><td align="left">查找非数字字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_whitespace.asp">\s</a></td><td align="left">查找空白字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_whitespace_non.asp">\S</a></td><td align="left">查找非空白字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_begin.asp">\b</a></td><td align="left">匹配单词边界。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_begin_not.asp">\B</a></td><td align="left">匹配非单词边界。</td></tr><tr><td align="left">\0</td><td align="left">查找 NUL 字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_newline.asp">\n</a></td><td align="left">查找换行符。</td></tr><tr><td align="left">\f</td><td align="left">查找换页符。</td></tr><tr><td align="left">\r</td><td align="left">查找回车符。</td></tr><tr><td align="left">\t</td><td align="left">查找制表符。</td></tr><tr><td align="left">\v</td><td align="left">查找垂直制表符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_octal.asp">\xxx</a></td><td align="left">查找以八进制数 xxx 规定的字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_hex.asp">\xdd</a></td><td align="left">查找以十六进制数 dd 规定的字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_unicode_hex.asp">\uxxxx</a></td><td align="left">查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><table><thead><tr><th align="left">量词</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_onemore.asp">n+</a></td><td align="left">匹配任何包含至少一个 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_zeromore.asp">n*</a></td><td align="left">匹配任何包含零个或多个 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_zeroone.asp">n?</a></td><td align="left">匹配任何包含零个或一个 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_nx.asp">n{X}</a></td><td align="left">匹配包含 X 个 n 的序列的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_nxy.asp">n{X,Y}</a></td><td align="left">匹配包含 X 至 Y 个 n 的序列的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_nxcomma.asp">n{X,}</a></td><td align="left">匹配包含至少 X 个 n 的序列的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_ndollar.asp">n$</a></td><td align="left">匹配任何结尾为 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_ncaret.asp">^n</a></td><td align="left">匹配任何开头为 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_nfollow.asp">?&#x3D;n</a></td><td align="left">匹配任何其后紧接指定字符串 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_nfollow_not.asp">?!n</a></td><td align="left">匹配任何其后没有紧接指定字符串 n 的字符串。</td></tr></tbody></table><h2 id="RegExp-对象属性"><a href="#RegExp-对象属性" class="headerlink" title="RegExp 对象属性"></a>RegExp 对象属性</h2><table><thead><tr><th align="left">属性</th><th align="left">描述</th><th align="left">FF</th><th align="left">IE</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_global.asp">global</a></td><td align="left">RegExp 对象是否具有标志 g。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_ignorecase.asp">ignoreCase</a></td><td align="left">RegExp 对象是否具有标志 i。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_lastindex_regexp.asp">lastIndex</a></td><td align="left">一个整数，标示开始下一次匹配的字符位置。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_multiline_regexp.asp">multiline</a></td><td align="left">RegExp 对象是否具有标志 m。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_source_regexp.asp">source</a></td><td align="left">正则表达式的源文本。</td><td align="left">1</td><td align="left">4</td></tr></tbody></table><h2 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">FF</th><th align="left">IE</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_compile.asp">compile</a></td><td align="left">编译正则表达式。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_exec_regexp.asp">exec</a></td><td align="left">检索字符串中指定的值。返回找到的值，并确定其位置。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_test_regexp.asp">test</a></td><td align="left">检索字符串中指定的值。返回 true 或 false。</td><td align="left">1</td><td align="left">4</td></tr></tbody></table><h2 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">FF</th><th align="left">IE</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_search.asp">search</a></td><td align="left">检索与正则表达式相匹配的值。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_match.asp">match</a></td><td align="left">找到一个或多个正则表达式的匹配。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_replace.asp">replace</a></td><td align="left">替换与正则表达式匹配的子串。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_split.asp">split</a></td><td align="left">把字符串分割为字符串数组。</td><td align="left">1</td><td align="left">4</td></tr></tbody></table><h2 id="几个正则例子"><a href="#几个正则例子" class="headerlink" title="几个正则例子"></a>几个正则例子</h2><h3 id="手机号匹配"><a href="#手机号匹配" class="headerlink" title="手机号匹配"></a>手机号匹配</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/^1[34578]\d&#123;9&#125;$/g</span><br></code></pre></td></tr></table></figure><p>^从字符串开头进行匹配</p><p>$从字符串末尾进行匹配</p><p>1 第一位为1</p><p>[34578]第二位一般是 3&#x2F;4&#x2F;5&#x2F;7&#x2F;8</p><p>\d 表示所有数字</p><p>{9}表示重复的次数（这里表示 9 个数字）</p><p>g 表示全局模式</p><h3 id="qq-号匹配"><a href="#qq-号匹配" class="headerlink" title="qq 号匹配"></a>qq 号匹配</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/^[1-9][0-9]&#123;4,9&#125;$/g</span><br></code></pre></td></tr></table></figure><p>{4,9}表示重复次数的范围 （这里表示 4-9 个数字）</p><h3 id="十六进制表示颜色"><a href="#十六进制表示颜色" class="headerlink" title="十六进制表示颜色"></a>十六进制表示颜色</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">4BD1CC 或 <span class="hljs-comment">#0AB</span></span><br><span class="hljs-meta prompt_">/#</span><span class="language-bash">?([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span><br></code></pre></td></tr></table></figure><p>#? 表示 # 可有可无（开发时根据实际情况写）</p><p>(a|b) 表示两组（两种情况）</p><h3 id="常见邮箱格式"><a href="#常见邮箱格式" class="headerlink" title="常见邮箱格式"></a>常见邮箱格式</h3><p>可接受的字符有 英文字符 数字 _ - .</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">分成三组 <span class="hljs-number">12345678</span>@qq.com<br>/^([<span class="hljs-keyword">A</span>-Za-z0-<span class="hljs-number">9</span>_\-\.]+)@([<span class="hljs-keyword">A</span>-Za-z0-<span class="hljs-number">9</span>_\-\.]+)\.([<span class="hljs-keyword">A</span>-Za-z]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;)$/g<br></code></pre></td></tr></table></figure><p>-在正则中表示范围，.表示除了换行符外的任意字符，所以都需要转义</p><p>理论上来说是需要控制长度的，这里就不限定字符数了（+表示 1个字符到无限个字符）</p><h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.bilibili.com<span class="hljs-regexp">/danlaoshi/</span><span class="hljs-number">666</span>/<br><span class="hljs-regexp">/^((https?|ftp|file):\/\/)?([\da-z\.\-]+)\.)([a-z\.]&#123;2,6&#125;)([\/\w\.\-]*)*\/?$/g</span><br></code></pre></td></tr></table></figure><p>https? 就表示 http 或 https</p><p>我们输入网址时可能不会写上协议名称，因此分组并加上问号</p><p>+表示1到无穷大</p><p>*表示0到无穷大</p><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-variable">&lt;div class=&quot;lwj&quot;&gt;</span>lwj<span class="hljs-variable">&lt;/div&gt;</span><br><span class="hljs-variable">&lt;div&gt;</span><span class="hljs-variable">&lt;/div&gt;</span><br><span class="hljs-variable">&lt;img /&gt;</span><br><br>/^<span class="hljs-variable">&lt;([a-z]+)([^&gt;</span>]+)<span class="hljs-symbol">*</span>(?:&gt;(.<span class="hljs-symbol">*</span>)<span class="hljs-variable">&lt;\/\1&gt;</span>|<span class="hljs-string">\s+\/&gt;)$/gm</span><br></code></pre></td></tr></table></figure><p>\1 表示引用前面括号包裹起来的第一个组</p><p>也就是说，这里 \1 表示 ([a-z]+)</p><p>\s 表示空格</p><p>?: 出现在括号的开头 表示不需要捕获该组</p><h3 id="更多常用正则"><a href="#更多常用正则" class="headerlink" title="更多常用正则"></a>更多常用正则</h3><p><a href="https://juejin.cn/post/7119242343798013959">https://juejin.cn/post/7119242343798013959</a></p><h2 id="在线测试工具"><a href="#在线测试工具" class="headerlink" title="在线测试工具"></a>在线测试工具</h2><p><a href="https://c.runoob.com/front-end/854/">https://c.runoob.com/front-end/854/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp">https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp</a></p><p><a href="https://www.bilibili.com/video/BV1QK4y1K72U/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=1616b746cefe2e7615c229563ba38eb4">https://www.bilibili.com/video/BV1QK4y1K72U/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=1616b746cefe2e7615c229563ba38eb4</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>正则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue源码解析</title>
    <link href="/2022/07/10/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/10/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>(更新中)</p><h1 id="数据响应式原理"><a href="#数据响应式原理" class="headerlink" title="数据响应式原理"></a>数据响应式原理</h1><h2 id="将数据变为响应式"><a href="#将数据变为响应式" class="headerlink" title="将数据变为响应式"></a>将数据变为响应式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 让 data 变为响应式</span><br><span class="hljs-comment">// let val 临时变量也是可以的, 但是不美观, 可以封装到函数 defineReactive 中 , 也方便复用</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, val</span>) &#123;<br>    <span class="hljs-comment">// 没传 val 的话 就使用原有的值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>        val = data[key]<br>    &#125;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// getter</span><br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;访问 obj 的&#x27;</span> + key + <span class="hljs-string">&#x27;属性&#x27;</span>)<br>            <span class="hljs-keyword">return</span> val<br>        &#125;,<br>        <span class="hljs-comment">// setter</span><br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;改变 obj 的&#x27;</span> + key + <span class="hljs-string">&#x27;属性&#x27;</span>, newValue)<br>            <span class="hljs-keyword">if</span> (val === newValue) <span class="hljs-keyword">return</span><br>            val = newValue<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归侦测对象全部属性"><a href="#递归侦测对象全部属性" class="headerlink" title="递归侦测对象全部属性"></a>递归侦测对象全部属性</h2><p>若对象层级深，深层对象并不是响应式的，需要递归对象的全部属性</p><p>创建 Observer 类将一个 object 转换为每个层级的属性都是响应式的</p><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// \src\index.js</span><br><span class="hljs-keyword">import</span> observe <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./observe.js&#x27;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123;<br>        <span class="hljs-attr">c</span>: <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 递归入口 */</span><br><span class="hljs-title function_">observe</span>(obj)<br><br>obj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>)<br></code></pre></td></tr></table></figure><h3 id="observe-辅助函数"><a href="#observe-辅助函数" class="headerlink" title="observe 辅助函数"></a>observe 辅助函数</h3><p>作用: 1.判断递归出口    2.避免循环引用反复创建 Observer 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// \src\observe.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Observer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Observer&quot;</span><br><br><span class="hljs-comment">/* 创建 observe 函数 -- 作用: 1.判断递归出口    2.避免循环引用反复创建 Observer 实例 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 递归的出口</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">let</span> ob<br>    <span class="hljs-comment">// 防止循环引用</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value.<span class="hljs-property">__ob__</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>        ob = value.<span class="hljs-property">__ob__</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(value)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Observer-类"><a href="#Observer-类" class="headerlink" title="Observer 类"></a>Observer 类</h3><p>给 value __ob__ 属性, 遍历所有属性并调用 defineReactive 使它们变为响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// \src\Observer.js</span><br><br><span class="hljs-keyword">import</span> &#123; def &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span><br><span class="hljs-keyword">import</span> defineReactive <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./defineReactive&#x27;</span><br><br><span class="hljs-comment">/* Observer 类, 给 value __ob__ 属性, 遍历所有属性并调用 defineReactive 使它们变为响应式 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-comment">// this 为 new 的实例</span><br>        <span class="hljs-title function_">def</span>(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-variable language_">this</span>, <span class="hljs-literal">false</span>)   <span class="hljs-comment">// 目前 __ob__ 的意义好像只有在 observe 中判断循环引用</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Observer 构造器&#x27;</span>, value)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value)<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历所有键, 让其响应式</span><br>    <span class="hljs-title function_">walk</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> value) &#123;<br>            <span class="hljs-title function_">defineReactive</span>(value, k)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="defineReactive-函数"><a href="#defineReactive-函数" class="headerlink" title="defineReactive 函数"></a>defineReactive 函数</h3><p>让 data 变为响应式, 对每个 val 调用 observe, 开启递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// \src\defineReactive.js</span><br><br><span class="hljs-keyword">import</span> observe <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./observe.js&#x27;</span><br><br><span class="hljs-comment">/* 让 data 变为响应式, 对每个 val 调用 observe, 开启递归 */</span><br><span class="hljs-comment">// let val 临时变量也是可以的, 但是不美观, 可以封装到函数 defineReactive 中 , 也方便复用</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, val</span>) &#123;<br>    <span class="hljs-comment">// 没传 val 的话 就使用原有的值</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是 defineReactive&#x27;</span>, data, key)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>        val = data[key]<br>    &#125;<br><br>    <span class="hljs-comment">// 子元素要进行 observe, 至此形成递归. 这个递归是函数循环调用，不是自己调自己</span><br>    <span class="hljs-keyword">let</span> childOb = <span class="hljs-title function_">observe</span>(val)<br><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// getter</span><br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;访问&#x27;</span> + key + <span class="hljs-string">&#x27;属性&#x27;</span>)<br>            <span class="hljs-keyword">return</span> val<br>        &#125;,<br>        <span class="hljs-comment">// setter</span><br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;改变&#x27;</span> + key + <span class="hljs-string">&#x27;属性&#x27;</span>, newValue)<br>            <span class="hljs-keyword">if</span> (val === newValue) <span class="hljs-keyword">return</span><br>            val = newValue<br>            <span class="hljs-comment">// 当设置了新值, 新值也要 observe</span><br>            childOb = <span class="hljs-title function_">observe</span>(newValue)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>重写下 Object.defineProperty, 将 enumerable 变为参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// \src\utils.js</span><br><br><span class="hljs-comment">/* 重写下 Object.defineProperty, 将 enumerable 变为参数 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> def = <span class="hljs-keyword">function</span>(<span class="hljs-params">obj, key, value, enumerable</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>        value, <br>        enumerable,<br>        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="整个流程"><a href="#整个流程" class="headerlink" title="整个流程"></a>整个流程</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">执行<span class="hljs-built_in">observe</span>(obj)<br>├── new <span class="hljs-built_in">Observer</span>(obj),并执行this<span class="hljs-selector-class">.walk</span>()遍历obj的属性，执行<span class="hljs-built_in">defineReactive</span>()<br>    ├── <span class="hljs-built_in">defineReactive</span>(obj, a)<br>        ├── 执行<span class="hljs-built_in">observe</span>(obj.a) 发现obj<span class="hljs-selector-class">.a</span>不是对象，直接返回<br>        ├── 执行<span class="hljs-built_in">defineReactive</span>(obj, a) 的剩余代码(定义obj的a属性的响应式)<br>    ├── <span class="hljs-built_in">defineReactive</span>(obj, b) <br>    ├── 执行<span class="hljs-built_in">observe</span>(obj.b) 发现obj<span class="hljs-selector-class">.b</span>是对象<br>        ├── 执行 new <span class="hljs-built_in">Observer</span>(obj.b)，遍历obj<span class="hljs-selector-class">.b</span>的属性，执行<span class="hljs-built_in">defineReactive</span>()<br>                    ├── 执行<span class="hljs-built_in">defineReactive</span>(obj.b, c)<br>                        ├── 执行<span class="hljs-built_in">observe</span>(obj.b.c) 发现obj<span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.c</span>不是对象，直接返回<br>                        ├── 执行<span class="hljs-built_in">defineReactive</span>(obj.b, c)的剩余代码(定义obj.b的c属性的响应式)<br>            ├── 执行<span class="hljs-built_in">defineReactive</span>(obj, b)的剩余代码(定义obj的b属性的响应式)<br>代码执行结束<br></code></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>不是自己调用自己的递归，还是三个函数相互调用的循环</p><img src="/2022/07/10/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220710214346769.png" class="" title="image-20220710214346769"><p>当传入 observe 的值不是对象时跳出递归</p><h2 id="数组的响应式处理"><a href="#数组的响应式处理" class="headerlink" title="数组的响应式处理"></a>数组的响应式处理</h2><h3 id="为什么需要处理数组的响应式"><a href="#为什么需要处理数组的响应式" class="headerlink" title="为什么需要处理数组的响应式"></a>为什么需要处理数组的响应式</h3><p>正因为我们可以<strong>通过Array原型上的方法来改变数组的内容</strong>，所以 object 那种<strong>通过getter&#x2F;setter的实现方式就行不通了</strong>。</p><p>ES6 之前没有提供可以拦截原型方法的能力，我们可以用自定义的方法去覆盖原生的原型方法。</p><p><strong>Vue 是通过改写数组的七个方法（可以改变数组自身内容的方法）来实现对数组的响应式处理</strong></p><p>这些方法分别是：<strong>push、pop、shift、unshift、splice、sort、reverse</strong></p><h3 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h3><p>这七个方法都是定义在 Array.prototype上，要保留方法的功能，同时增加数据劫持的代码</p><p>思路就是 以 Array.prototype为原型，创建一个新对象 arrayMethods<br>然后在新对象arrayMethods上定义（改写）这些方法<br>定义 数组 的原型指向 arrayMethods</p><p>这就相当于用一个拦截器覆盖 Array.prototype，每当使用Array原型上的方法操作数组时，其实执行的是拦截器中提供的方法。在拦截器中使用原生Array的原型方法去操作数组。</p><h3 id="重写数组方法"><a href="#重写数组方法" class="headerlink" title="重写数组方法"></a>重写数组方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// array.js</span><br><span class="hljs-keyword">import</span> &#123; def &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span><br><br><span class="hljs-keyword">const</span> arrayPrototype = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><br><span class="hljs-comment">// 以 arrayPrototype 为原型创建 arrayMethods 对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(arrayPrototype)<br><br><span class="hljs-keyword">const</span> methodsNeedChange = [<br>    <span class="hljs-string">&#x27;push&#x27;</span>,<br>    <span class="hljs-string">&#x27;pop&#x27;</span>,<br>    <span class="hljs-string">&#x27;shift&#x27;</span>,<br>    <span class="hljs-string">&#x27;unshift&#x27;</span>,<br>    <span class="hljs-string">&#x27;splice&#x27;</span>,<br>    <span class="hljs-string">&#x27;sort&#x27;</span>,<br>    <span class="hljs-string">&#x27;reverse&#x27;</span><br>]<br><br>methodsNeedChange.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">methodName</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 备份原来的方法</span><br>    <span class="hljs-keyword">const</span> original = arrayPrototype[methodName]<br><br>    <span class="hljs-comment">// 定义新的方法</span><br>    <span class="hljs-title function_">def</span>(arrayMethods, methodName, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 恢复原来的功能</span><br>        <span class="hljs-keyword">const</span> result = original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>)<br><br>        <span class="hljs-comment">// 把这个数组身上的 __ob__ 取出来,</span><br>        <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span><br><br>        <span class="hljs-comment">// 有三种方法 push unshift splice 能插入新项, 要将新项变为 observe的</span><br>        <span class="hljs-comment">// inserted 用来存要插入的项</span><br>        <span class="hljs-keyword">let</span> inserted = []<br>        <br>        <span class="hljs-comment">// 根据方法名来判断要插入的项是什么并存入 inserted</span><br>        <span class="hljs-keyword">switch</span>(methodName) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;unshift&#x27;</span>:<br>                inserted = <span class="hljs-variable language_">arguments</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;splice&#x27;</span>:<br>                inserted = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>)<br>                <span class="hljs-keyword">break</span><br>        &#125;<br><br>        <span class="hljs-comment">// 判断有没有要插入的新项, 让新项也变为响应的</span><br>        <span class="hljs-keyword">if</span> (inserted.<span class="hljs-property">length</span>) &#123;<br>            ob.<span class="hljs-title function_">observeArray</span>(inserted)<br>        &#125;<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;啦啦啦&#x27;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    &#125;, <span class="hljs-literal">false</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="observeArray"><a href="#observeArray" class="headerlink" title="observeArray"></a>observeArray</h3><p>如果是数组的话走 observeArray 来遍历所有键；否则走 walk</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; def &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span><br><span class="hljs-keyword">import</span> defineReactive <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./defineReactive.js&#x27;</span><br><span class="hljs-keyword">import</span> &#123; arrayMethods &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./array.js&#x27;</span><br><span class="hljs-keyword">import</span> observe <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./observe.js&#x27;</span><br><br><span class="hljs-comment">/* Observer 类, 给 value __ob__ 属性, 遍历所有属性并调用 defineReactive 使它们变为响应式 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-comment">// this 为 new 的实例</span><br>        <span class="hljs-title function_">def</span>(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-variable language_">this</span>, <span class="hljs-literal">false</span>)   <span class="hljs-comment">// 目前 __ob__ 的意义好像只有在 observe 中判断循环引用</span><br><br>        <span class="hljs-comment">// 检查是数组还是对象</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>            <span class="hljs-comment">// 如果是数组, 将这个数组的原型指向 arrayMethods (arrayMethods的原型上的方法是改写过的)</span><br>            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(value, arrayMethods)<br>            <span class="hljs-comment">// 让这个数组变得 observe</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observeArray</span>(value)<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历所有键, 让其响应式</span><br>    <span class="hljs-title function_">walk</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> value) &#123;<br>            <span class="hljs-title function_">defineReactive</span>(value, k)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 数组的特殊遍历</span><br>    <span class="hljs-title function_">observeArray</span>(<span class="hljs-params">arr</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = arr.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>            <span class="hljs-comment">// 逐项 observe</span><br>            <span class="hljs-title function_">observe</span>(arr[i])<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>Dep 类</p><p>依赖收集，用来管理依赖</p><p>每个 Observer 的实例成员中都有一个 Dep 的实例</p><p>Watcher 类</p><p>中介，数据发生</p><img src="/2022/07/10/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220713134710965.png" class="" title="image-20220713134710965"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1G54y1s7xV/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=1616b746cefe2e7615c229563ba38eb4">https://www.bilibili.com/video/BV1G54y1s7xV/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=1616b746cefe2e7615c229563ba38eb4</a></p><p><a href="https://juejin.cn/post/6932659815424458760">https://juejin.cn/post/6932659815424458760</a></p><p><a href="https://blog.csdn.net/weixin_44972008/article/details/115922118">https://blog.csdn.net/weixin_44972008/article/details/115922118</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双向绑定</tag>
      
      <tag>虚拟DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JS</title>
    <link href="/2022/07/10/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"/>
    <url>/2022/07/10/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/</url>
    
    <content type="html"><![CDATA[<h1 id="（更新中）"><a href="#（更新中）" class="headerlink" title="（更新中）"></a>（更新中）</h1><h1 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h1><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><h3 id="传统编译语言"><a href="#传统编译语言" class="headerlink" title="传统编译语言"></a>传统编译语言</h3><h4 id="分词-x2F-词法分析"><a href="#分词-x2F-词法分析" class="headerlink" title="分词&#x2F;词法分析"></a>分词&#x2F;词法分析</h4><p><strong>将由字符组成的字符串分解成有意义的代码块（词法单元 token）</strong></p><p>var a &#x3D; 2; 会被拆为 var、a、&#x3D;、2、；</p><h4 id="解析-x2F-语法分析"><a href="#解析-x2F-语法分析" class="headerlink" title="解析&#x2F;语法分析"></a>解析&#x2F;语法分析</h4><p><strong>将词法单元流（数组）转换成抽象语法树（Abstract Syntax Tree, AST）</strong></p><p>var a &#x3D; 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作NumericLiteral（它的值是2）的子节点。</p><h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p><strong>将 AST 转换为可执行代码的过程被称为代码生成。</strong></p><p>简单来说就是有某种方法可以将var a &#x3D; 2; 的 AST 转化为一组机器指令，用来创建一个叫作a 的变量（包括分配内存等），并将一个值储存在a 中。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><img src="你不知道的JS/image-20220710153154238.png" alt="image-20220710153154238" style="zoom:80%;" /><h3 id="JS-的编译过程"><a href="#JS-的编译过程" class="headerlink" title="JS 的编译过程"></a>JS 的编译过程</h3><p>复杂得多（时间短，需要优化性能）</p><p>对于JS来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳。</p><p>简单地说，任何JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript 编译器首先会对var a &#x3D; 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。</p><h3 id="处理工具"><a href="#处理工具" class="headerlink" title="处理工具"></a>处理工具</h3><h4 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h4><p>从头到尾负责整个JavaScript 程序的编译及执行过程。</p><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>负责<strong>语法分析及代码生成</strong>等</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>负责<strong>收集并维护由所有声明的标识符（变量）组成的一系列查询</strong>，并实施一套非常严格的规则，<strong>确定</strong>当前执行的代码对这些标识符的<strong>访问权限</strong>。</p><h3 id="var-a-x3D-2-后发生了什么"><a href="#var-a-x3D-2-后发生了什么" class="headerlink" title="var a &#x3D; 2 后发生了什么"></a>var a &#x3D; 2 后发生了什么</h3><p>编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。然后开始生成代码。</p><p>在生成代码的过程中：变量的赋值操作会执行两个动作。</p><ol><li><p>首先编译器会在当前作用域中声明一个变量（如果之前没有声明过，否则忽略声明继续编译）</p></li><li><p>然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值（找不到就抛出异常）。</p></li></ol><p><strong>引擎如何查找变量</strong></p><p><strong>LHS 查询</strong></p><p>如果查找的目的是对变量进行赋值，那么就会使用LHS 查询</p><p>a &#x3D; 2</p><p><strong>RHS 查询</strong></p><p>如果目的是获取变量的值，就会使用RHS 查询。</p><p>console.log(a)</p><h2 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h2><h3 id="作用域-2"><a href="#作用域-2" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是根据名称查找变量的一套规则。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a><strong>作用域链</strong></h3><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>大部分标准语言编译器的第一个工作阶段叫作词法化</p><p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，是静态的。</p><h3 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h3><p><strong>欺骗词法作用域会导致性能下降</strong></p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>动态生成代码（即通过代码生成代码）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str, a</span>) &#123;<br>    <span class="hljs-built_in">eval</span>( str ); <span class="hljs-comment">// 欺骗！</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a, b );<br>&#125;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-title function_">foo</span>( <span class="hljs-string">&quot;var b = 3;&quot;</span>, <span class="hljs-number">1</span> ); <span class="hljs-comment">// 1, 3</span><br></code></pre></td></tr></table></figure><p>严格模式下，eval(..) 在运行时有其自己的词法作用域，无法欺骗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <span class="hljs-built_in">eval</span>( str );<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// ReferenceError: a is not defined</span><br>&#125;<br><span class="hljs-title function_">foo</span>( <span class="hljs-string">&quot;var a = 2&quot;</span> );<br></code></pre></td></tr></table></figure><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。</p><p>严格模式禁止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-comment">// 单调乏味的重复&quot;obj&quot;</span><br>obj.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;<br>obj.<span class="hljs-property">b</span> = <span class="hljs-number">3</span>;<br>obj.<span class="hljs-property">c</span> = <span class="hljs-number">4</span>;<br><span class="hljs-comment">// 简单的快捷方式</span><br><span class="hljs-keyword">with</span> (obj) &#123;<br>    a = <span class="hljs-number">3</span>;<br>    b = <span class="hljs-number">4</span>;<br>    c = <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在全局变量泄露的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">with</span> (obj) &#123;<br>        a = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> o1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-keyword">var</span> o2 = &#123;<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-title function_">foo</span>( o1 );<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( o1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2</span><br><span class="hljs-title function_">foo</span>( o2 );<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( o2.<span class="hljs-property">a</span> ); <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2——a 被泄漏到全局作用域上了</span><br></code></pre></td></tr></table></figure><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>性能很差，不要使用！</p><p>原因：JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。使用 eval 或 with 会使他们失效。</p>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>作用域</tag>
      
      <tag>this</tag>
      
      <tag>对象</tag>
      
      <tag>原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/07/09/Git/"/>
    <url>/2022/07/09/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><img src="/2022/07/09/Git/image-20220709160235846.png" class="" title="image-20220709160235846"><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="用户设置"><a href="#用户设置" class="headerlink" title="用户设置"></a>用户设置</h3><p><strong>设置用户名</strong></p><p>git config –global user.name lwj</p><p><strong>设置邮箱</strong></p><p>git config –global user.email <a href="mailto:&#54;&#49;&#x39;&#53;&#x30;&#48;&#56;&#x32;&#56;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;">&#54;&#49;&#x39;&#53;&#x30;&#48;&#56;&#x32;&#56;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;</a></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>git init</p><p>多了一个 .git 文件夹，git 的所有记录都在此文件夹中</p><p>默认位于 master (主分支)</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>echo “版本1” &gt; lao.md</p><p>lao.md 为我们创建的文件；版本1 为在文件中添加的内容</p><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><p>git status</p><p>用于查看目前分支，以及需要做什么步骤</p><img src="/2022/07/09/Git/image-20220709161701963.png" class="" title="image-20220709161701963"><p>处于 master 分支</p><p>刚刚添加的文件 lao.md 为 untracked files，需要添加到缓存区</p><h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><p>git add lao.md</p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p>git commit会进入 vim 编辑器</p><p>git commit -m “版本2和版本3”加上 -m 和提交信息 则不会进入 vim</p><h3 id="查看之前版本"><a href="#查看之前版本" class="headerlink" title="查看之前版本"></a>查看之前版本</h3><p>git log</p><img src="/2022/07/09/Git/image-20220709162553790.png" class="" title="image-20220709162553790"><h3 id="不需要提交的文件"><a href="#不需要提交的文件" class="headerlink" title="不需要提交的文件"></a>不需要提交的文件</h3><p>创建 .gitignore 文件</p><p>echo &gt; .gitignore</p><p>在 .gitignore 中写上不想提交的文件 rubbish.md，git status 后就不会显示该文件了</p><img src="/2022/07/09/Git/image-20220709163820131.png" class="" title="image-20220709163820131"><p>配置 .gitignore 后</p><img src="/2022/07/09/Git/image-20220709163829783.png" class="" title="image-20220709163829783"><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>一个分支代表一条独立的开发线。</p><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><img src="/2022/07/09/Git/image-20220709164756819.png" class="" title="image-20220709164756819"><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>git branch 分支名</p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><p>git branch</p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>git checkout 分支名</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>git branch -d 分支名（会有提示）</p><p>git branch -D 分支名（不会有提示，非常确定要删除时使用）</p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>把别的分支合并到当前所处分支</p><p>git merge 分支名</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="拷贝远程仓库到本地"><a href="#拷贝远程仓库到本地" class="headerlink" title="拷贝远程仓库到本地"></a>拷贝远程仓库到本地</h3><p>直接 download，则版本历史和记录(.git)不会下载</p><p>使用 git clone url 更好</p><h3 id="查看本地仓库与远程仓库的联系"><a href="#查看本地仓库与远程仓库的联系" class="headerlink" title="查看本地仓库与远程仓库的联系"></a>查看本地仓库与远程仓库的联系</h3><p>git remote -v</p><h3 id="更新远程仓库"><a href="#更新远程仓库" class="headerlink" title="更新远程仓库"></a>更新远程仓库</h3><p>git push</p><p>2021年后不支持通过账号密码，而要生成个人 token</p><h3 id="更新本地仓库"><a href="#更新本地仓库" class="headerlink" title="更新本地仓库"></a>更新本地仓库</h3><p>git fetch (远程仓库&#x2F;分支名)更新本地仓库，本地文件（工作区）并不会改变</p><p>git diff 远程仓库名&#x2F;分支名查看工作区和本地仓库的区别</p><p>如果没问题则可使用 git pull 把远程仓库的内容直接整合到工作区</p><h2 id="vscode-中的-git"><a href="#vscode-中的-git" class="headerlink" title="vscode 中的 git"></a>vscode 中的 git</h2><p>初始化仓库</p><p>相当于 git init</p><img src="/2022/07/09/Git/image-20220709170218325.png" class="" title="image-20220709170218325"><p>一些操作</p><img src="/2022/07/09/Git/image-20220709170748070.png" class="" title="image-20220709170748070"><p>左下角切换分支</p><img src="/2022/07/09/Git/image-20220709171256207.png" class="" title="image-20220709171256207"><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><p>stash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>1.需要临时切分支时</p><p>2.多人同时修改同一分支时</p><img src="Git/image-20220805172652696.png" alt="image-20220805172652696" style="zoom:80%;" /><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 保存当前未commit的代码</span><br>git stash<br><br><span class="hljs-comment"># 保存当前未commit的代码并添加备注</span><br>git stash save <span class="hljs-string">&quot;备注的内容&quot;</span><br><br><span class="hljs-comment"># 列出stash的所有记录</span><br>git stash list<br><br><span class="hljs-comment"># 删除stash的所有记录</span><br>git stash clear<br><br><span class="hljs-comment"># 应用最近一次的stash</span><br>git stash apply<br><br><span class="hljs-comment"># 应用最近一次的stash，随后删除该记录</span><br>git stash pop<br><br><span class="hljs-comment"># 删除最近的一次stash</span><br>git stash drop<br>复制代码<br></code></pre></td></tr></table></figure><p>当有多条 stash，可以指定操作stash，首先使用stash list 列出所有记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git stash list<br>stash@&#123;0&#125;: WIP on ...<br>stash@&#123;1&#125;: WIP on ...<br>stash@&#123;2&#125;: On ...<br>复制代码<br></code></pre></td></tr></table></figure><p>应用第二条记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git stash apply stash@&#123;1&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>pop，drop 同理。</p><h2 id="使用顺序注意"><a href="#使用顺序注意" class="headerlink" title="使用顺序注意"></a>使用顺序注意</h2><p><a href="https://blog.csdn.net/aaaaa1994/article/details/90340224">https://blog.csdn.net/aaaaa1994/article/details/90340224</a> 实习期间遇到了同样的问题</p><p>1.本地修改与远程代码无冲突，优先使用</p><p>pull -&gt; commit -&gt; push</p><p><strong>2.本地修改与远程代码有冲突，优先使用</strong></p><p>commit -&gt; pull -&gt; push</p><p>pull 是为了本地 commit 和远程 commit 的对比记录</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.337.search-card.all.click&amp;vd_source=1616b746cefe2e7615c229563ba38eb4">https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.337.search-card.all.click&amp;vd_source=1616b746cefe2e7615c229563ba38eb4</a></p><p><a href="https://www.runoob.com/git/git-basic-operations.html">https://www.runoob.com/git/git-basic-operations.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3</title>
    <link href="/2022/07/01/vue3/"/>
    <url>/2022/07/01/vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h1><h2 id="构建与结构"><a href="#构建与结构" class="headerlink" title="构建与结构"></a>构建与结构</h2><h3 id="使用-vite-快速构建一个-vue3-项目"><a href="#使用-vite-快速构建一个-vue3-项目" class="headerlink" title="使用 vite 快速构建一个 vue3 项目"></a>使用 vite 快速构建一个 vue3 项目</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>初始化<br><span class="hljs-regexp">//</span> yarn create vite<br><span class="hljs-built_in">npm</span> init vite@latest<br><br><span class="hljs-number">2.</span>进入文件夹后安装依赖包<br><span class="hljs-built_in">npm</span> install<br><br><span class="hljs-number">3.</span>启动()<br><span class="hljs-built_in">npm</span> run dev<br></code></pre></td></tr></table></figure><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>vue2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;)<br>vm.$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>vue3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入的不再是Vue构造函数了，引入的是一个名为createApp的工厂函数</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">//创建应用实例对象——app(类似于之前Vue2中的vm，但app比vm更“轻”)</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br><span class="hljs-comment">//挂载</span><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br><span class="hljs-comment">// 卸载</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    app.<span class="hljs-title function_">unmount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h2 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h2><h3 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h3><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><ol><li><p>Vue3.0 中的新配置项，值为一个函数</p></li><li><p>组件中所用到的数据、方法等都要配置在 setup 中</p></li><li><p>setup 函数有两种返回值：</p></li></ol><p><strong>返回一个对象，对象中的属性、方法，在模板中均可直接使用</strong></p><p>返回一个渲染函数，可以自定义渲染内容（较少使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;h1&gt;信息：&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;sayHello&quot;&gt;说话&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; h &#125; from &#x27;vue&#x27;<br><br>export default &#123;<br>    name: &#x27;App&#x27;,<br><br>    // 这样的数据无响应式<br>    setup() &#123;<br>        // 数据<br>        let name = &#x27;张三&#x27;<br>        let age = 18<br><br>        // 方法<br>        function sayHello() &#123;<br>            alert(`我叫xxx$&#123;name&#125;, 我$&#123;age&#125;岁了`)<br>        &#125;<br><br>        // 返回一个对象<br>        /* return &#123;<br>            name,<br>            age,<br>            sayHello<br>        &#125; */<br><br>        // 返回一个函数 (渲染函数)<br>        return () =&gt; &#123;return h(&#x27;h1&#x27;, &#x27;尚硅谷&#x27;)&#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>vue2 中定义 data &#x2F; methods 都是键值对形式的，因为本身式对象（所以不需要 let &#x2F; function）</p><p>vue3 setup是一个函数，所以里面的数据和方法都是需要定义的。并且 setup 不能用 async 定义。</p><h5 id="setup-的两个参数"><a href="#setup-的两个参数" class="headerlink" title="setup 的两个参数"></a>setup 的两个参数</h5><p>props 和 context </p><p>context 里有三个属性：attrs、emit、slots</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">export default &#123;<br>name: &#x27;Demo&#x27;,<br>props:[&#x27;msg&#x27;,&#x27;school&#x27;],<br>    emits:[&#x27;hello&#x27;],<br>    setup(props,&#123;attrs, emit, slots&#125;)&#123;&#125;<br></code></pre></td></tr></table></figure><p>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</p><p>context：上下文对象</p><p>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。</p><p>slots: 收到的插槽内容, 相当于 this.$slots。</p><p>emit: 分发自定义事件的函数, 相当于 this.$emit。</p><p><strong><a href="https://blog.csdn.net/LueLueLue77/article/details/124964058">context 里还有 expose</a></strong></p><p>expose可以使父组件直接去修改子组件的数据</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p><strong>作用：定义一个响应式数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;h1&gt;信息：&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>&lt;h3&gt;工作种类：&#123;&#123;job.type&#125;&#125;&lt;/h3&gt;<br>&lt;h3&gt;工作薪水：&#123;&#123;job.salary&#125;&#125;&lt;/h3&gt;<br>    &lt;button @click=&quot;changeInfo&quot;&gt;修改人的信息&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    import &#123;ref&#125; from &#x27;vue&#x27;<br><br>    export default &#123;<br>        name: &#x27;App&#x27;,<br><br>        // 这样的数据无响应式<br>        setup() &#123;<br>            // 数据<br>let name = ref(&#x27;张三&#x27;)<br>let age = ref(23)<br>let job = ref(&#123;<br>type:&#x27;前端&#x27;,<br>salary:&#x27;20K&#x27;<br>&#125;)<br><br>            // 方法<br>            function changeInfo() &#123;<br>                name.value = &#x27;李四&#x27;<br>                age.value = 33<br>                job.value.type = &#x27;算法&#x27;<br>                job.value.salary = &#x27;30K&#x27;<br>            &#125;<br><br>            // 返回一个对象<br>            return &#123;<br>                name,<br>                age,<br>                job,<br>                changeInfo<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>为什么修改数据需要 .value？</strong></p><p>被 ref 包裹的数据变为了对象，是 RefImpl (reference implement) 的实例，可称为引用对象，就实现响应式了。</p><img src="/2022/07/01/vue3/image-20220701143037245.png" class="" title="image-20220701143037245"><p><strong>为什么 html 部分不需要 .value？</strong></p><p>检测到是响应式数据后，会自动解析</p><p><strong>ref 处理对象类型用的 proxy（操作封装在 reactive 函数中），简单类型还是用的 object.defineProperty（本身object.defineProperty的问题就在于对象&#x2F;数组）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// name是简单数据类型, job是对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-property">value</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(job.<span class="hljs-property">value</span>)<br></code></pre></td></tr></table></figure><img src="/2022/07/01/vue3/image-20220701150926114.png" class="" title="image-20220701150926114"><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><p><strong>作用：定义一个&#x3D;&#x3D;对象类型&#x3D;&#x3D;的响应式数据</strong></p><p>对象使用 reactive 而不是用 ref ，可以少写 .value</p><p><strong>语法：</strong>const 代理对象&#x3D; reactive(源对象)接收一个对象（或数组），<strong>返回一个代理对象</strong>（Proxy的实例对象）。</p><p>通过代理对象修改源对象。</p><p><strong>可以将多个简单数据类型封装为一个对象使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;h1&gt;信息：&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;<br>&lt;h3&gt;工作种类：&#123;&#123;person.job.type&#125;&#125;&lt;/h3&gt;<br>&lt;h3&gt;工作薪水：&#123;&#123;person.job.salary&#125;&#125;&lt;/h3&gt;<br>    &lt;h3&gt;爱好：&#123;&#123;person.hobby&#125;&#125;&lt;/h3&gt;<br>    &lt;h3&gt;测试的数据c：&#123;&#123;person.job.a.b.c&#125;&#125;&lt;/h3&gt;<br>    &lt;button @click=&quot;changeInfo&quot;&gt;修改人的信息&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    import &#123;reactive&#125; from &#x27;vue&#x27;<br><br>    export default &#123;<br>        name: &#x27;App&#x27;,<br><br>        setup() &#123;<br>            let person = reactive(&#123;<br>                name: &#x27;张三&#x27;,<br>                age: 28,<br>                job: &#123;<br>                    type:&#x27;前端&#x27;,<br>                    salary:&#x27;20K&#x27;,<br>                    a: &#123;<br>                        b: &#123;<br>                            c: 666<br>                        &#125;<br>                    &#125;<br>                &#125;,<br>                hobby: [&#x27;抽烟&#x27;, &#x27;喝酒&#x27;, &#x27;烫头&#x27;]<br>            &#125;)<br>           <br>            // 方法<br>            function changeInfo() &#123;<br>                person.name = &#x27;李四&#x27;,<br>                person.age = 48,<br>                person.job.type = &#x27;算法&#x27;,<br>                person.job.salary = &#x27;30K&#x27;<br>                person.job.a.b.c = 999,<br>                person.hobby[0] = &#x27;学习&#x27;<br>            &#125;<br><br>            // 返回一个对象<br>            return &#123;<br>                person,<br>                changeInfo<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><h5 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h5><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, <span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>    get () &#123;&#125;, <br>    set () &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h5 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h5><ul><li><p>实现原理: </p><ul><li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p></li><li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p></li><li><p>MDN文档中描述的Proxy与Reflect：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br><span class="hljs-comment">// 拦截读取属性值</span><br>    get (target, prop) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截设置属性值或添加新属性</span><br>    set (target, prop, value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, prop, value)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截删除属性</span><br>    deleteProperty (target, prop) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, prop)<br>    &#125;<br>&#125;)<br><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;tom&#x27;</span>   <br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="reactive与ref"><a href="#reactive与ref" class="headerlink" title="reactive与ref"></a>reactive与ref</h4><ul><li><p>从定义数据角度对比：</p><ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li><p>从原理角度对比：</p><ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li><p>从使用角度对比：</p><ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li><li><p>从是否丢失相应性对比：</p><ul><li><p>refactive 被传递给函数或是从一般对象上被解构时，不会丢失响应性。</p></li><li><p>ref 被传递给函数或是从一般对象上被解构时，不会丢失响应性。</p></li></ul><p><strong>简言之，<code>ref()</code> 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。</strong></p></li></ul><h4 id="ref-实验中"><a href="#ref-实验中" class="headerlink" title="$ref(实验中)"></a>$ref(实验中)</h4><p>相对于普通的 JavaScript 变量，我们不得不用相对繁琐的 <code>.value</code> 来获取 ref 的值。这是一个受限于 JavaScript 语言限制的缺点。然而，通过编译时转换，我们可以让编译器帮我们省去使用 <code>.value</code> 的麻烦。Vue 提供了一种编译时转换，使得我们可以像这样书写之前的“计数器”示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue3">&lt;script setup&gt;<br>let count = $ref(0)<br><br>function increment() &#123;<br>  // 无需 .value<br>  count++<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h4 id="setup-注意点"><a href="#setup-注意点" class="headerlink" title="setup 注意点"></a>setup 注意点</h4><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul><img src="/2022/07/01/vue3/image-20220701211921826.png" class="" title="image-20220701211921826"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params">props,context</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---setup---&#x27;</span>,context)<br>    <br>    <span class="hljs-comment">//数据</span><br>    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<br>        <span class="hljs-attr">age</span>:<span class="hljs-number">18</span><br>    &#125;)<br><br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>        context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">666</span>)<br>    &#125;<br><br>    <span class="hljs-comment">//返回一个对象</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        person,<br>        test<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;computed&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>    ...<br><span class="hljs-comment">//计算属性——简写(没有考虑计算属性被修改的情况)</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>    &#125;)<br>    <span class="hljs-comment">//计算属性——完整</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(&#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>            <span class="hljs-keyword">const</span> nameArr = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br>            person.<span class="hljs-property">firstName</span> = nameArr[<span class="hljs-number">0</span>]<br>            person.<span class="hljs-property">lastName</span> = nameArr[<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;)<br>    <br>    <span class="hljs-keyword">return</span> &#123;<br>        fullName<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</p><p>监视reactive定义的响应式数据中某个属性时：deep配置有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//情况一：监视ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>(sum,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-comment">//情况二：监视多个ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>([sum,msg],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)<br>&#125;) <br><br><span class="hljs-comment">/* 情况三：监视reactive定义的响应式数据</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-title function_">watch</span>(person,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">false</span>&#125;) <span class="hljs-comment">//此处的deep配置不再奏效</span><br><br><span class="hljs-comment">//情况四：监视reactive定义的响应式数据中的某个属性</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <br><br><span class="hljs-comment">//情况五：监视reactive定义的响应式数据中的某些属性</span><br><span class="hljs-title function_">watch</span>([<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">name</span>],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-comment">//特殊情况</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <span class="hljs-comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span><br></code></pre></td></tr></table></figure><h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h4><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：<strong>不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性</strong>。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> x1 = sum.<span class="hljs-property">value</span><br>    <span class="hljs-keyword">const</span> x2 = person.<span class="hljs-property">age</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;watchEffect配置的回调执行了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><strong>vue2</strong></p><img src="/2022/07/01/vue3/image-20220708144649496.png" class="" title="image-20220708144649496"><p><strong>vue3</strong></p><img src="/2022/07/01/vue3/image-20220708144757189.png" class="" title="image-20220708144757189"><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>created</code>&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>beforeMount</code> &#x3D;&#x3D;&gt;<code>onBeforeMount</code></li><li><code>mounted</code>&#x3D;&#x3D;&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li><li><code>updated </code>&#x3D;&#x3D;&gt;<code>onUpdated</code></li><li><code>beforeUnmount </code>&#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li><li><code>unmounted </code>&#x3D;&#x3D;&gt;<code>onUnmounted</code></li></ul></li></ul><h4 id="hook函数"><a href="#hook函数" class="headerlink" title="hook函数"></a>hook函数</h4><ul><li>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</li><li>类似于vue2.x中的mixin。</li><li>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</li></ul><p>一般写在 hooks 文件夹中，以 use 为开头命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// hooks/usePoint.js</span><br><span class="hljs-keyword">import</span> &#123;reactive,onMounted,onBeforeUnmount&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//实现鼠标“打点”相关的数据</span><br><span class="hljs-keyword">let</span> point = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">x</span>:<span class="hljs-number">0</span>,<br><span class="hljs-attr">y</span>:<span class="hljs-number">0</span><br>&#125;)<br><br><span class="hljs-comment">//实现鼠标“打点”相关的方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">savePoint</span>(<span class="hljs-params">event</span>)&#123;<br>point.<span class="hljs-property">x</span> = event.<span class="hljs-property">pageX</span><br>point.<span class="hljs-property">y</span> = event.<span class="hljs-property">pageY</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">pageX</span>,event.<span class="hljs-property">pageY</span>)<br>&#125;<br><br><span class="hljs-comment">//实现鼠标“打点”相关的生命周期钩子</span><br><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,savePoint)<br>&#125;)<br><br><span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,savePoint)<br>&#125;)<br><br><span class="hljs-keyword">return</span> point<br>&#125;<br></code></pre></td></tr></table></figure><p>组件使用时引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;h2&gt;当前点击时鼠标的坐标为：x：&#123;&#123;point.x&#125;&#125;，y：&#123;&#123;point.y&#125;&#125;&lt;/h2&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import usePoint from &#x27;../hooks/usePoint&#x27;<br>export default &#123;<br>name:&#x27;Test&#x27;,<br>setup()&#123;<br>const point = usePoint()<br>return &#123;point&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h4><ul><li><p>作用：<strong>创建一个 ref 对象，其value值指向另一个对象中的某个属性</strong>。<strong>（引用）</strong></p></li><li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p></li><li><p>应用:   <strong>要将响应式对象中的某个属性单独提供给外部使用时</strong>。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><h3 id="其他-API"><a href="#其他-API" class="headerlink" title="其他 API"></a>其他 API</h3><h4 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a>shallowReactive 与 shallowRef</h4><ul><li>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</li><li>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</li></ul><p>Ref 处理对象会向 Reactive 求助，而 shallowRef 并不会</p><ul><li>什么时候使用?<ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li></ul></li></ul><h4 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h4><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h4 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h4><ul><li>toRaw：<ul><li>作用：将一个由<strong>reactive</strong>生成的<strong>响应式对象</strong>转为<strong>普通对象</strong>。(ref 定义的会变成undefined)</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其<strong>永远不会再成为响应式对象</strong>。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h4 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h4><ul><li><p>作用：创建一个<strong>自定义 ref</strong>，并对其依赖项跟踪和更新触发进行显式控制（自定义 get 和 set 逻辑）。</p></li><li><p>实现防抖效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;input type=&quot;text&quot; v-model=&quot;keyWord&quot;&gt;<br>&lt;h3&gt;&#123;&#123;keyWord&#125;&#125;&lt;/h3&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; clear &#125; from &#x27;console&#x27;<br>import &#123;ref, customRef&#125; from &#x27;vue&#x27;<br>export default &#123;<br>name: &#x27;App&#x27;,<br>setup() &#123;<br>// 自定义 ref<br>function myRef(value, delay) &#123;<br>let timer<br>// 不可能从头写底层, 实际上实在 customRef 上去修改（自定义）, 将定义好的返回出去使用<br>return customRef((track, trigger) =&gt; &#123;<br>// 语法要求 返回一个对象<br>return &#123;<br>get() &#123;<br>track()// 通知 vue 追踪数据(value)变化<br>return value<br>&#125;,<br>set(newValue) &#123;<br>clearTimeout(timer)<br>setTimeout(() =&gt; &#123;<br>value = newValue<br>trigger()// 通知 vue 重新解析模板<br>&#125;, delay);<br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br>// let keyWord = ref(&#x27;hello&#x27;)// vue 内置的 ref<br>let keyWord = myRef(&#x27;hello&#x27;)// 自定义 ref<br>return &#123;keyWord&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h4><img src="/2022/07/01/vue3/image-20220708143202180.png" class="" title="image-20220708143202180"><ul><li><p>作用：实现<strong>祖先与后代组件间通信</strong></p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>......<br>    <span class="hljs-keyword">let</span> car = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;奔驰&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-string">&#x27;40万&#x27;</span>&#125;)<br>    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;car&#x27;</span>,car)<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params">props,context</span>)&#123;<br>......<br>    <span class="hljs-keyword">const</span> car = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;car&#x27;</span>)<br>    <span class="hljs-keyword">return</span> &#123;car&#125;<br>......<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul><h4 id="响应式数据的判断"><a href="#响应式数据的判断" class="headerlink" title="响应式数据的判断"></a>响应式数据的判断</h4><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h2 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h2><h3 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h3><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><img src="/2022/07/01/vue3/f84e4e2c02424d9a99862ade0a2e4114tplv-k3u1fbpfcp-watermark.image" class="" title="img"><img src="/2022/07/01/vue3/e5ac7e20d1784887a826f6360768a368tplv-k3u1fbpfcp-watermark.image" class="" title="img"><h3 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h3><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><img src="/2022/07/01/vue3/bc0be8211fc54b6c941c036791ba4efetplv-k3u1fbpfcp-watermark-165726304478210.image" class="" title="img"><img src="/2022/07/01/vue3/6cc55165c0e34069a75fe36f8712eb80tplv-k3u1fbpfcp-watermark-165726305601013.image" class="" title="img"><h2 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h2><h3 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h3><ul><li>在Vue2中: 组件必须有一个根标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;h3&gt;App组件&lt;/h3&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ul><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个 <strong>Fragment 虚拟元素</strong>中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;h3&gt;App组件&lt;/h3&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ul><li>好处: 减少标签层级, 减小内存占用</li></ul><h3 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h3><ul><li><p>什么是Teleport</p><p>Teleport是一种能够<strong>将组件的html结构移动到指定位置</strong>的技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;teleport to=&quot;移动位置&quot;&gt;<br>&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;<br>&lt;div class=&quot;dialog&quot;&gt;<br>&lt;h3&gt;我是一个弹窗&lt;/h3&gt;<br>&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/teleport&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h3><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p><p>静态引入需等所有组件全部引入完毕，一起显示（木桶原理），异步引入（动态引入）则可以先显示引入好的组件</p><p>但是用户并不知道页面是否还有组件没有加载完毕，而且组件加载完毕后突然出现，效果并不好。可以使用 Suspense 包裹，底层通过插槽实现。</p><ul><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;defineAsyncComponent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;app&quot;&gt;<br>&lt;h3&gt;我是App组件&lt;/h3&gt;<br>&lt;Suspense&gt;<br>&lt;template v-slot:default&gt;<br>&lt;Child/&gt;<br>&lt;/template&gt;<br>&lt;template v-slot:fallback&gt;<br>&lt;h3&gt;加载中.....&lt;/h3&gt;<br>&lt;/template&gt;<br>&lt;/Suspense&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h3><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//注册全局组件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyButton&#x27;</span>, &#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;),<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">//注册全局指令</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-attr">inserted</span>: <span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-title function_">focus</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h3 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h3><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.v-enter</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.v-leave</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.v-enter-from</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.v-leave-from</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;my-component<br>  v-on:close=&quot;handleComponentEvent&quot;<br>  v-on:click=&quot;handleNativeClickEvent&quot;<br>/&gt;<br></code></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    emits: [&#x27;close&#x27;]// 不声明 click 说明是原生事件<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul><h2 id="一些重要操作"><a href="#一些重要操作" class="headerlink" title="一些重要操作"></a>一些重要操作</h2><h3 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a><a href="https://blog.csdn.net/m0_50789696/article/details/125168752">全局事件总线</a></h3><p>Vue3从实例中移除了 $on、$off 和 $once 方法，所以我们如果希望继续使用全局事件总线，要通过第三方的库：<br>Vue3官方有推荐一些库，例如 mitt </p><h4 id="1-安装-mitt"><a href="#1-安装-mitt" class="headerlink" title="1.安装 mitt"></a>1.安装 mitt</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> mitt<br></code></pre></td></tr></table></figure><h4 id="2-两种使用方式"><a href="#2-两种使用方式" class="headerlink" title="2.两种使用方式"></a><a href="https://www.bilibili.com/read/cv15580240/">2.两种使用方式</a></h4><h5 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h5><p>挂载到 app 上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> bus = <span class="hljs-title function_">mitt</span>()<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br>app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$bus</span> = bus<br>app.<span class="hljs-title function_">use</span>(store).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 兄弟组件 bro1 --&gt;<br>&lt;script&gt;<br>    import &#123;getCurrentInstance&#125; from &#x27;vue&#x27;;<br>    export default &#123;<br>        setup(props) &#123;<br>            const ins=getCurrentInstance()<br>            const bus=ins.appContext.config.globalProperties.$bus<br>            function passE()&#123;<br>          // 触发事件<br>                bus.emit(&#x27;bro&#x27;,&#x27;xwl&#x27;)<br>            &#125;<br>            return &#123;<br>                passE<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br><br>&lt;!-- 兄弟组件 bro2 --&gt;<br>&lt;script&gt;<br>    import &#123;getCurrentInstance&#125; from &#x27;vue&#x27;;<br>    export default &#123;<br>        setup(props) &#123;<br>            const ins=getCurrentInstance()<br>            const bus=ins.appContext.config.globalProperties.$bus<br>            onMounted(()=&gt;&#123;<br>                // 绑定事件<br>                bus.on(&#x27;bro&#x27;,(value)=&gt;&#123;<br>                    console.log(value);<br>                &#125;)<br>            &#125;)<br>            return &#123; &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="局部引入"><a href="#局部引入" class="headerlink" title="局部引入"></a>局部引入</h5><p>不与 vue 建立连接</p><ol><li><strong>封装 eventBus.js，可以放在 utils 下面</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> mitt <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mitt&#x27;</span>;<br><br><span class="hljs-keyword">const</span> emitter = <span class="hljs-title function_">mitt</span>();<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> emitter<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>使用</strong></li></ol><p><strong>导入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils/eventbus&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>触发事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;event&quot;</span>, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;);<br></code></pre></td></tr></table></figure><p><strong>监听事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;event&quot;</span>, <span class="hljs-function">(<span class="hljs-params">info</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;event:&quot;</span>, info)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>移除事件监听</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">emitter.<span class="hljs-property">all</span>.<span class="hljs-title function_">clear</span>()<br></code></pre></td></tr></table></figure><p><strong>指定监听移除</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onEvent</span>(<span class="hljs-params"></span>)&#123;&#125;<br>emitter.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;event&quot;</span>, onEvent);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm nvm nrm</title>
    <link href="/2022/06/30/npm-nvm-nrm/"/>
    <url>/2022/06/30/npm-nvm-nrm/</url>
    
    <content type="html"><![CDATA[<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>Node Package Manager</p><p>NodeJS包管理和分发工具</p><p><strong>npm 规定在项目根目录中必须提供一个 package.json 包管理配置文件，记录与项目相关的配置信息</strong>，如：</p><p>项目的名称、版本号、描述等</p><p>项目中用到了哪些包</p><p>哪些包只会在开发期间使用</p><p>哪些包在开发和部署时都会使用</p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a><strong>常用指令</strong></h3><h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 默认为 当前文件夹安装 最新版本 写入package.json的dependencies(-S)<br>npm install XXX<br><br><span class="hljs-regexp">//</span> 安装指定版本<br>npm install xxx@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 全局安装<br>npm install -g<br><br><span class="hljs-regexp">//</span> 写入package.json的devDependencies中<br>npm install –D xxx<br></code></pre></td></tr></table></figure><h4 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 卸载<br>npm uninstall XXX<br><br><span class="hljs-regexp">//</span> 卸载并在 package.json 中移除<br>npm uninstall -S XXX<br>npm uninstall -D XXX<br><br><span class="hljs-regexp">//</span> 卸载全局依赖<br>npm uninstall -g XXX<br></code></pre></td></tr></table></figure><h4 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 检查更新<br>npm outdated<br><br><span class="hljs-regexp">//</span> 执行更新<br>npm update<br></code></pre></td></tr></table></figure><h4 id="查看包"><a href="#查看包" class="headerlink" title="查看包"></a>查看包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 查看全局安装的包<br>npm list -g --depth <span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 查看某个包的版本<br>npm list vue-cli<br></code></pre></td></tr></table></figure><h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>Node Version Management</p><p>管理 node 版本的工具，通过它可以安装和切换不同版本的 node.js</p><p>不同的项目需要不同的 node 版本</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><p><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><h3 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a><strong>常用指令</strong></h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 本地 node 版本<br>nvm list<br><br><span class="hljs-regexp">//</span> 官方 node 版本<br>nvm list available<br><br><span class="hljs-regexp">//</span> 安装<br>nvm install <span class="hljs-number">18.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 卸载<br>nvm uninstall <span class="hljs-number">18.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 切换当前版本<br>nvm use <span class="hljs-number">18.2</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>npm registry manager</p><p>npm 的镜像源管理工具</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 全局安装<br>npm install -g nrm<br></code></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 查看所有源<br>nrm ls<br><br><span class="hljs-regexp">//</span> 添加源 nrm add &lt;registry&gt; &lt;url&gt;<br>nrm add baidu www.baidu.com<br><br><span class="hljs-regexp">//</span> 切换源<br>nrm use taobao<br><br><span class="hljs-regexp">//</span> 删除源<br>nrm use taobao<br><br><span class="hljs-regexp">//</span> 测试源相应时长<br>nrm test taobao<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>包管理工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vite</title>
    <link href="/2022/06/30/Vite/"/>
    <url>/2022/06/30/Vite/</url>
    
    <content type="html"><![CDATA[<h1 id="Vite（未完）"><a href="#Vite（未完）" class="headerlink" title="Vite（未完）"></a>Vite（未完）</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://vitejs.cn/guide/why.html#the-problems">官方文档</a></p><h2 id="Vite的优势"><a href="#Vite的优势" class="headerlink" title="Vite的优势"></a>Vite的优势</h2><h3 id="更快的服务器启动"><a href="#更快的服务器启动" class="headerlink" title="更快的服务器启动"></a><strong>更快的服务器启动</strong></h3><p>Vite 通过在一开始将应用中的模块区分为 <strong>依赖</strong> 和 <strong>源码</strong> 两类，改进了开发服务器启动时间</p><p><strong>依赖</strong> 大多为在开发时不会变动的纯 JavaScript。</p><p>Vite 将会使用 **<a href="https://esbuild.github.io/">esbuild</a> <a href="https://vitejs.cn/guide/dep-pre-bundling.html">预构建依赖</a>**。Esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。</p><p><strong>源码</strong> 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue&#x2F;Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。</p><p>Vite 以 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules"><strong>原生 ESM</strong></a> 方式提供源码。这实际上是<strong>让浏览器接管了打包程序的部分工作</strong>：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景<strong>动态导入</strong>代码，即只在当前屏幕上实际使用时才会被处理。</p><h3 id="更快的更新"><a href="#更快的更新" class="headerlink" title="更快的更新"></a>更快的更新</h3><p>轻量快速的 HMR</p><p>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。</p><h3 id="传统构建与-vite-构建对比图"><a href="#传统构建与-vite-构建对比图" class="headerlink" title="传统构建与 vite 构建对比图"></a>传统构建与 vite 构建对比图</h3><p>一次全部打包</p><img src="/2022/06/30/Vite/bundler.37740380.png" class="" title="基于打包器的开发服务器"><p>按需动态引入</p><img src="/2022/06/30/Vite/esm.3070012d.png" class="" title="基于 ESM 的开发服务器"><h2 id="快速搭建一个项目"><a href="#快速搭建一个项目" class="headerlink" title="快速搭建一个项目"></a>快速搭建一个项目</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>初始化<br><span class="hljs-regexp">//</span> yarn create vite<br><span class="hljs-built_in">npm</span> init vite@latest<br><br><span class="hljs-number">2.</span>进入文件夹后安装依赖包<br><span class="hljs-built_in">npm</span> install<br><br><span class="hljs-number">3.</span>启动()<br><span class="hljs-built_in">npm</span> run dev<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json 命令解析</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 启动开发服务器，别名：`vite dev`，`vite serve`</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite build&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 为生产环境构建产物</span><br>    <span class="hljs-attr">&quot;preview&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite preview&quot;</span> <span class="hljs-comment">// 本地预览生产构建产物</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>项目目录</p><img src="/2022/06/30/Vite/image-20220701002419270.png" class="" title="image-20220701002419270"><p>public 下放无需编译的静态资源（图片 &#x2F; js）</p><p>assets 放可被编译的静态资源（图片 -&gt; base64）</p><p>components 公共组件</p>]]></content>
    
    
    <categories>
      
      <category>vite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pinia</title>
    <link href="/2022/06/28/pinia/"/>
    <url>/2022/06/28/pinia/</url>
    
    <content type="html"><![CDATA[<h1 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是-pinia"><a href="#什么是-pinia" class="headerlink" title="什么是 pinia"></a>什么是 pinia</h3><p>Vue 的状态管理库，会逐渐取代 Vuex</p><h3 id="pinia-的优势"><a href="#pinia-的优势" class="headerlink" title="pinia 的优势"></a>pinia 的优势</h3><p>1.完全支持 ts</p><p>2.移除了 mutations，actions 同时支持同步和异步</p><p>3.轻量 压缩后体积只有 1kb 左右</p><p>4.没有模块嵌套，只有 store，每一个 store 都是独立的</p><p>5.store 一旦创建便会自动添加，无需手动添加 store</p><p>6.支持 vue2 与 vue3</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="安装-pinia"><a href="#安装-pinia" class="headerlink" title="安装 pinia"></a>安装 pinia</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install pinia <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="创建-store"><a href="#创建-store" class="headerlink" title="创建 store"></a>创建 store</h3><p>新建 src&#x2F;store 目录并在其下面创建 index.ts，导出 store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/store/index.ts</span><br><span class="hljs-keyword">import</span> &#123;createPinia&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createPinia</span>()<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br></code></pre></td></tr></table></figure><p>vue3 是 createPinia </p><p>vue2 是 PiniaVuePlugin</p><p>在 main.ts 中引入并使用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/main.ts</span><br><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123;createPinia&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createPinia</span>()<br><span class="hljs-keyword">let</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br>app.<span class="hljs-title function_">use</span>(store)<br><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="定义-store"><a href="#定义-store" class="headerlink" title="定义 store"></a>定义 store</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//src/store/index.ts</span><br><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTestStore = <span class="hljs-title function_">defineStore</span>(&#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-comment">// id必填，唯一值(可以理解成命名空间)</span><br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// vuex中的state是对象, pinia中是箭头函数返回对象</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;lwj&#x27;</span>,<br>            <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;23&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">getters</span>: &#123;<br><br>    &#125;,<br>    <span class="hljs-attr">actions</span>: &#123;<br><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src/App.vue --&gt;<br>&lt;template&gt;<br>    &lt;div&gt;<br>        &#123;&#123;Test.name&#125;&#125;--&#123;&#123;Test.age&#125;&#125;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>    import &#123;useTestStore&#125; from &#x27;./store/index&#x27;<br>    const Test = useTestStore()<br>&lt;/script&gt;<br><br>&lt;style scoped&gt; <br>    <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><h4 id="修改-state-的五种方法"><a href="#修改-state-的五种方法" class="headerlink" title="修改 state 的五种方法"></a>修改 state 的五种方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src/App.vue --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &#123;&#123;Test.name&#125;&#125;--&#123;&#123;Test.age&#125;&#125;<br>    &lt;button @click=&quot;change1&quot;&gt;直接修改(修改一个)&lt;/button&gt;<br>    &lt;button @click=&quot;change2&quot;&gt;$patch对象写法(批量修改)&lt;/button&gt;<br>    &lt;button @click=&quot;change3&quot;&gt;$patch函数写法(可增加逻辑)&lt;/button&gt;<br>    &lt;button @click=&quot;change4&quot;&gt;$state(不常用 必须覆盖整个对象)&lt;/button&gt;<br>    &lt;button @click=&quot;change5&quot;&gt;actions&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>  import &#123;useTestStore&#125; from &#x27;./store/index&#x27;<br>  const Test = useTestStore()<br><br>  const change1 = () =&gt; &#123;<br>    Test.age++<br>  &#125;<br><br>  const change2 = () =&gt; &#123;<br>    Test.$patch(&#123;<br>      name: &#x27;lwjjj&#x27;,<br>      age: 24<br>    &#125;)<br>  &#125;<br><br>  const change3 = () =&gt; &#123;<br>    Test.$patch((state) =&gt; &#123;<br>      state.name = &#x27;lwjjjjjj&#x27;,<br>      state.age = 30<br>    &#125;)<br>  &#125;<br><br>  const change4 = () =&gt; &#123;<br>    Test.$state = &#123;<br>      name: &#x27;lwjjjjjjjj&#x27;,<br>      age: 50<br>    &#125;<br>  &#125;<br><br>  const change5 = () =&gt; &#123;<br>    Test.setCurrent(80)<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt; <br>  <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 方法五需要在 src/store/index.ts 中配置 actions</span><br><span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">setCurrent</span>(<span class="hljs-params">num:<span class="hljs-built_in">number</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;lwjjjjjjjjjjj&#x27;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = num<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;origin value &#123;&#123;Test.name&#125;&#125;--&#123;&#123;Test.age&#125;&#125;&#125;&lt;/div&gt;<br>  &lt;div&gt;<br>    &#123;&#123;Test.name&#125;&#125;--&#123;&#123;Test.age&#125;&#125;<br>    &lt;button @click=&quot;change&quot;&gt;change&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>  import &#123;useTestStore&#125; from &#x27;./store/index&#x27;<br>  import &#123; storeToRefs &#125; from &#x27;pinia&#x27;;<br>  const Test = useTestStore()<br><br>  // pinia 解构不具有响应式(直接解构的话修改数据要.value，可以使用 storeToRefs 解决)<br>  const &#123;name, age&#125; = storeToRefs(Test)<br><br>  const change = () =&gt; &#123;<br>    Test.age++<br>    console.log(name, age)<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt; <br>  <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="actions-和-getters"><a href="#actions-和-getters" class="headerlink" title="actions 和 getters"></a>actions 和 getters</h3><p>使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/store/index.ts</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Login</span> = (): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">User</span>&gt; =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(&#123;<br>                <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;vincent&#x27;</span>,<br>                <span class="hljs-attr">age</span>: <span class="hljs-number">99</span><br>            &#125;)<br>        &#125;, <span class="hljs-number">2000</span>);<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTestStore = <span class="hljs-title function_">defineStore</span>(&#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-comment">// id必填，唯一值(可以理解成命名空间)</span><br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// vuex中的state是对象, pinia中是箭头函数返回对象</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">user</span>: &lt;<span class="hljs-title class_">User</span>&gt;&#123;&#125;,<br>            <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;male&quot;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">getters</span>: &#123;<br>        <span class="hljs-title function_">newName</span>():<span class="hljs-built_in">string</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">`$~<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.sex&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.getUserAge&#125;</span>`</span><br>        &#125;,<br>        <span class="hljs-title function_">getUserAge</span>():<span class="hljs-built_in">number</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">age</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">actions</span>: &#123;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">setUser</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Login</span>()<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = result<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;female&#x27;</span>)<br>        &#125;,<br>        setName (<span class="hljs-attr">sex</span>:<span class="hljs-built_in">string</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="store-上的一些方法"><a href="#store-上的一些方法" class="headerlink" title="store 上的一些方法"></a>store 上的一些方法</h3><p><strong>$reset</strong></p><p>重置 store 到他的初始状态</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">reset</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title class_">Test</span>.$reset()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>$subscribe</strong></p><p>state 发生改变时触发</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Test</span>.$subscribe(<span class="hljs-function">(<span class="hljs-params">args, state</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state)<br>&#125;)<br></code></pre></td></tr></table></figure><p>args</p><img src="/2022/06/28/pinia/image-20220708230746204.png" class="" title="image-20220708230746204"><p>state</p><img src="/2022/06/28/pinia/image-20220708230807891.png" class="" title="image-20220708230807891"><p><strong>$onAction</strong></p><p>监听 action 变化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Test</span>.$onAction(<span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;)<br></code></pre></td></tr></table></figure><p>args</p><img src="/2022/06/28/pinia/image-20220708231241529.png" class="" title="image-20220708231241529"><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>pinia 和 vuex 的通病：页面刷新状态会丢失（初始化）</p><p>写一个 pinia 插件缓存值（通过 localStorage)</p><p><strong>写页面</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- App.vue --&gt;<br>&lt;template&gt;<br>  &lt;p&gt;&#123;&#123;Test.user&#125;&#125;&lt;/p&gt;<br>  &lt;hr&gt;<br>  &lt;p&gt;&#123;&#123;Base.baseCurrent&#125;&#125;&lt;/p&gt;<br>  &lt;hr&gt;<br>  &lt;button @click=&quot;changeTest&quot;&gt;changeTest&lt;/button&gt;<br>  &lt;button @click=&quot;changeBase&quot;&gt;changeBase&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>  import &#123;useTestStore, useStore&#125; from &#x27;./store/index&#x27;<br><br>  const Test = useTestStore()<br>  const Base = useStore()<br><br>  const changeTest = () =&gt; &#123;<br>    Test.user.name = &#x27;lwjjjjjjjjjjjjjjjjjjjjjjjjj&#x27;<br>    Test.user.age = 100<br>  &#125;<br><br>  const changeBase = () =&gt; &#123;<br>    Base.baseCurrent += 1<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt; <br>  <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>写数据</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// ./src/index.ts</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTestStore = <span class="hljs-title function_">defineStore</span>(&#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-comment">// id必填，唯一值(可以理解成命名空间)</span><br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// vuex中的state是对象, pinia中是箭头函数返回对象</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">user</span>: &lt;<span class="hljs-title class_">User</span>&gt;&#123;&#125;,<br>            <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;male&quot;</span><br>        &#125;<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">defineStore</span>(&#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;base&#x27;</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">baseCurrent</span>: <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>写插件（逻辑）</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">import</span> &#123; createApp, toRaw &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123;createPinia, <span class="hljs-title class_">PiniaPluginContext</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Options</span> = &#123;<br>    key?:<span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">__piniaKey__</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;xiaoman&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setStorage</span> = (<span class="hljs-params">key:<span class="hljs-built_in">string</span>, value:<span class="hljs-built_in">any</span></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value))<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getStorage</span> = (<span class="hljs-params">key:<span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key) ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key) <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>) : &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">piniaPlugin</span> = (<span class="hljs-params">options:Options</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">context:PiniaPluginContext</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123;store&#125; = context<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">getStorage</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;options?.key ?? __piniaKey__&#125;</span>-<span class="hljs-subst">$&#123;store.$id&#125;</span>`</span>)<br>        store.$subscribe(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">setStorage</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;options?.key ?? __piniaKey__&#125;</span>-<span class="hljs-subst">$&#123;store.$id&#125;</span>`</span>, <span class="hljs-title function_">toRaw</span>(store.<span class="hljs-property">$state</span>))<br>        &#125;)<br>        <span class="hljs-keyword">return</span> &#123;<br>            ...data<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createPinia</span>()<br><br>store.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">piniaPlugin</span>(&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;pinia&quot;</span><br>&#125;))<br><br><span class="hljs-keyword">let</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br>app.<span class="hljs-title function_">use</span>(store)<br><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>状态管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量提升与函数提升</title>
    <link href="/2022/06/27/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/"/>
    <url>/2022/06/27/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<h1 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h1><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>只有var定义的变量才会被提升</p><p>只提升声明，不提升赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a= <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//  &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>只提升函数声明式，不提升函数字面量式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//函数声明式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span> () &#123;&#125;<br><span class="hljs-comment">//函数字面量式 </span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>会整体提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getName</span>()<span class="hljs-comment">// 小明</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;小明&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.后面覆盖前面</p><p>2.如果变量和函数同名，提升的是函数</p><p>3.变量提升会区分作用域</p><h2 id="一道经典题目"><a href="#一道经典题目" class="headerlink" title="一道经典题目"></a>一道经典题目</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br><span class="hljs-title function_">a</span>();<br><span class="hljs-keyword">var</span> a=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span> ()&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>a=<span class="hljs-number">6</span>;<br><span class="hljs-title function_">a</span>()<br><br><span class="hljs-comment">//输出结果：function a () &#123;console.log()&#125;  10 3  TypeError </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端性能优化</title>
    <link href="/2022/06/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/06/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="前端性能优化的手段"><a href="#前端性能优化的手段" class="headerlink" title="前端性能优化的手段"></a>前端性能优化的手段</h2><h3 id="减少-http-请求"><a href="#减少-http-请求" class="headerlink" title="减少 http 请求"></a>减少 http 请求</h3><ol><li>base64 处理图片</li><li>减少重定向</li><li>使用缓存</li><li>不使用 css 的 @import</li></ol><h3 id="减少资源太小-压缩"><a href="#减少资源太小-压缩" class="headerlink" title="减少资源太小(压缩)"></a>减少资源太小(压缩)</h3><ol><li><strong>webpack</strong></li></ol><p>压缩 htmlHtmlWebpackPlugin 配置 minify</p><p>压缩 css   optimize-css-assets-webpack-plugin</p><p>压缩 js  mode: ‘production’(自动使用 terser-webpack-plugin)</p><ol start="2"><li><strong>开启 gzip 编码</strong></li></ol><p>开发模式下：webpack-dev-server 配置 compress: true</p><p>生产模式下：服务端配置，如 express 使用 compression 中间件</p><h3 id="优化网络连接"><a href="#优化网络连接" class="headerlink" title="优化网络连接"></a>优化网络连接</h3><ol><li><strong>内容分发网络 CDN</strong></li></ol><p>根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上</p><ol start="2"><li><strong>DNS 预解析</strong></li></ol><p>DNS 预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度</p><p>方法是在 head 标签里面写上几个 link 标签</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;dns-prefecth&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;https://www.google.com&quot;</span>&gt;<br>&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;dns-prefecth&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;https://www.google-analytics.com&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间</p><h3 id="优化资源加载"><a href="#优化资源加载" class="headerlink" title="优化资源加载"></a>优化资源加载</h3><ol><li><strong>资源加载位置</strong></li></ol><p>通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用</p><p>CSS文件放在head中</p><p>JS文件放在body底部，或者使用 defer&#x2F;async</p><ol start="2"><li><strong>资源加载时机</strong></li></ol><p>按需加载</p><p>懒加载与预加载</p><h3 id="减少重绘回流"><a href="#减少重绘回流" class="headerlink" title="减少重绘回流"></a>减少重绘回流</h3><ol><li><p>避免使用层级较深的选择器</p></li><li><p>防抖节流</p></li><li><p>DocumentFragment</p></li></ol><p>让DOM操作发生在内存中，而不是页面上；可以实现离线更新</p><ol start="4"><li>事件代理</li><li>动画 GPU 加速</li></ol><h3 id="性能更好的API"><a href="#性能更好的API" class="headerlink" title="性能更好的API"></a>性能更好的API</h3><ol><li>requestAnimationFrame来替代setTimeout和setInterval</li><li>使用IntersectionObserver来实现图片可视区域的懒加载</li></ol><h3 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h3><ol><li><p>treeshaking 去除无用代码</p></li><li><p>文件缓存</p></li></ol><p>hash chunkhash contenthash</p>]]></content>
    
    
    <categories>
      
      <category>优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块化</title>
    <link href="/2022/06/22/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2022/06/22/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起；</p><p>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>避免命名冲突、避免全局变量污染</p><p>便于代码编写和维护</p><h2 id="早期的模块化"><a href="#早期的模块化" class="headerlink" title="早期的模块化"></a>早期的模块化</h2><p>立即执行函数</p><p>通过函数作用域解决了命名冲突、污染全局的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-comment">// 在这里面声明各种变量、函数都不会污染全局作用域</span><br>&#125;)(a)<br></code></pre></td></tr></table></figure><h2 id="模块化方案"><a href="#模块化方案" class="headerlink" title="模块化方案"></a>模块化方案</h2><h3 id="1、CommonJS"><a href="#1、CommonJS" class="headerlink" title="1、CommonJS"></a>1、CommonJS</h3><p>①在node环境下使用，不支持浏览器环境<br>②NodeJS遵循的规范<br>③使用require()进行引入依赖<br>④使用exports进行暴露模块</p><h3 id="2、AMD"><a href="#2、AMD" class="headerlink" title="2、AMD"></a>2、AMD</h3><p>①浏览器环境下的异步加载模块<br>②RequireJS遵循的规范<br>③依赖于require.js模块管理工具库<br>④AMD 推崇依赖前置</p><h3 id="3、CMD"><a href="#3、CMD" class="headerlink" title="3、CMD"></a>3、CMD</h3><p>①浏览器环境下，同时支持异步和同步加载<br>②SeaJS遵循的规范<br>③CMD 推崇依赖就近</p><h3 id="4、ES6-module"><a href="#4、ES6-module" class="headerlink" title="4、ES6 module"></a>4、ES6 module</h3><p>ES6模块化语法在编译时就能确定模块的依赖关系，还能确定好输入输出的变量声明，已经不仅仅是模块规范，现在已经作为JS语言的标准语法使用，有以下特性：</p><p>①浏览器环境、<a href="https://www.yisu.com/">服务器</a>环境都支持<br>②编译时就能确定模块的依赖关系及变量，其他模块规范都是在运行时确定的<br>③export命令用于规定模块的对外接口<br>④import命令用于输入其他模块提供的功能</p><h3 id="CommonJs和ES6-module的区别"><a href="#CommonJs和ES6-module的区别" class="headerlink" title="CommonJs和ES6 module的区别"></a>CommonJs和ES6 module的区别</h3><p><strong>CommonJS</strong> 是一种模块规范，最初被应用于 <strong>Nodejs</strong>，成为 Nodejs 的模块规范。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br><span class="hljs-comment">// 导出</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = 导出的值<br></code></pre></td></tr></table></figure><p>运行在<strong>浏览器</strong>端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: <strong>AMD</strong>)，用来对前端模块进行管理。</p><p>自 ES6 起，引入了一套新的 <strong>ES6 Module 规范</strong>，在语言标准的层面上实现了模块功能，而且实现得相当简单，<strong>有望成为浏览器和服务器通用的模块解决方案</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;模块路径&quot;</span><br><span class="hljs-keyword">import</span> &#123;a,b&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;模块路径&quot;</span><br><span class="hljs-keyword">import</span> c <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;模块路径&quot;</span><span class="hljs-comment">//默认导入</span><br><br><br><span class="hljs-comment">// 导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">b</span> = (<span class="hljs-params"></span>)=&gt;&#123;&#125;<br><span class="hljs-comment">//默认导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">xx</span>:yy,<br><span class="hljs-attr">aa</span>:bb<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>但目前浏览器对 ES6 Module <strong>兼容还不太好</strong>，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。</p><p>在**<a href="https://blog.csdn.net/qq_45890970/article/details/123541700?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123541700-blog-123954229.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=3">使用上的差别</a>**主要有：</p><p><strong>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong>（一旦输出一个值，模块内部的变化就影响不到这个值）</p><p><strong>CommonJS 是同步加载模块，ES6 是异步加载模块。</strong>（主要用于服务器编程，模块文件一般都已经存在于本地，加载起来比较快）</p><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p><p>CommonJs 是单个值导出，ES6 Module可以导出多个</p><p>CommonJs 是<strong>动态语法可以写在判断里</strong>，ES6 Module <strong>静态语法只能写在顶层</strong></p><p>CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.yisu.com/zixun/452499.html">https://www.yisu.com/zixun/452499.html</a></p><p><a href="https://blog.csdn.net/weixin_39690316/article/details/122946850">https://blog.csdn.net/weixin_39690316/article/details/122946850</a></p><p><a href="https://blog.csdn.net/qq_45890970/article/details/123541700?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123541700-blog-123954229.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/qq_45890970/article/details/123541700?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123541700-blog-123954229.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>模块化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AJAX</title>
    <link href="/2022/06/21/AJAX/"/>
    <url>/2022/06/21/AJAX/</url>
    
    <content type="html"><![CDATA[<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Asynchronous JavaScript And XML（异步的 JS 和 XML）</p><p>AJAX 是在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页。（<strong>无刷新获取数据</strong>）</p><h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点：</strong></p><ol><li><p>无需刷新页面与服务端通信</p></li><li><p>允许根据用户事件来更新部分页面内容</p></li></ol><p><strong>缺点：</strong></p><ol><li>没有浏览历史、不能回退</li><li>存在跨域问题</li><li>不易SEO</li></ol><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>传统Ajax 指的是 XMLHttpRequest（XHR），最早出现的向后端发送请求的技术，隶属于原始 js 中</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h4><ul><li>创建对象 （XMLHttpRequest 对象）</li><li>请求 （将请求发送到服务器，使用 XMLHttpRequest 对象的 open() 和 send() 方法）</li><li>响应 （获得来自服务器的响应，使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性）</li><li>根据XMLHttpRequest的readyState判定调用哪个回调函数 （onreadystatechange 事件）</li><li>更新页面</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 请求成功回调函数</span><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request success&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 请求结束回调函数</span><br>xhr.<span class="hljs-property">onloadend</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request loadend&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 请求出错回调函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request error&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 请求超时回调函数</span><br>xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request timeout&#x27;</span>);<br>&#125;;<br><br>xhr.<span class="hljs-property">timeout</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 设置超时时间,0表示永不超时</span><br><span class="hljs-comment">// 初始化请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET/POST/DELETE/...&#x27;</span>, <span class="hljs-string">&#x27;/url&#x27;</span>, <span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 设置期望的返回数据类型 &#x27;json&#x27; &#x27;text&#x27; &#x27;document&#x27; ...</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-comment">// 设置请求头</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-comment">// 发送请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span> || <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span> || <span class="hljs-string">&#x27;a=1&amp;b=2&#x27;</span> || <span class="hljs-string">&#x27;json字符串&#x27;</span>);<br><br><span class="hljs-comment">// 请求回调函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> === <span class="hljs-number">304</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request success&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request error&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 取消请求</span><br>xhr.<span class="hljs-title function_">abort</span>()<br></code></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>浏览器通过 XMLHttpRequest 对象进行 http 通信，多个请求之间如果有先后关系的话，就会出现 <a href="https://www.cnblogs.com/bala/p/11650296.html#callback-hell"><strong>回调地狱</strong></a></p><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>fetch 号称是 AJAX 的替代品，是在 ES6 出现的，使用了ES6 中的 promise 对象。Fetch 是基于 promise 设计的。</p><p><strong>fetch 不是 ajax的进一步封装，而是原生 JS ， 没有使用 XMLHttpRequest 对象。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 一个简单的fetch 请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/movies.json&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)&#123;<br>        <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>()<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">myJson</span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myJson) <br>    &#125;)<br><br><br><span class="hljs-comment">// 一个带有参数的fetch请求</span><br><span class="hljs-title function_">postData</span>(<span class="hljs-string">&#x27;http://example.com/answer&#x27;</span>,&#123;<span class="hljs-attr">answer</span>: <span class="hljs-number">42</span>&#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))  <span class="hljs-comment">// JSON from &#x27;response.json()&#x27; call</span><br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error))<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">postData</span>(<span class="hljs-params">url, data</span>) &#123;<br>  <span class="hljs-comment">// Default options are marked with *</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>       <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data),  <span class="hljs-comment">// must match &#x27;Content-Type&#x27; header</span><br>       <span class="hljs-attr">cache</span>: <span class="hljs-string">&#x27;no-cache&#x27;</span>,  <span class="hljs-comment">// * default, no-cache, reload, force-cache, only-if-cached</span><br>        <span class="hljs-attr">headers</span>: &#123;<br>            <span class="hljs-string">&#x27;user-agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/4.0 MDN Example&#x27;</span>,<br>             <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>        &#125;,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-comment">// *GET, POST, PUT, DELETE, etc.</span><br>        <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;cors&#x27;</span>, <span class="hljs-comment">// no-cors, cors, *same-origin</span><br>        <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;follow&#x27;</span>, <span class="hljs-comment">// manual, *follow, error</span><br>        <span class="hljs-attr">referrer</span>: <span class="hljs-string">&#x27;no-referrer&#x27;</span>, <span class="hljs-comment">// *client, no-referrer    </span><br>  &#125;)    <br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>()) <span class="hljs-comment">// parses response to JSON</span><br></code></pre></td></tr></table></figure><p>fetch 的优点：</p><p>　　1、语法简洁，更加语义化</p><p>　　2、基于标准 Promise 实现，支持 async &#x2F; await</p><p>　　3、同构方便，使用<code>[isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)</code></p><p>　　4、更加底层，提供的 API 丰富 （request， response）</p><p>　　5、脱离了 XHR，是 ES 规范中新的实现方式。</p><p>缺点：</p><p>　　1、fetch 只对网络请求报错，对400,500都当作成功的请求，服务器返回400， 500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时， fetch 才会被 reject。需要封装去处理。</p><p>　　2、fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</p><p>　　3、**<a href="https://www.cnblogs.com/bala/p/11650296.html#abort-controller">fetch 不支持 abort</a>** （xhr 有个 xhr.abort 方法可以直接阻断请求），不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求，请求过程继续在后台运行，造成了流量的浪费。</p><p>　　4、fetch 没有办法原生监测请求的进度，而 XHR 可以。</p><p>　　5、fetch 兼容性并不太好，IE 不支持</p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios 是一个基于 <a href="https://www.cnblogs.com/bala/p/11650296.html#promise">Promise</a> 的 http请求库，可以用在浏览器和 node.js 中，本质上也是<strong>对原生XHR的封装</strong>，只不过它是Promise 的实现版本，符合最新的ES规则。是目前最常用的请求方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 配置 baseURL</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;http://localhost:8000&#x27;</span>;<br><br><span class="hljs-comment">// GET 请求</span><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/axios-server&#x27;</span>, &#123;<br>    <span class="hljs-comment">// url 参数</span><br>    <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-number">100</span>,<br>        <span class="hljs-attr">vip</span>: <span class="hljs-number">7</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 请求头信息</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;atguigu&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error) <br>&#125;)<br><br><span class="hljs-comment">// POST 请求</span><br>axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/axios-server&#x27;</span>, &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>&#125;, &#123;<br>    <span class="hljs-comment">// url</span><br>    <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-attr">vip</span>: <span class="hljs-number">9</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 请求头参数</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">height</span>: <span class="hljs-number">180</span>,<br>        <span class="hljs-attr">weight</span>: <span class="hljs-number">180</span>,<br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error) <br>&#125;)<br><br><span class="hljs-comment">// 通用</span><br><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-comment">// 请求方法</span><br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-comment">//url</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/axios-server&#x27;</span>,<br>    <span class="hljs-comment">// url参数</span><br>    <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">vip</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">level</span>: <span class="hljs-number">30</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 头信息</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">a</span>: <span class="hljs-number">100</span>,<br>        <span class="hljs-attr">b</span>: <span class="hljs-number">200</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 请求体参数</span><br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>        <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>    <span class="hljs-comment">// 响应状态码</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">status</span>);<br>    <span class="hljs-comment">// 响应状态字符串</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">statusText</span>);<br>    <span class="hljs-comment">// 响应头信息</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">headers</span>);<br>    <span class="hljs-comment">// 响应体</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error) <br>&#125;)<br><br><span class="hljs-comment">// 利用 async await</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/axios-server&#x27;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)                   <br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)  <br>    &#125;  <br></code></pre></td></tr></table></figure><p>axios 的特征：</p><p>　　1、从浏览器中创建XMLHttpRequest</p><p>　　<strong>2、支持 Promise API，不会产生回调地狱的问题</strong></p><p>　　<strong>3、客户端支持防止 CSRF</strong></p><p>　　4、提供了一些**<a href="https://www.cnblogs.com/bala/p/11650296.html#concurrent">并发</a>**请求的接口（重要，方便了很多的操作）</p><p>　　5、从 node.js 创建 http 请求</p><p>　　<strong>6、拦截请求和响应</strong></p><p>　　7、转换请求和响应数据</p><p>　　8、取消请求</p><p>　　9、自动转换JSON数据</p><h3 id="xhr-封装-axios"><a href="#xhr-封装-axios" class="headerlink" title="xhr 封装 axios"></a>xhr 封装 axios</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">axios</span>(<span class="hljs-params">method, url, data</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>        xhr.<span class="hljs-title function_">open</span>(method, url)<br>        xhr.<span class="hljs-title function_">send</span>(data)<br>        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">response</span>))<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>                       <br><span class="hljs-comment">// 调用</span><br><span class="hljs-title function_">axios</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;接口地址&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)  <br></code></pre></td></tr></table></figure><h3 id="如何终止-http-请求"><a href="#如何终止-http-请求" class="headerlink" title="如何终止 http 请求"></a><a href="https://www.jianshu.com/p/a7d367dd270b">如何终止 http 请求</a></h3><p><strong>XMLHttpRequest</strong></p><p><strong>abort()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ajax = <span class="hljs-title class_">XMLHttpRequest</span><br>ajax.<span class="hljs-title function_">open</span>()<br>ajax.<span class="hljs-title function_">send</span>()<br>ajax.<span class="hljs-property">onreadystateChange</span> = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br><br><span class="hljs-comment">// 终止请求</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    ajax.<span class="hljs-title function_">abort</span>()<br>&#125;, <span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure><p><strong>fetch</strong></p><p>fetch需要配合<a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController"><strong>AbortController</strong></a>实例来完成请求的取消</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br><span class="hljs-keyword">let</span> signal = controller.<span class="hljs-property">signal</span>;<br><br><span class="hljs-keyword">const</span> downloadBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.download&#x27;</span>);<br><span class="hljs-keyword">const</span> abortBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.abort&#x27;</span>);<br><br>downloadBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, fetchVideo);<br><br>abortBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  controller.<span class="hljs-title function_">abort</span>();<span class="hljs-comment">// 终止请求</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Download aborted&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchVideo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-title function_">fetch</span>(url, &#123;signal&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    reports.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;Download error: &#x27;</span> + e.<span class="hljs-property">message</span>;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>axios</strong></p><p> 跟fetch有点像，使用CancelToken.source创建一个 <strong>cancel token</strong> 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cancelToken = axios.<span class="hljs-property">CancelToken</span><br><span class="hljs-keyword">const</span> source = cancelToken.<span class="hljs-title function_">source</span>()<br>axios.<span class="hljs-title function_">get</span>(url, &#123;<br>    <span class="hljs-attr">cancelToken</span>: source.<span class="hljs-property">token</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br><br><span class="hljs-comment">// 终止请求</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    source.<span class="hljs-title function_">cancel</span>()<br>&#125;, <span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>AJAX</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueRouter</title>
    <link href="/2022/06/18/VueRouter/"/>
    <url>/2022/06/18/VueRouter/</url>
    
    <content type="html"><![CDATA[<h1 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h1><p>路由，vue是单页面应用，通过组件来显示不同的视图，路由就是通过设定路径来控制组件的显示与隐藏，实现页面的跳转与切换。</p><p>一个路由就是一个键值对，键是路径，值是组件。</p><h3 id="VueRouter的作用"><a href="#VueRouter的作用" class="headerlink" title="VueRouter的作用"></a>VueRouter的作用</h3><p>vue的核心概念之一：页面组件化、SPA。</p><p>由于vue是单页面应用，且每个功能模块都可以封装为组件，因此不可能和多页面应用一样直接通过超链接跳转，换句话说只有一个html，还能跳转到哪儿去？那如何让vue可以在一个页面中如何切换不同的组件？<br>这也是vue-router要解决的根本目的：让SPA像多页面应用一样实现跳转。</p><h3 id="vue-router钩子函数"><a href="#vue-router钩子函数" class="headerlink" title="vue-router钩子函数"></a>vue-router钩子函数</h3><p>全局的：beforeEach、beforeResolve、afterEach<br>路由的：beforeEnter<br>组件的：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave<br>参数：to、from、next；正对不同的钩子函数参数有所差异。</p><p>除了afterEach全局后置外，其他的守卫中务必要调用next(),否则无法完成导航<br>还有注意全局前置守卫可以用来进行拦截（登录拦截）</p><h3 id="route和router有什么区别"><a href="#route和router有什么区别" class="headerlink" title="route和router有什么区别"></a><a href="https://www.cnblogs.com/itgezhu/p/12177288.html">route和router有什么区别</a></h3><p><strong>route：代表当前路由信息对象，可以获取到当前路由的信息参数</strong></p><p>$route.fullPath ：完成解析后的url，包含查询参数和hash的完整路径</p><p>$route.path：路径，字符串类型，解析为绝对路径</p><p>$route.hash： 当前路由的hash值（带#号的），如果没有hash值则为空字符串</p><p>$route.name：当前路由的名称，如果有的话（用于命名路由）</p><p>$route.params：一个键值对对象，路由参数</p><p>$route.query：一个键值对对象，表示url查询参数</p><p>$route.matched：一个包含了当前路由的所有嵌套路径片段的路由记录（routes配置数组中的对象副本）</p><p>$route.redirectedFrom：重定向来源的路由的名字，如果存在重定向的话。</p><p><strong>router：代表路由实例的对象，包含了路由的跳转方法，钩子函数等</strong></p><p>属性：</p><p>$router.app ：配置了router的Vue根实例</p><p>$router.mode：路由模式，这里是hash</p><p>$router.currentRoute：当前路由的路由信息对象，包含了当前匹配路由的信息</p><p>方法：</p><p>守卫：router.afterEach()</p><p>路由跳转：router.push( location )router.replace( location )</p><h3 id="路由之间如何跳转"><a href="#路由之间如何跳转" class="headerlink" title="路由之间如何跳转"></a>路由之间如何跳转</h3><p>组件导航<br>router-link router-view</p><p>编程导航<br>router.push<br>router.replace<br>router.go</p><h3 id="vue-router完整的导航解析流程"><a href="#vue-router完整的导航解析流程" class="headerlink" title="vue-router完整的导航解析流程"></a>vue-router完整的导航解析流程</h3><p>1.导航被触发；</p><p>2.在失活的组件里调用beforeRouteLeave守卫；</p><p>3.调用全局beforeEach守卫；</p><p>4.在复用组件里调用beforeRouteUpdate守卫；</p><p>5.调用路由配置里的beforeEnter守卫；</p><p>6.解析异步路由组件；</p><p>7.在被激活的组件里调用beforeRouteEnter守卫；</p><p>8.调用全局beforeResolve守卫；</p><p>9.导航被确认；</p><p>10.调用全局的afterEach钩子；</p><p>11.DOM更新；</p><p>12.用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数。</p><h3 id="从零开始写一个vue路由"><a href="#从零开始写一个vue路由" class="headerlink" title="从零开始写一个vue路由"></a>从零开始写一个vue路由</h3><ol><li>为了方便后期维护，建议独立出一个 router.js 文件</li><li>npm install vue-router</li><li>引入注册</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li>向外暴露出一个router实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    ...<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>动态导入，需要跳转到要用的页面的时候在对该页面进行加载</p><p>1.vue的异步组件：resolve&#x3D;&gt;require([‘需要异步加载的组件’]，resolve)</p><p><strong>2.es6的import方法：</strong></p><p>利用 <strong>箭头函数 和 import</strong> 来实现动态加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 将 import UserDetails from &#x27;./views/UserDetails&#x27; 替换成</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">UserDetails</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./views/UserDetails&#x27;</span>)<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">routes</span>: [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserDetails</span> &#125;],<br>&#125;)<br></code></pre></td></tr></table></figure><p>3.webpack的 require.ensure： r &#x3D;&gt; require.ensure([],()&#x3D;&gt;r( require(需要异步加载的组件))，chunkName)</p><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>在用户访问一个特定的地址时,将其重定向到另一个指定的地址 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/goback&#x27;</span>,<br><span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h3><p>active-class是vue-router模块的router-link组件中的属性，用来做选中样式的切换；</p><h3 id="如何获取路由传过来的参数？"><a href="#如何获取路由传过来的参数？" class="headerlink" title="如何获取路由传过来的参数？"></a><a href="https://github.com/haizlin/fe-interview/issues/379#">如何获取路由传过来的参数？</a></h3><p>如果使用<code>query</code>方式传入的参数使用<code>this.$route.query</code> 接收<br>如果使用<code>params</code>方式传入的参数使用<code>this.$route.params</code>接收</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p>vue-router插件的其中一个组件, 用于跳转路由, 类似于a标签, 它一般也会渲染成a标签, 但是可以通过<code>tag</code>来变更默认渲染元素, 通过<code>to</code>来跳转</p><h3 id="路由有几种模式"><a href="#路由有几种模式" class="headerlink" title="路由有几种模式"></a>路由有几种模式</h3><p>路由配置时，设置 mode，默认为 hash</p><p>前端路由实现的本质是<strong>监听 url 变化</strong>，实现方式有两种：<strong>Hash 模式和 History 模式</strong>，<strong>无需刷新页面就能重新加载相应的页面</strong>。</p><p>Hash url 的格式为<code>www.a.com/#/</code>，当#后的哈希值发生变化时，通过 <strong>hashchange</strong> 事件监听，然后页面跳转。</p><p>History url 通过<code>history.pushState</code>和<code>history.replaceState</code>改变 url。 </p><p>两种模式的区别：</p><ul><li>hash 只能改变#后的值，而 history 模式可以随意设置同源 url；</li><li>hash 只能添加字符串类的数据，而 history 可以通过 API 添加多种类型的数据；</li><li>hash 的历史记录只显示之前的<code>www.a.com</code>而不会显示 hash 值，而 history 的每条记录都会进入到历史记录；</li><li>hash 无需后端配置且兼容性好，而 history 需要配置<code>index.html</code>用于匹配不到资源的情况。</li></ul><h3 id="vue-router怎么配置404页面？"><a href="#vue-router怎么配置404页面？" class="headerlink" title="vue-router怎么配置404页面？"></a>vue-router怎么配置404页面？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123; <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>, <span class="hljs-attr">routes</span>: [ &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">NotFoundComponent</span> &#125; ] &#125;)<br></code></pre></td></tr></table></figure><p>path: ‘*’  注意要放在最后</p><p>*代表全匹配 你放在第一个 不管地址是什么都会 匹配到了 放在最后一个 前面有的就不会匹配到</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收</title>
    <link href="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="为什么需要垃圾回收"><a href="#为什么需要垃圾回收" class="headerlink" title="为什么需要垃圾回收"></a>为什么需要垃圾回收</h2><p>V8引擎已经帮我们自动进行了内存的分配和管理，JS 不需要手动开辟和释放内存。</p><p>存在写代码的过程中不够严谨而容易引发内存泄漏的问题</p><h2 id="V8引擎的内存限制"><a href="#V8引擎的内存限制" class="headerlink" title="V8引擎的内存限制"></a>V8引擎的内存限制</h2><p>JS 是单线程，垃圾回收的过程阻碍了主线程逻辑的执行。会导致主线程的等待时间长，浏览器长时间得不到响应。</p><p>V8引擎直接粗暴的限制了堆内存的大小。在浏览器端一般也不会遇到需要操作几个G内存这样的场景。在node端我们可以手动调整。</p><h2 id="经典垃圾回收策略"><a href="#经典垃圾回收策略" class="headerlink" title="经典垃圾回收策略"></a>经典垃圾回收策略</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数会跟踪每个值被引用的次数，当引用数为0时变量，内存就会被释放。因为存在<strong>循环引用</strong>的问题，所以很少使用这种方法。</p><p>在代码运行时就会自动的增减，因此效率高。</p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>第一个阶段是标记，也就是找垃圾的过程，从根节点出发遍历对象，对所有访问过的对象打上标记，表示对象可达。第二阶段是清除，对那些没有标记的对象进行回收。以下几种情况都可以作为根节点：</p><ol><li>全局对象</li><li>本地函数的局部变量和参数</li><li>当前嵌套调用链上的其他函数的变量和参数</li></ol><p>因为需要暂停下来遍历对象，所以效率相对较低。</p><h2 id="V8的垃圾回收策略"><a href="#V8的垃圾回收策略" class="headerlink" title="V8的垃圾回收策略"></a>V8的垃圾回收策略</h2><h3 id="V8的内存结构"><a href="#V8的内存结构" class="headerlink" title="V8的内存结构"></a>V8的内存结构</h3><p><code>新生代(new_space)</code>：<strong>大多数的对象</strong>（如执行上下文）开始都会被分配在这里，这个<strong>区域相对较小</strong>但是<strong>垃圾回收特别频繁</strong>，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。</p><p><code>老生代(old_space)</code>：<strong>新生代中的对象在存活一段时间后就会被转移到老生代内存区</strong>（如全局变量、自定义类、函数等），相对于新生代该内存区域的垃圾回收频率较低。老生代又分为<code>老生代指针区</code>和<code>老生代数据区</code>，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。</p><p><code>大对象区(large_object_space)</code>：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。</p><p><code>代码区(code_space)</code>：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。</p><p><code>map区(map_space)</code>：存放Cell和Map，每个区域都是存放相同大小的元素，结构简单(这里没有做具体深入的了解，有清楚的小伙伴儿还麻烦解释下)。</p><img src="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/16ee12280b78399dtplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp" class="" title="1620974853612-a480b43e-b3bb-452f-a502-3a0162548a7f"><p>上图中的带斜纹的区域代表暂未使用的内存，新生代(new_space)被划分为了两个部分，其中一部分叫做inactive new space，表示暂未激活的内存区域，另一部分为激活状态。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新生代的垃圾回收过程中主要采用了**<code>Scavenge</code>**算法。</p><p><code>Scavenge</code>算法是一种典型的牺牲空间换取时间的算法，对于老生代内存来说，可能会存储大量对象，如果在老生代中使用这种算法，势必会造成内存资源的浪费，但是在新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。</p><p>在<code>Scavenge</code>算法的具体实现中，主要采用了<code>Cheney</code>算法，它将新生代内存一分为二，每一个部分的空间称为<code>semispace</code>，也就是我们在上图中看见的new_space中划分的两个区域，其中处于激活状态的区域我们称为<code>From</code>空间，未激活(inactive new space)的区域我们称为<code>To</code>空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到<code>From</code>空间，当进行垃圾回收时，如果<code>From</code>空间中尚有存活对象，则会被复制到<code>To</code>空间进行保存，非存活的对象会被自动回收。当复制完成后，<code>From</code>空间和<code>To</code>空间完成一次角色互换，<code>To</code>空间会变为新的<code>From</code>空间，原来的<code>From</code>空间则变为<code>To</code>空间。</p><p><code>Scavenge</code>算法的垃圾回收过程主要就是将存活对象在<code>From</code>空间和<code>To</code>空间之间进行复制，同时完成两个空间之间的角色互换，因此该算法的缺点也比较明显，浪费了一半的内存用于复制。</p><h3 id="对象晋升"><a href="#对象晋升" class="headerlink" title="对象晋升"></a>对象晋升</h3><p>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时（在将对象从<code>From</code>空间复制到<code>To</code>空间之前），该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为<code>晋升</code>。<br> 对象晋升的条件主要有以下两个（满足任意一个则会晋升）：</p><ul><li>对象是否经历过一次<code>Scavenge</code>算法</li><li><code>To</code>空间的内存占比是否已经超过<code>25%</code></li></ul><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><p>在老生代中，因为管理着大量的存活对象，如果依旧使用<code>Scavenge</code>算法的话，很明显会浪费一半的内存，因此已经不再使用<code>Scavenge</code>算法，而是采用新的算法**<code>Mark-Sweep(标记清除)</code>和<code>Mark-Compact(标记整理)</code>**来进行管理。</p><p>标记清除的问题是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现<strong>内存碎片</strong>的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。</p><p>为了解决这种内存碎片的问题，<code>Mark-Compact(标记整理)</code>算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，<strong>回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存</strong>。</p><h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><p>全停顿 <img src="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/153329224-c2120a5d-4f25-4659-9347-d6217d5a5ce8.png" class="" title="1620974853612-a480b43e-b3bb-452f-a502-3a0162548a7f"></p><p>增量标记 <img src="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/153329251-e6a21086-f646-48d5-a23c-c2e3351497ef.png" class="" title="1620975019709-efc33748-fbfc-4fb5-a19d-97abadbf8f97"></p><p>为了减少垃圾回收带来的停顿时间，V8引擎又引入了<strong>Incremental Marking(增量标记)<strong>的概念，即将</strong>原本需要一次性遍历堆内存的操作改为增量标记的方式</strong>，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p><p>得益于增量标记的好处，V8引擎后续继续引入了<strong>延迟清理(lazy sweeping)<strong>和</strong>增量式整理(incremental compaction)<strong>，让清理和整理的过程也变成增量式的。同时为了充分利用多核CPU的性能，也将引入</strong>并行标记</strong>和<strong>并行清理</strong>，进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。</p><h2 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h2><ol><li><strong>尽可能少地创建全局变量</strong></li></ol><p>会无形地挂载到<code>window</code>全局对象上，变成根节点，必须要将其设置为 null 才能回收</p><ol start="2"><li><p><strong>记得手动清除定时器</strong></p></li><li><p><strong>少使用闭包</strong></p></li><li><p><strong>使用弱引用</strong></p></li></ol><p>WeakMap, WeakSet</p><p>弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904016325902344#heading-2">https://juejin.cn/post/6844904016325902344#heading-2</a></p><p><a href="https://www.bilibili.com/video/BV1bP4y1u7GF?spm_id_from=333.337.search-card.all.click&amp;vd_source=1616b746cefe2e7615c229563ba38eb4">https://www.bilibili.com/video/BV1bP4y1u7GF?spm_id_from=333.337.search-card.all.click&amp;vd_source=1616b746cefe2e7615c229563ba38eb4</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>垃圾回收</tag>
      
      <tag>V8引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON</title>
    <link href="/2022/06/17/JSON/"/>
    <url>/2022/06/17/JSON/</url>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h2><p>是一种数据格式，之所以需要这样一种数据格式，是因为前后端的编程语言不同，数据的表示形式也不同，所以需要有这样一种格式来作为桥梁传递数据。</p><h2 id="JSON-和-JS-对象的区别"><a href="#JSON-和-JS-对象的区别" class="headerlink" title="JSON 和 JS 对象的区别"></a>JSON 和 JS 对象的区别</h2><p>JSON和JS有相同的语法，JSON和JS对象也非常的像，但还是有一定区别的，JSON的要求更多一些，区别在于：</p><img src="/2022/06/17/JSON/image-20220701002710162.png" class="" title="image-20220701002710162"><p>在我们前端向后端发送数据时，需要将JS对象转换为一个JSON字符串，可以通过JSON.stringify()这个JS方法来实现，并且提供了一些参数来对转换过程做一些处理。相反，我们收到的后端的数据也是JSON格式，我们需要通过JSON.parse()来将其转化为JS对象之后再使用。</p><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value[, replacer [, space]])<br><span class="hljs-comment">// value: 将要序列化成一个 JSON 字符串的值</span><br></code></pre></td></tr></table></figure><ul><li><strong>转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。</strong></li><li>非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。</li><li>布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。</li><li><strong><code>undefined</code>、任意的函数以及 symbol 值，在序列化过程中会被忽略</strong>（出现在非数组对象的属性值中时）或者被转换成 <code>null</code>（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如<code>JSON.stringify(function()&#123;&#125;)</code> or <code>JSON.stringify(undefined)</code>.</li><li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</li><li>所有以 symbol 为属性键的属性都会被完全忽略掉，即便 <code>replacer</code> 参数中强制指定包含了它们。</li><li>Date 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理。</li><li><strong>NaN 和 Infinity 格式的数值及 null 都会被当做 null。</strong></li><li>其他类型的对象，包括 Map&#x2F;Set&#x2F;WeakMap&#x2F;WeakSet，仅会序列化可枚举的属性。</li></ul><h2 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> oldJson = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">const</span> newJson = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(oldJson));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>terser是如何压缩js代码的</title>
    <link href="/2022/06/17/terser%E6%98%AF%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9js%E4%BB%A3%E7%A0%81%E7%9A%84/"/>
    <url>/2022/06/17/terser%E6%98%AF%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9js%E4%BB%A3%E7%A0%81%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="js代码压缩整体策略"><a href="#js代码压缩整体策略" class="headerlink" title="js代码压缩整体策略"></a>js代码压缩整体策略</h2><p>通过 AST 分析，根据选项配置一些策略，来<strong>生成一颗更小体积的 AST</strong> 并生成代码。</p><h2 id="压缩-AST-的方式"><a href="#压缩-AST-的方式" class="headerlink" title="压缩 AST 的方式"></a>压缩 AST 的方式</h2><p>目前前端工程化中使用 <a href="https://terser.org/docs/api-reference#compress-options">terser</a>和 <a href="https://swc.rs/docs/configuration/minification">swc</a>进行 JS 代码压缩，他们拥有相同的 API。</p><p>常见用以压缩 AST 的几种方案如下:</p><ol><li><strong>去除多余字符: 空格，换行及注释</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (a, b) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span> a+b&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>压缩变量名：变量名，函数名及属性名</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (first, second) &#123;<br>  <span class="hljs-keyword">return</span> first + second;  <br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (x, y) &#123;<br>  <span class="hljs-keyword">return</span> x + y;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>合并声明以及布尔值简化</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>编译预计算</strong></li></ol><p><strong>数学</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ONE_YEAR</span> = <span class="hljs-number">365</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span><br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ONE_YAAR</span> = <span class="hljs-number">31536000</span><br></code></pre></td></tr></table></figure><p><strong>函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span> () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello, world&#x27;</span>)<br>&#125;<br><br><span class="hljs-title function_">hello</span>()<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello, world&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="在-webpack-中开启-js-代码压缩"><a href="#在-webpack-中开启-js-代码压缩" class="headerlink" title="在 webpack 中开启 js 代码压缩"></a>在 webpack 中开启 js 代码压缩</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">mode:</span> <span class="hljs-comment">&#x27;production&#x27;</span><br></code></pre></td></tr></table></figure><p>生产环境会自动压缩 js 代码（会自动使用一些插件，如terser-webpack-plugin）</p><p><code>terser-webpack-plugin</code> 内部封装了 <a href="https://link.zhihu.com/?target=https://github.com/terser/terser">terser</a> 库，用于处理 js 的压缩和混淆，通过 <code>webpack plugin</code> 的方式对代码进行处理</p>]]></content>
    
    
    <categories>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>terser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="/2022/06/14/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/06/14/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="对象的深拷贝与浅拷贝"><a href="#对象的深拷贝与浅拷贝" class="headerlink" title="对象的深拷贝与浅拷贝"></a>对象的深拷贝与浅拷贝</h2><h3 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝"></a>什么是浅拷贝</h3><p><strong>只拷贝了数据对象的第一层，深层次的数据值与原始数据会互相影响（拷贝后的数据与原始数据还存有关联）</strong></p><p>常见浅拷贝的方式：Object.assign()、扩展运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-attr">info</span>: &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> &#125; &#125;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj1)<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1 &#125;<br><br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;cat&#x27;</span><br>obj2.<span class="hljs-property">info</span>.<span class="hljs-property">age</span> = <span class="hljs-number">4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1) <span class="hljs-comment">// &#123; name: &#x27;dog&#x27;, info: &#123; age: 4 &#125; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2) <span class="hljs-comment">// &#123; name: &#x27;cat&#x27;, info: &#123; age: 4 &#125; &#125;</span><br></code></pre></td></tr></table></figure><h3 id="什么是深拷贝"><a href="#什么是深拷贝" class="headerlink" title="什么是深拷贝"></a>什么是深拷贝</h3><p><strong>不管数据对象有多少层，改变拷贝后的值都不会影响原始数据的值。（拷贝后的数据与原始数据毫无关系）</strong></p><p>常见深拷贝的方式：JSON.parse()  和  JSON.stringify()  配合使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-attr">info</span>: &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> &#125;, <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125; &#125;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1))<br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;cat&#x27;</span><br>obj2.<span class="hljs-property">info</span>.<span class="hljs-property">age</span> = <span class="hljs-number">4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1) <span class="hljs-comment">// &#123; name: &#x27;dog&#x27;, info: &#123; age: 3 &#125;, fn: function()&#123;&#125; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2) <span class="hljs-comment">// &#123; name: &#x27;cat&#x27;, info: &#123; age: 4 &#125; &#125;</span><br></code></pre></td></tr></table></figure><p>浅拷贝可以使用  Object.assign 或者<strong>遍历赋值</strong>的方式手动实现。</p><p>深拷贝可以通过JSON.stringify() 与 JSON.parse()实现，但对于对象有要求，因为在遇到函数，undefined，Sybmol，Date对象时会自动忽略，遇到正则时会返回空对象。也可以通过<strong>递归</strong>的方式手动实现深拷贝。</p><h3 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h3><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p><strong>Object.assign()</strong> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历赋值"><a href="#遍历赋值" class="headerlink" title="遍历赋值"></a>遍历赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br>    <br>    <span class="hljs-comment">// Object.keys不会遍历到原型链中的属性</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) &#123;<span class="hljs-comment">// for of 遍历元素值</span><br>cloneObj[key] = obj[key]<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br><br><br><span class="hljs-keyword">let</span> c1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>: &#123;<br>        <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>,<br>        <span class="hljs-attr">e</span>: <span class="hljs-number">5</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> d1 = <span class="hljs-title function_">clone</span>(c1)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c1, d1)<br><br>c1.<span class="hljs-property">c</span>.<span class="hljs-property">d</span> = <span class="hljs-number">12</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c1, d1)<br></code></pre></td></tr></table></figure><h3 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a><a href="https://juejin.cn/post/7072528644739956773#heading-15">深拷贝的实现</a></h3><h4 id="JSON-stringify-与-JSON-parse"><a href="#JSON-stringify-与-JSON-parse" class="headerlink" title="JSON.stringify() 与 JSON.parse()"></a>JSON.stringify() 与 JSON.parse()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><a href="https://juejin.cn/post/7113829141392130078">问题：</a></strong></p><ol><li>对象中的时间类型会被变成字符串类型数据</li><li>对象中的 undefined 和 函数类型会直接丢失</li><li>对象中的 NaN、Infinity、-Infinity 会变成 null</li><li>对象循环引用时会报错</li></ol><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h5 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-comment">// 处理 null date reg 原始类型</span><br>    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj)<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> obj<br><br>    <span class="hljs-comment">// 处理对象和数组</span><br>    <span class="hljs-keyword">const</span> cloneObj = <span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)      <span class="hljs-comment">// 根据对象和数组自动生成</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) &#123;<br>        cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key])<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="稍微复杂版"><a href="#稍微复杂版" class="headerlink" title="稍微复杂版"></a>稍微复杂版</h5><ol><li>解决 symbol 无法作为键的问题</li></ol><p>Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组 等于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</p><ol start="2"><li>解决循环引用问题</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>&#125;<br>obj.<span class="hljs-property">b</span> = obj<br><br><span class="hljs-keyword">const</span> newObj = <span class="hljs-title function_">deepClone</span>(obj)<br></code></pre></td></tr></table></figure><p>报错：栈内存溢出，死循环了。</p><p>因为在递归遍历obj的属性时，obj有属性指向自身，因此会无限循环。</p><p>开辟新内存记录出现过的 obj，如果已经出现过就不再遍历，直接返回。</p><ol start="3"><li>解决垃圾回收问题</li></ol><p>使用 WeakMap，WeakMap是弱引用，不影响垃圾回收（WeakMap键指向的对象的其它引用被清除后，该对象会被垃圾回收）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>    <span class="hljs-comment">// 处理 null date reg 原始类型</span><br>    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj)<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> obj<br><br>    <span class="hljs-comment">// 解决循环引用问题</span><br>    <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj)             <span class="hljs-comment">// 说明 obj 在属性中出现过，再去遍历就会造成循环引用，因此直接返回hash中的记录</span><br><br>    <span class="hljs-comment">// 处理对象和数组</span><br>    <span class="hljs-keyword">const</span> cloneObj = <span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)      <span class="hljs-comment">// 根据对象和数组自动生成</span><br><br>    hash.<span class="hljs-title function_">set</span>(obj, cloneObj)                     <span class="hljs-comment">// 记录出现过的 obj</span><br><br>    <span class="hljs-comment">// Reflect.ownKeys 解决 Symbol 无法作为键的问题</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash)<br>    &#125;)<br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="日常开发"><a href="#日常开发" class="headerlink" title="日常开发"></a>日常开发</h3><p>日常开发中，如果要使用深拷贝，为了兼容各种边界情况，一般是使用三方库如 lodash</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-built_in">npm</span> i --save lodash<br><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span><br><span class="hljs-keyword">const</span> cloneObj = _.cloneDeep(obj)<br></code></pre></td></tr></table></figure><h3 id="structuredClone"><a href="#structuredClone" class="headerlink" title="structuredClone()"></a><a href="https://blog.csdn.net/songjungang/article/details/125373543">structuredClone()</a></h3><p>一个新的深拷贝API，ES 的一部分，目前兼容性还不够好。chrome &gt;&#x3D; 98才支持。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">structuredClone</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span><br></code></pre></td></tr></table></figure><p>这个函数有第二个参数 transferables，这个参数很少有用。详细信息，请参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone">MDN 页面structuredClone()</a></p><p><strong>缺陷：</strong></p><ol><li><strong>一些内置对象不能被复制，structuredClone()会抛出DOMException</strong></li></ol><p>Functions (ordinary functions, arrow functions, classes, methods)</p><p>DOM 节点DOM nodes</p><ol start="2"><li><strong>structuredClone()不会复制对象的原型链</strong></li></ol><p>如果structuredClone()与类实例一起使用，将获得一个普通对象作为返回值，因为结构化克隆会丢弃对象的原型链。</p><ol start="3"><li><strong>structuredClone()并不能复制DOM节点<a href="https://exploringjs.com/deep-js/ch_property-attributes-intro.html">特性属性</a>：</strong></li></ol><p>访问器 get 变成了数据属性。</p><p>在副本中，特性属性始终具有默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>深拷贝与浅拷贝</tag>
      
      <tag>手撕代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两栏布局/圣杯布局/双飞翼布局</title>
    <link href="/2022/06/11/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <url>/2022/06/11/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h1><p>HTML 结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-浮动-margin-left"><a href="#1-浮动-margin-left" class="headerlink" title="1.浮动 + margin-left"></a>1.浮动 + margin-left</h2><ol><li>左边元素宽度固定 ，设置浮动。右元素设置 <code>margin-left</code> 。因为右边元素的 <code>width</code> 默认为 <code>auto</code> ，所以会自动撑满父元素。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-绝对定位-margin-left"><a href="#2-绝对定位-margin-left" class="headerlink" title="2.绝对定位 + margin-left"></a>2.绝对定位 + margin-left</h2><p>绝对定位和浮动是一样的都是为了让左元素脱离标准流</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">position</span>: absolute;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-绝对定位-left"><a href="#3-绝对定位-left" class="headerlink" title="3.绝对定位 + left"></a>3.绝对定位 + left</h2><p>与上面不同在于，给右元素浮动定位，设置 left top right bottom（不可省略）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-flex"><a href="#4-flex" class="headerlink" title="4.flex"></a>4.flex</h2><p>左边元素固定宽度，右边的元素设置 <code>flex: 1</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h1><img src="/2022/06/11/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/image-20220122135020616.png" class="" title="image-20220122135020616"><h2 id="float-相对定位"><a href="#float-相对定位" class="headerlink" title="float + 相对定位"></a>float + 相对定位</h2><p>步骤：</p><p>1.设置基本样式</p><p>2.设置父元素container的padding，空出左右元素的位置</p><p>3.设置三个子元素左浮动，清除浮动</p><p>4.设置center的width:100%，单独站一行。此时left和right被挤到第二行</p><p>5.设置left和right的margin-left，将left和right放回第一行</p><p>6.设置<strong>子元素的相对定位</strong>，将left和right移动到合适的位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>头部<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>主区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>底部<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span>, <span class="hljs-selector-tag">footer</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">color</span>: wheat;<br>    <span class="hljs-attribute">text-align</span>: center;     <span class="hljs-comment">/* 水平居中 */</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;           <span class="hljs-comment">/* 盒子高度 */</span><br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">60px</span>;      <span class="hljs-comment">/* line-height是行高; line-height = height 单行文字垂直居中 */</span><br>&#125;<br><br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.center</span>, <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;     <span class="hljs-comment">/* 相对定位，将左右盒子移动到正确的位置 */</span><br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">left</span>: -<span class="hljs-number">200px</span>;           <span class="hljs-comment">/* 将左盒子移动到最左侧 */</span><br>    <span class="hljs-attribute">background-color</span>: green;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;     <span class="hljs-comment">/* 第二行移动到第一行 */</span><br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<span class="hljs-comment">/* 中间能够自适应的原因 */</span><br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">right</span>: -<span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">300px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;   <span class="hljs-comment">/* 空出放左盒子和右盒子的空间(上右下左) */</span><br>&#125;<br><br><span class="hljs-comment">/* 清除浮动，不然container盒子高度会变0 */</span><br><span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>步骤：</p><p>1.设置基本样式</p><p>2.给父元素container设置display:flex。三个div子元素会排列到一行</p><p>3.给center设置flex:1。会分配所有剩余的空间（一行中去除左右盒子的部分，也就实现了自适应）</p><p>4.给left设置order:-1，将其排到最左侧。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span>, <span class="hljs-selector-tag">footer</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">color</span>: wheat;<br>    <span class="hljs-attribute">text-align</span>: center;     <span class="hljs-comment">/* 水平居中 */</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;           <span class="hljs-comment">/* 盒子高度 */</span><br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">60px</span>;      <span class="hljs-comment">/* line-height是行高; line-height = height 单行文字垂直居中 */</span><br>&#125;<br><br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.center</span>, <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;        <span class="hljs-comment">/* 分配所有剩余的空间 */</span><br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: green;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;      <span class="hljs-comment">/* 数值越小排列越前 */</span><br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h1><p>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决 “中间栏div内容不被遮挡”问题的思路不一样。圣杯布局是利用了相对定位。</p><p>而双飞翼布局没有给父盒子加padding，而是给中间子盒子里面的内容套了层div，再给div加padding，这样左右两个盒子就会自己在最左侧和最右侧，而不需要再定位过去了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>头部<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>主区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 包裹一层div --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>底部<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span>, <span class="hljs-selector-tag">footer</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">color</span>: wheat;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">60px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.center</span>, <span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-comment">/* 不需要相对定位了 */</span><br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: green;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.content</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">300px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;   <span class="hljs-comment">/* 不是父盒子padding，而是center内容的div加padding */</span><br>&#125;<br><br><span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2022/06/10/Promise/"/>
    <url>/2022/06/10/Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Promise 是 JS 中进行异步编程的新解决方案（旧方案是单纯使用回调函数）</p><p>从语法上来说: Promise 是一个<strong>构造函数</strong></p><p>从功能上来说: promise 对象用来<strong>封装一个异步操作并可以获取其成功&#x2F;失败的结果值</strong></p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>pending</p><p>resolved&#x2F;fulfilled</p><p>rejected</p><p>无论变为成功还是失败, 都会有一个结果数据</p><p>成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><img src="/2022/06/10/Promise/image-20220610202339657.png" class="" title="image-20220610202339657"><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li><p><strong>指定回调函数更加灵活</strong>，原先需要在异步任务前指定。如今异步任务在new时写入，成功&#x2F;失败回调在then中绑定</p></li><li><p>支持<strong>链式调用</strong>，解决<strong>回调地狱</strong>问题</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.创建一个Promise实例</span><br><span class="hljs-comment">//2.Promise构造函数接收一个函数作为参数，函数的两个参数分别是resolve和reject。它们均是函数</span><br><span class="hljs-keyword">const</span> promise=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>     <span class="hljs-keyword">if</span>(操作是否成功)&#123;<br>          <span class="hljs-title function_">resolve</span>(value)<br>          <span class="hljs-comment">//3.当异步操作成功时，调用resolve()。状态发生改变（pending-&gt;fulfilled），并将结果作为参数传递出去</span><br>     &#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-title function_">reject</span>(error)<br>         <span class="hljs-comment">//4.当异步操作失败是，调用reject()。状态发生改变（pending-&gt;rejected），并将错误作为参数传递出去</span><br>     &#125;<br>&#125;)<br><span class="hljs-comment">//5.可以使用then方法指定resolved状态和rejected状态的回调函数.then方法接收两个回调函数作为参数（这俩个函数都是可选的）</span><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-comment">//6.状态变为resolved(在这里统一只指`fulfilled`状态)时调用，可使用传出的value</span><br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;<br>   <span class="hljs-comment">// 7.状态变为rejected时调用，可使用传出的error</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="手写API"><a href="#手写API" class="headerlink" title="手写API"></a>手写API</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><ol><li>Promise.all()接受一个promise的iterable类型</li><li>只有数组中全部的 Promise 都变为 resolve 的时候，返回一个成果结果的数组</li><li>只要有一个失败，状态就变成 rejected，将失败的那个结果给失败状态的回调函数</li></ol><p><strong>使用例子</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 全部resolve, 输出数组</span><br><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);<br>&#125;);<br><span class="hljs-comment">// expected output: Array [3, 42, &quot;foo&quot;]</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<span class="hljs-params">values</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> results = [];<span class="hljs-comment">// 结果数组</span><br>        <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">processData</span> = (<span class="hljs-params">value, index</span>) =&gt; &#123;<br>            results[index] = value;<br>            <span class="hljs-comment">// 当成功的个数 和 当前的参数个数相等就把结果抛出去</span><br>            <span class="hljs-keyword">if</span>(++i === value.<span class="hljs-property">length</span>) &#123;<br>                <span class="hljs-title function_">resolve</span>(results);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = values[i]<br>            <span class="hljs-comment">// 判断是否为 promise</span><br>            <span class="hljs-keyword">if</span> (current <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                current.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> <span class="hljs-title function_">processData</span>(y, i), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">reject</span>(err))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">processData</span>(current, i)<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;one&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;two&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1, promise2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>  <span class="hljs-comment">// Both resolve, but promise2 is faster</span><br>&#125;);<br><span class="hljs-comment">// expected output: &quot;two&quot;</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(<span class="hljs-params">values</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = values[i]<br>            <span class="hljs-keyword">if</span> (current <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                current.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(res), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">reject</span>(err))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(current)<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>Promise.allSettled() 可用于并行执行独立的异步操作，并收集这些操作的结果。</p><p>该函数接受一个 promise 数组(通常是一个可迭代对象)作为参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> statusesPromise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises);<br></code></pre></td></tr></table></figure><p>当所有的输入 <code>promises</code> 都被 <code>fulfilled</code> 或 <code>rejected</code> 时，<code>statusesPromise</code> 会解析为一个具有它们状态的数组</p><ol><li><code>&#123; status: &#39;fulfilled&#39;, value: value &#125;</code> — 如果对应的 promise 已经 <code>fulfilled</code></li><li>或者 <code>&#123;status: &#39;rejected&#39;， reason: reason&#125;</code> 如果相应的 promise 已经被 <code>rejected</code></li></ol><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(reject, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>));<br><span class="hljs-keyword">const</span> promises = [promise1, promise2];<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises).<br>  <span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">status</span>)));<br><br><span class="hljs-comment">// expected output:</span><br><span class="hljs-comment">// &quot;fulfilled&quot;</span><br><span class="hljs-comment">// &quot;rejected&quot;</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(<span class="hljs-params">values</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> res = []<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">addData</span> = (<span class="hljs-params">status, value, i</span>) =&gt; &#123;<br>            res[i] = &#123;<br>                status,<br>                value<br>            &#125;<br>            count++<br>            <span class="hljs-keyword">if</span> (count === values.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(res)<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = values[i]<br>            <span class="hljs-keyword">if</span> (current <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                current.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, res, i), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>, err, i))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, current, i)<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><ul><li>如果有一个Promise成功，则返回这个成功结果</li><li>如果所有Promise都失败，则报错</li></ul><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);<br>&#125;);<br><span class="hljs-comment">// expected output: Array [3, 42, &quot;foo&quot;]</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>(<span class="hljs-params">values</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = values[i]<br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(val), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                count++<br>                <span class="hljs-keyword">if</span> (count === values.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>))<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-控制并发数"><a href="#Promise-控制并发数" class="headerlink" title="Promise 控制并发数"></a>Promise 控制并发数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// values 是数组</span><br><span class="hljs-comment">// iteratorFn 是每个 promise 需要执行的异步操作。</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncPool</span>(<span class="hljs-params">values, limit, iteratorFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = []          <span class="hljs-comment">// 存放所有 promise 实例</span><br>    <span class="hljs-keyword">const</span> executing = []    <span class="hljs-comment">// 存放目前正在执行的 promise</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> values) &#123;<br>        <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">iteratorFn</span>(item))     <span class="hljs-comment">// 异步操作应当返回 promise, 包裹一层 Promise.resolve 避免返回的不是 promise</span><br>        res.<span class="hljs-title function_">push</span>(p)<br>        <span class="hljs-keyword">if</span> (limit &lt;= values.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">const</span> e = p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> executing.<span class="hljs-title function_">splice</span>(executing.<span class="hljs-title function_">indexOf</span>(e), <span class="hljs-number">1</span>))   <span class="hljs-comment">// 当这个promise状态变为fulfilled后，将其从正在执行的promise列表executing中删除</span><br>            executing.<span class="hljs-title function_">push</span>(e)<br>            <span class="hljs-keyword">if</span> (executing.<span class="hljs-property">length</span> &gt;= limit) &#123;<br>                <span class="hljs-comment">// 一旦正在执行的promise列表数量等于限制数，就使用Promise.race等待某一个promise状态发生变更，</span><br>                <span class="hljs-comment">// 状态变更后，就会执行上面then的回调，将该promise从executing中删除，</span><br>                <span class="hljs-comment">// 然后再进入到下一次for循环，生成新的promise进行补充</span><br>                <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(executing)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(res)<br>&#125;<br><br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">timeout</span> = (<span class="hljs-params">i</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;开始&#x27;</span>, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(i);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;结束&#x27;</span>, i);<br>    &#125;, i));<br>&#125;;<br><br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncPool</span>(<span class="hljs-number">2</span>, [<span class="hljs-number">1000</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">2000</span>], timeout);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异步编程</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入URL后浏览器发生了什么变化</title>
    <link href="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/"/>
    <url>/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="输入-url-后浏览器发生了什么变化"><a href="#输入-url-后浏览器发生了什么变化" class="headerlink" title="输入 url 后浏览器发生了什么变化"></a>输入 url 后浏览器发生了什么变化</h1><h2 id="步骤简单总结"><a href="#步骤简单总结" class="headerlink" title="步骤简单总结"></a>步骤简单总结</h2><ul><li><p><strong>网络请求</strong></p></li><li><ul><li><strong>DNS</strong> 查询（得到 IP），建立 TCP 连接（三次握手）</li><li>浏览器发送 HTTP 请求</li><li>收到请求响应，得到 HTML（解析 HTML 过程中，遇到静态资源还会继续发起网络请求）</li></ul></li><li><p><strong>解析</strong>（字符串 -&gt; 结构化数据）</p></li><li><ul><li>HTML 构建 <strong>DOM</strong> 树</li><li>CSS 构建 <strong>CSSOM</strong> 树</li><li>两者结合形成 <strong>render</strong> tree</li></ul></li><li><p><strong>渲染</strong></p></li><li><ul><li><strong>layout</strong> 计算布局：（文档流， 盒模型， 计算各个元素的大小、位置）</li><li><strong>paint</strong> 绘制：（将边框颜色、文字颜色、阴影等都画出来）</li><li>composite 合成：根据层叠关系显示画面</li><li>遇到 JS 执行</li><li>异步 CSS，图片加载，可能会触发重新渲染</li></ul></li></ul><h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>通过域名查找 IP 地址</p><h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><p>递归实现</p><p>先在<strong>本地计算机缓存</strong>查找，找不到再将请求发送给 dns 服务器</p><p>在<strong>本地 dns 服务器</strong>找</p><p>再到<strong>根域名服务器</strong>找</p><p>再到<strong>顶级域名服务器</strong>找</p><p>以 <a href="http://www.google.com/">www.google.com</a> 为例：</p><p>. -&gt; .com -&gt; google.com. -&gt; <a href="http://www.google.com/">www.google.com</a></p><h3 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h3><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>DNS缓存指DNS返回了正确的IP之后，系统就会将这个结果临时储存起来。并且它会为缓存设定一个失效时间 (例如N小时)，在这N小时之内，当你再次访问这个网站时，系统就会直接从你<strong>电脑本地的DNS缓存</strong>中把结果交还给你，而<strong>不必再去询问DNS服务器</strong>，变相“加速”了网址的解析。</p><h4 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h4><p>你访问大公司域名的时候，每次响应的并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问。DNS可以返回一个<strong>合适的机器的IP</strong>给用户，例如可以根据每台<strong>机器的负载量</strong>，该机器离用户<strong>地理位置</strong>的距离等等，这种过程就是DNS负载均衡。</p><h2 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>在 TCP&#x2F;IP 协议中，TCP 协议提供可靠的连接服务，采用三次握手建立一个连接。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/20150603155505255.png" class="" title="img"> <p><strong>第一次握手</strong>：建立连接时，客户端发送 syn 包(syn&#x3D;j)到服务器，并进入 SYN_SEND 状态，等待服务器确认； </p><p><strong>第二次握手</strong>：服务器收到 syn 包，必须确认客户的 SYN（ack&#x3D;j+1），同时自己也发送一个 SYN 包（syn&#x3D;k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；<br><strong>第三次握手</strong>：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack&#x3D;k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/20150511164615901.jpeg" class="" title="img"> <p>通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。 <strong>三次握手的最主要目的是保证连接是双工的，可靠更多的是通过重传机制来保证的。</strong></p><p><strong>为什么是三次？</strong></p><p>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。 </p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。</p><p>那TCP 的四次握手，<strong>是为了保证通信双方都关闭了连接</strong>，具体过程如下：</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/20150603155803953.png" class="" title="img"> <p>1）客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送；<br>2）服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号；<br>3）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A；<br>4）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。</p><p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p><p>这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。<strong>但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了，但是你还可以给对方发送数据，也有这么种可能，你还有一些数据在传给对方的途中，所以你不能立马关闭连接</strong>,也即你可能还需要把在传输途中的数据给对方之后，又或者，你还有一些数据需要传输给对方后，（再关闭连接）再发送FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p><h3 id="TCP-x2F-UDP-的区别"><a href="#TCP-x2F-UDP-的区别" class="headerlink" title="TCP&#x2F;UDP 的区别"></a>TCP&#x2F;UDP 的区别</h3><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接，是指发送数据之前必须在两端建立TCP连接，连接方式为三次握手（打电话）</td><td>不面向连接（写信）</td></tr><tr><td>可靠传输，流量控制与拥塞控制</td><td>不可靠传输，尽最大努力交付</td></tr><tr><td>传输方式上以字节流的形式传输</td><td>以报文形式传输</td></tr><tr><td>只能是一对一通信</td><td>支持一对一、一对多、多对多、多对一交互通信</td></tr><tr><td>最小20字节，最多60字节</td><td>首部开销较小，只有 8 字节</td></tr><tr><td>适用于要求<strong>可靠传输</strong>的应用（传文件）</td><td><strong>适用于实时应用，如视频会议、直播等</strong>（丢几帧无所谓）</td></tr></tbody></table><p><strong>DNS使用什么协议传输？为什么？</strong></p><p>-  UDP 机制简单 开销小 性能更好</p><h2 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h2><h3 id="1-HTTP报文结构"><a href="#1-HTTP报文结构" class="headerlink" title="1. HTTP报文结构"></a>1. HTTP报文结构</h3><p>HTTP报文由<strong>报文首部</strong>和<strong>报文主体</strong>构成，中间由一个<strong>空行分隔</strong>。<strong>报文首部包含请求行和请求头部</strong>，报文主体主要包含被发送的信息。</p><p>报文首部是客户端或服务端需要处理请求或响应的内容及属性，可以传递额外的信息。</p><p>一个HTTP报文示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.enjoytoday.cn<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36<br>Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://www.enjoytoday.cn/posts/326<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, sdch<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8<br><br><span class="language-ini"><span class="hljs-attr">username</span>=hfcai&amp;sex=man</span><br></code></pre></td></tr></table></figure><h4 id="1-1-请求报文"><a href="#1-1-请求报文" class="headerlink" title="1-1. 请求报文"></a>1-1. 请求报文</h4><p>一个HTTP请求报文由<strong>请求行，请求头部，空行和请求数据</strong>4部分组成。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/278526F9CD532C9C14FBF3ADB9A2A930.png" class="" title="图片说明"> <p>请求行：三部分组成，方法 + URI + HTTP版本</p><p>请求头部：首部字段名和字段值构成，中间用 : 分隔。首部字段格式： 首部字段名:字段值</p><h4 id="1-2-响应报文"><a href="#1-2-响应报文" class="headerlink" title="1-2. 响应报文"></a>1-2. 响应报文</h4><p>HTTP响应报文由<strong>状态行、响应头部、空行和响应体</strong>4部分组成</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/FB5C81ED3A220004B71069645F112867.png" class="" title="图片说明"> <p>状态行：HTTP版本 + 状态码 + 响应短语</p><h3 id="2-HTTP首部字段"><a href="#2-HTTP首部字段" class="headerlink" title="2. HTTP首部字段"></a>2. HTTP首部字段</h3><p>给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等</p><h4 id="2-1-HTTP通用首部字段"><a href="#2-1-HTTP通用首部字段" class="headerlink" title="2-1. HTTP通用首部字段"></a>2-1. HTTP通用首部字段</h4><p>通用首部字段是请求报文和响应报文都会使用的字段，例如：</p><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td><strong>Date</strong></td><td>有</td><td></td><td>表示请求和响应生成的日期，GTM时间。例如 <code>Tue, 02 Mar 2021 12:31:25 GMT</code></td></tr><tr><td>Pragma</td><td>有</td><td></td><td>表示数据是否允许被缓存的通信选项</td></tr><tr><td><strong>Cache-Control</strong></td><td></td><td>有</td><td>控制缓存的相关信息<br />no-store表示不缓存<br />no-cache表示不缓存过期的资源</td></tr><tr><td><strong>Connection</strong></td><td></td><td>有</td><td>设置发送响应之后 TCP 连接是否继续保持<br />http1.1前需如下所示手动设置 Connection: Keep-Alive<br /><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606145754409.png" class="" title="img"></td></tr><tr><td>Transfer-Encoding</td><td></td><td>有</td><td>表示消息主体的编码格式</td></tr><tr><td>Via</td><td></td><td>有</td><td>记录途中经过的代理和网关</td></tr></tbody></table><h4 id="2-2-HTTP请求首部字段"><a href="#2-2-HTTP请求首部字段" class="headerlink" title="2-2. HTTP请求首部字段"></a>2-2. HTTP请求首部字段</h4><p>补充请求的附加信息、客户端信息、对相应内容相关的优先级</p><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td><strong>Host</strong></td><td></td><td>有</td><td>接受请求的服务器IP地址和端口号</td></tr><tr><td><strong>Accept</strong></td><td>有</td><td>有</td><td>客户端可支持的数据类型<br /><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606151327313.png" class="" title="img"><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606151859848-16548294901661.png" class="" title="img"></td></tr><tr><td>User-Agent</td><td>有</td><td>有</td><td></td></tr><tr><td><strong>If-Modified-Since</strong></td><td>有</td><td>有</td><td>UMT时间，表示该时间之后资源是否修改<br /><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606154802921.png" class="" title="img"></td></tr><tr><td><strong>If-None-Match</strong></td><td></td><td>有</td><td>返回服务器响应头的 Etag 值</td></tr><tr><td>Referer</td><td>有</td><td>有</td><td>通过点击超链接进入下一个页面时，在这里会记录上一个页面的 URI</td></tr><tr><td>Accept-Encoding</td><td>有</td><td>有</td><td>客户端可支持的编码格式<br />gzip&#x2F;compress&#x2F;deflate&#x2F;identify</td></tr><tr><td>Accept-Language</td><td>有</td><td>有</td><td>客户端可支持的语言（中文&#x2F;英文）</td></tr><tr><td><strong>If-Match</strong></td><td></td><td>有</td><td>If-xxx 条件请求  判断为真时，服务器才会执行请求<br />If-Match 和 ETag 值一致时，服务器才会接受请求</td></tr><tr><td>If-Unmodified-Since</td><td></td><td>有</td><td></td></tr><tr><td>Range</td><td></td><td>有</td><td>当只需要回去部分数据时，可通过这个字段指定要获取的数据范围</td></tr><tr><td>Authorization</td><td></td><td></td><td><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606152828630.png" class="" title="img"></td></tr></tbody></table><h4 id="2-3-HTTP响应首部字段"><a href="#2-3-HTTP响应首部字段" class="headerlink" title="2-3. HTTP响应首部字段"></a>2-3. HTTP响应首部字段</h4><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td>Location</td><td>有</td><td>有</td><td>令客户端重定向至URI，绝对路径</td></tr><tr><td>Server</td><td>有</td><td>有</td><td>服务器程序的名称和版本号相关信息</td></tr></tbody></table><h4 id="2-4-HTTP实体（消息体）首部字段"><a href="#2-4-HTTP实体（消息体）首部字段" class="headerlink" title="2-4. HTTP实体（消息体）首部字段"></a>2-4. HTTP实体（消息体）首部字段</h4><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td>Allow</td><td>有</td><td>有</td><td>表示指定的 URI 支持的方法</td></tr><tr><td>Content-Encoding</td><td>有</td><td>有</td><td>消息的编码格式</td></tr><tr><td>Content-Length</td><td>有</td><td>有</td><td>消息体的长度</td></tr><tr><td>Content-Type</td><td>有</td><td>有</td><td>消息体的数据类型</td></tr><tr><td><strong>Expires</strong></td><td>有</td><td>有</td><td>消息体的有效期，UMT 时间</td></tr><tr><td><strong>Last-Modified</strong></td><td>有</td><td>有</td><td>数据最后更新的日期</td></tr><tr><td><strong>Etag</strong></td><td></td><td>有</td><td>资源的唯一标识符，控制是否使用缓存</td></tr></tbody></table><h3 id="3-HTTP方法"><a href="#3-HTTP方法" class="headerlink" title="3. HTTP方法"></a>3. HTTP方法</h3><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p><p>HTTP1.0 定义了三种请求方法：GET、POST 和 HEAD 方法</p><p>HTTP1.1 新增了六种方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>用于从服务器获取数据</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过响应中没有具体的内容，<strong>用户获取报头</strong></td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求。数据被包含在请求体中，POST请求可能导致新的资源的建立或已有资源的修改</td></tr><tr><td>PUT</td><td>客户端向服务器传送的数据取代指定的文档内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的资源</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>CONNECT</td><td>HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606122333035.png" class="" title="img"><p><strong>GET与POST方法的区别：</strong></p><ol><li>get 是从指定的资源请求数据，post 是向指定的资源提交要处理的数据 </li><li>get 请求可以被缓存，post 请求不会被缓存 </li><li>get 请求传输的数据有长度限制，一般为 2048 字符，post 请求传输的数据没有大小限制 </li><li>get 请求的数据一般追加在 URL 的末尾，post 请求的数据在 http 请求体中</li></ol><p>一般不使用 GET 请求发送如密码这样的敏感信息。我认为 post 请求比 get请求更安全。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>304状态码是在协商缓存，缓存命中的时候服务器返回的，告诉客户端，服务器资源没有修改，可以使用客户端自己的缓存。</p><p>浏览器缓存分<strong>为本地缓存（强缓存）和协商缓存（弱缓存）</strong>。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/57B66CA5C634CC9645E63287A8BA90AC.png" class="" title="图片说明"> <p><strong>如上图所示，在浏览器第一次发出请求之后，需要再次发送请求的时候，浏览器首先获取该资源缓存的 header 信息，然后根据 Cache-Control 和 Expires 字段判断缓存是否过期。如果没有过期，直接使用浏览器缓存，并不会与服务器通信。该过程为判断是否使用强缓存，即本地缓存。</strong></p><ol><li><p><strong>Cache-Control</strong></p><p><strong>设置是否缓存与缓存时间等</strong>，通用字段，请求头和响应头中都有</p><p>该字段是 HTTP1.1 规范，一般利用该字段的 <strong>max-age</strong> 属性来判断，这个值是一个<strong>相对时间</strong>，单位为 s，代表资源的有效期。例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">Cache-Control:max-age=3600<br></code></pre></td></tr></table></figure><p>除此之外还有几个常用的值：</p><ul><li>no-cache：表示<strong>不使用强缓存</strong>，需要使用协商缓存 </li><li>no-store：禁止<strong>浏览器缓存数据</strong>，每次请求下载完整的资源 </li><li>public：可以被所有用户缓存，包括终端用户和中间代理服务器 </li><li>private：只能被终端用户的浏览器缓存</li></ul></li><li><p><strong>Expires</strong></p><p>该字段是 HTTP1.0 规范，他是一个<strong>绝对时间</strong>的 GMT 格式的时间字符串。例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">expires:Mar, 06 Apr 2020 10:57:09 GMT<br></code></pre></td></tr></table></figure><p>这个时间代表资源的失效时间，只要发送请求的时间在这之前，都会使用强缓存。</p><p>由于失效时间是一个绝对时间，因此当<strong>服务器时间与客户端时间偏差较大时，就会导致缓存混乱</strong>。</p></li></ol><p><strong>如果缓存过期，浏览器会向服务器发送请求，即 使用协商缓存。本次请求会带着第一次请求返回的有关缓存的 header 字段信息，比如以下两个字段：</strong>最后更新时间（<code>last-modified</code>）和文件标识（<code>ETag</code>）</p><p><strong>Etag&#x2F;If-None-Match</strong></p><p>判断响应头中是否存在 Etag 字段，如果存在，浏览器则发送一个带有 If-None-Match 字段的请求头的请求，该字段的值为 Etag 值。服务器通过对比客户端发过来的Etag值是否与服务器相同。如果相同，说明缓存命中，服务器返回 304 状态码，并将 If-None-Match 设为 false，客户端继续使用本地缓存。如果不相同，说明缓存未命中，服务器返回 200 状态码，并将 If-None-Match 设为 true，并且返回请求的数据。</p><p><strong>Last-Modified</strong>&#x2F;If-Modified-Since</p><p>除了 Etag 字段之外，客户端还会通过服务器返回的 Last-Modified 字段判断是否继续使用缓存，该字段为服务器返回的资源的最后修改时间，为UMT时间。浏览器发送一个带有 If-Modified-Since 字段的请求头的请求给服务器，该字段的值为 Last-Modified 值。服务器收到之后，通过这个时间判断，在该时间之后，资源有无修改，如果未修改，缓存命中，返回 304 状态码；如果未命中，返回 200 状态码，并返回最新的内容。</p><p>Etag和Last-Modified是服务器响应头里的；请求头里会加上If-None-Match和If-Modified-Since给服务器用于判断是否采用协商缓存</p><p><strong>Cache-Control 与 Expires 的优先级：</strong></p><p>两者可以在服务端配置同时使用，<strong>Cache-Control 的优先级高于 Expires。</strong></p><p><strong>Last-Modified&#x2F;If-Modified-Since 已经可以判断缓存是否失效了，为什么出现 Etag&#x2F;If-None-Match?</strong></p><p>Etag&#x2F;If-None-Match 是实体标签，是一个资源的唯一标识符，资源的变化都会导致 ETag 的变化。出现 Etag 的主要原因是解决 Last-Modified 比较难解决的问题：</p><ul><li>一些文件也许会周期性的修改，但是他的内容并不发生改变，这个时候我们并不希望客户端认为这个文件修改了 </li><li>某些文件在秒以下的时间内进行修改了，If-Modified-Since无法判断。UNIX时间只能精确到秒</li></ul><p>Last-Modified 和 Etag 可以一起使用， <strong>Etag 的优先级更高</strong>。</p><p><strong>E-tag 的缺点</strong></p><p>服务器需要计算Etag，会有性能损失</p><p>不同操作系统，web服务器对于ETag的计算方法也不同，当使用不同操作系统，不同类型的web服务器做负载均衡的时候，如果用ETag作为判断条件，在被负载均衡到不同服务器后，则很容易导致缓存失效。</p><p><strong>刷新页面的问题：</strong></p><p>F5刷新：不使用强缓存，使用协商缓存</p><p>ctrl+F5：二者都不使用</p><h2 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h2><h3 id="浏览器渲染步骤"><a href="#浏览器渲染步骤" class="headerlink" title="浏览器渲染步骤"></a>浏览器渲染步骤</h3><p> （1）首先解析收到的文档（HTML文件），根据文档定义<strong>构建一棵 DOM 树</strong>，DOM 树是由 DOM 元素及属性节点组成的。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115170857468.png" class="" title="img"><p> （2）然后对 CSS 进行解析，<strong>生成 CSSOM 规则树</strong>。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171024474.png" class="" title="img"><p> （3）根据 DOM 树和 CSSOM 规则树<strong>构建渲染树</strong>。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171208070.png" class="" title="img"><p> （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会<strong>根据渲染树来进行布局</strong>（也可以叫做<strong>回流</strong>）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171453541.png" class="" title="img"><p> （5）<strong>布局阶段结束后是绘制阶段</strong>，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</p><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是<strong>解析完一部分内容就显示一部分内容</strong>，同时，可能还在通过网络下载其余内容。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171612862.png" class="" title="img"><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><h4 id="阻塞关系"><a href="#阻塞关系" class="headerlink" title="阻塞关系"></a>阻塞关系</h4><ul><li><p>CSS </p></li><li><ul><li><strong>CSS 不会阻塞 HTML 的解析</strong>，解析 HTML 和解析 CSS 是并行的；</li><li>页面渲染依照 CSS Tree +DOM Tree 合成 Render Tree，因此 <strong>CSS 会阻塞页面的渲染</strong></li><li><strong>CSS 下载解析会阻塞 JS 执行</strong>，JS 需要读取 CSS 的结果</li></ul></li><li><p><strong>JS 会阻塞 HTML 解析</strong>：</p></li><li><ul><li>JS 可能会修改 DOM，需要阻塞 HTML 的解析</li><li>JS 执行线程是单独的线程，和浏览器解析渲染线程互斥</li></ul></li></ul><p>解析页面过程中如果遇到一个 script 标签，会停止 HTML 解析，去下载 script 脚本，下载完毕之后立即执行脚本，然后接着解析 HTML，所以如果 script 下载速度很慢，会造成页面<strong>白屏</strong>。因此我们常常<strong>把 script 标签放到 body 底部</strong>。当然在当下，并不是说 script 标签必须放在底部，因为你可以<strong>给 script 标签添加 defer 或者 async 属性</strong>。</p><h4 id="async-和-defer-的作用是什么？有什么区别？"><a href="#async-和-defer-的作用是什么？有什么区别？" class="headerlink" title="async 和 defer 的作用是什么？有什么区别？"></a><strong>async 和 defer 的作用是什么？有什么区别？</strong></h4><p>script ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</p><p>async script ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</p><p>defer script ：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220611161332407.png" class=""><h3 id="渲染页面时常见哪些不良现象？"><a href="#渲染页面时常见哪些不良现象？" class="headerlink" title="渲染页面时常见哪些不良现象？"></a>渲染页面时常见哪些不良现象？</h3><p>FOUC：主要指的是<strong>样式闪烁</strong>的问题，由于浏览器渲染机制（比如firefox），<strong>在 CSS 加载之前，先呈现了 HTML</strong>，就会导致展示出<strong>无样式</strong>内容，然后<strong>样式突然呈现</strong>的现象。会出现这个问题的原因主要是 <strong>css 加载时间过长，或者 css 被放在了文档底部</strong>。</p><p><strong>白屏</strong>：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 <strong>CSS 部分放在 HTML 尾部</strong>，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 <strong>js 文件放在头部</strong>，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</p><h3 id="浏览器的绘制过程"><a href="#浏览器的绘制过程" class="headerlink" title="浏览器的绘制过程"></a>浏览器的绘制过程</h3><h4 id="什么是重绘和回流（重拍）？"><a href="#什么是重绘和回流（重拍）？" class="headerlink" title="什么是重绘和回流（重拍）？"></a>什么是重绘和回流（重拍）？</h4><p><strong>重绘</strong>: 当渲染树中的一些元素需要更新属性，而这些属性<strong>只是影响元素的外观、风格，而不会影响布局</strong>的操作，比如 background-color，我们将这样的操作称为重绘。</p><p><strong>回流</strong>：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会<strong>影响到布局的操作</strong>，这样<br>的操作我们称为回流。</p><p><strong>常见引起回流属性和方法：</strong></p><p><strong>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</strong></p><p> （1）添加或者删除可见的 DOM 元素；<br> （2）元素尺寸改变——边距、填充、边框、宽度和高度<br> （3）内容变化，比如用户在 input 框中输入文字<br> （4）浏览器窗口尺寸改变——resize事件发生时<br> （5）计算 offsetWidth 和 offsetHeight 属性<br> （6）设置 style 属性的值<br> （7）当你修改网页的默认字体时。</p><p><strong>回流必定会发生重绘，重绘不一定会引发回流</strong>。回流的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><p><strong>常见引起重绘属性和方法：</strong></p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/68747470733a2f2f636176737a686f75796f752d313235343039333639372e636f732e61702d63686f6e6771696e672e6d7971636c6f75642e636f6d2f6e6f74652d31342e706e67.png" class="" title="常见引起回流属性和方法"><p><strong>常见引起回流属性和方法：</strong></p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/68747470733a2f2f636176737a686f75796f752d313235343039333639372e636f732e61702d63686f6e6771696e672e6d7971636c6f75642e636f6d2f6e6f74652d31332e706e67.png" class="" title="常见引起重绘属性和方法"><h4 id="如何减少回流？"><a href="#如何减少回流？" class="headerlink" title="如何减少回流？"></a>如何减少回流？</h4><ol><li><p><strong>最小化重绘和重排</strong>，比如<strong>样式集中改变</strong>，使用添加新样式类名 <code>.class</code> 或 <code>cssText</code> 。</p></li><li><p><strong>批量操作 DOM</strong>，比如读取某元素 <code>offsetWidth</code> 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。</p></li><li><p><strong>使用  absolute 或 fixed 使元素脱离文档流</strong>，这在制作复杂的动画时对性能的影响比较明显。</p></li><li><p><strong>开启 GPU 加速</strong>，利用 css 属性 <code>transform</code> 、<code>will-change</code> 等，比如改变元素位置，我们使用 <code>translate</code> 会比使用绝对定位改变其 <code>left</code> 、<code>top</code> 等来的高效，因为它不会触发重排或重绘，<code>transform</code> 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。</p></li><li><p><strong>opacity替代visibility</strong>： 前者回流重绘都不会触发(前提是它单独在一个图层)，后者两个都会触发。</p></li></ol><h4 id="为什么操作-DOM-慢？"><a href="#为什么操作-DOM-慢？" class="headerlink" title="为什么操作 DOM 慢？"></a>为什么操作 DOM 慢？</h4><p>一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</p><p>DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。</p><h2 id="JS-解析"><a href="#JS-解析" class="headerlink" title="JS 解析"></a>JS 解析</h2><p>事件循环，放在 JS 部分里</p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>DNS</tag>
      
      <tag>TCP/UDP</tag>
      
      <tag>缓存</tag>
      
      <tag>浏览器解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
