<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue3</title>
    <link href="/2022/07/01/vue3/"/>
    <url>/2022/07/01/vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="vue3-更新中"><a href="#vue3-更新中" class="headerlink" title="vue3(更新中)"></a>vue3(更新中)</h1><h2 id="构建与结构"><a href="#构建与结构" class="headerlink" title="构建与结构"></a>构建与结构</h2><h3 id="使用-vite-快速构建一个-vue3-项目"><a href="#使用-vite-快速构建一个-vue3-项目" class="headerlink" title="使用 vite 快速构建一个 vue3 项目"></a>使用 vite 快速构建一个 vue3 项目</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>初始化<br><span class="hljs-regexp">//</span> yarn create vite<br><span class="hljs-built_in">npm</span> init vite@latest<br><br><span class="hljs-number">2.</span>进入文件夹后安装依赖包<br><span class="hljs-built_in">npm</span> install<br><br><span class="hljs-number">3.</span>启动()<br><span class="hljs-built_in">npm</span> run dev<br></code></pre></td></tr></table></figure><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>vue2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;)<br>vm.$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>vue3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入的不再是Vue构造函数了，引入的是一个名为createApp的工厂函数</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">//创建应用实例对象——app(类似于之前Vue2中的vm，但app比vm更“轻”)</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br><span class="hljs-comment">//挂载</span><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br><span class="hljs-comment">// 卸载</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    app.<span class="hljs-title function_">unmount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h2 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h2><h3 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h3><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><ol><li><p>Vue3.0 中的新配置项，值为一个函数</p></li><li><p>组件中所用到的数据、方法等都要配置在 setup 中</p></li><li><p>setup 函数有两种返回值：</p></li></ol><p><strong>返回一个对象，对象中的属性、方法，在模板中均可直接使用</strong></p><p>返回一个渲染函数，可以自定义渲染内容（较少使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;h1&gt;信息：&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;sayHello&quot;&gt;说话&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; h &#125; from &#x27;vue&#x27;<br><br>export default &#123;<br>    name: &#x27;App&#x27;,<br><br>    // 这样的数据无响应式<br>    setup() &#123;<br>        // 数据<br>        let name = &#x27;张三&#x27;<br>        let age = 18<br><br>        // 方法<br>        function sayHello() &#123;<br>            alert(`我叫xxx$&#123;name&#125;, 我$&#123;age&#125;岁了`)<br>        &#125;<br><br>        // 返回一个对象<br>        /* return &#123;<br>            name,<br>            age,<br>            sayHello<br>        &#125; */<br><br>        // 返回一个函数 (渲染函数)<br>        return () =&gt; &#123;return h(&#x27;h1&#x27;, &#x27;尚硅谷&#x27;)&#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>vue2 中定义 data &#x2F; methods 都是键值对形式的，因为本身式对象（所以不需要 let &#x2F; function）</p><p>vue3 setup是一个函数，所以里面的数据和方法都是需要定义的。并且 setup 不能用 async 定义。</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p><strong>作用：定义一个响应式数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;h1&gt;信息：&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>&lt;h3&gt;工作种类：&#123;&#123;job.type&#125;&#125;&lt;/h3&gt;<br>&lt;h3&gt;工作薪水：&#123;&#123;job.salary&#125;&#125;&lt;/h3&gt;<br>    &lt;button @click=&quot;changeInfo&quot;&gt;修改人的信息&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    import &#123;ref&#125; from &#x27;vue&#x27;<br><br>    export default &#123;<br>        name: &#x27;App&#x27;,<br><br>        // 这样的数据无响应式<br>        setup() &#123;<br>            // 数据<br>let name = ref(&#x27;张三&#x27;)<br>let age = ref(23)<br>let job = ref(&#123;<br>type:&#x27;前端&#x27;,<br>salary:&#x27;20K&#x27;<br>&#125;)<br><br>            // 方法<br>            function changeInfo() &#123;<br>                name.value = &#x27;李四&#x27;<br>                age.value = 33<br>                job.value.type = &#x27;算法&#x27;<br>                job.value.salary = &#x27;30K&#x27;<br>            &#125;<br><br>            // 返回一个对象<br>            return &#123;<br>                name,<br>                age,<br>                job,<br>                changeInfo<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>为什么修改数据需要 .value？</strong></p><p>被 ref 包裹的数据变为了对象，是 RefImpl (reference implement) 的实例，可称为引用对象，就实现响应式了。</p><img src="/2022/07/01/vue3/image-20220701143037245.png" class="" title="image-20220701143037245"><p><strong>为什么 html 部分不需要 .value？</strong></p><p>检测到是响应式数据后，会自动解析</p><p><strong>ref 处理对象类型用的 proxy（操作封装在 reactive 函数中），简单类型还是用的 object.defineProperty（本身object.defineProperty的问题就在于对象&#x2F;数组）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// name是简单数据类型, job是对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-property">value</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(job.<span class="hljs-property">value</span>)<br></code></pre></td></tr></table></figure><img src="/2022/07/01/vue3/image-20220701150926114.png" class="" title="image-20220701150926114"><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><p><strong>作用：定义一个&#x3D;&#x3D;对象类型&#x3D;&#x3D;的响应式数据</strong></p><p>对象使用 reactive 而不是用 ref ，可以少写 .value</p><p><strong>语法：</strong>const 代理对象&#x3D; reactive(源对象)接收一个对象（或数组），<strong>返回一个代理对象</strong>（Proxy的实例对象）。</p><p>通过代理对象修改源对象。</p><p><strong>可以将多个简单数据类型封装为一个对象使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;h1&gt;信息：&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;<br>&lt;h3&gt;工作种类：&#123;&#123;person.job.type&#125;&#125;&lt;/h3&gt;<br>&lt;h3&gt;工作薪水：&#123;&#123;person.job.salary&#125;&#125;&lt;/h3&gt;<br>    &lt;h3&gt;爱好：&#123;&#123;person.hobby&#125;&#125;&lt;/h3&gt;<br>    &lt;h3&gt;测试的数据c：&#123;&#123;person.job.a.b.c&#125;&#125;&lt;/h3&gt;<br>    &lt;button @click=&quot;changeInfo&quot;&gt;修改人的信息&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    import &#123;reactive&#125; from &#x27;vue&#x27;<br><br>    export default &#123;<br>        name: &#x27;App&#x27;,<br><br>        setup() &#123;<br>            let person = reactive(&#123;<br>                name: &#x27;张三&#x27;,<br>                age: 28,<br>                job: &#123;<br>                    type:&#x27;前端&#x27;,<br>                    salary:&#x27;20K&#x27;,<br>                    a: &#123;<br>                        b: &#123;<br>                            c: 666<br>                        &#125;<br>                    &#125;<br>                &#125;,<br>                hobby: [&#x27;抽烟&#x27;, &#x27;喝酒&#x27;, &#x27;烫头&#x27;]<br>            &#125;)<br>           <br>            // 方法<br>            function changeInfo() &#123;<br>                person.name = &#x27;李四&#x27;,<br>                person.age = 48,<br>                person.job.type = &#x27;算法&#x27;,<br>                person.job.salary = &#x27;30K&#x27;<br>                person.job.a.b.c = 999,<br>                person.hobby[0] = &#x27;学习&#x27;<br>            &#125;<br><br>            // 返回一个对象<br>            return &#123;<br>                person,<br>                changeInfo<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><h5 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h5><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, <span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>    get () &#123;&#125;, <br>    set () &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h5 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h5><ul><li><p>实现原理: </p><ul><li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p></li><li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p></li><li><p>MDN文档中描述的Proxy与Reflect：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br><span class="hljs-comment">// 拦截读取属性值</span><br>    get (target, prop) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截设置属性值或添加新属性</span><br>    set (target, prop, value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, prop, value)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截删除属性</span><br>    deleteProperty (target, prop) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, prop)<br>    &#125;<br>&#125;)<br><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;tom&#x27;</span>   <br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="reactive与ref"><a href="#reactive与ref" class="headerlink" title="reactive与ref"></a>reactive与ref</h4><ul><li>从定义数据角度对比：<ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm nvm nrm</title>
    <link href="/2022/06/30/npm-nvm-nrm/"/>
    <url>/2022/06/30/npm-nvm-nrm/</url>
    
    <content type="html"><![CDATA[<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>Node Package Manager</p><p>NodeJS包管理和分发工具</p><p><strong>npm 规定在项目根目录中必须提供一个 package.json 包管理配置文件，记录与项目相关的配置信息</strong>，如：</p><p>项目的名称、版本号、描述等</p><p>项目中用到了哪些包</p><p>哪些包只会在开发期间使用</p><p>哪些包在开发和部署时都会使用</p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a><strong>常用指令</strong></h3><h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 默认为 当前文件夹安装 最新版本 写入package.json的dependencies(-S)<br>npm install XXX<br><br><span class="hljs-regexp">//</span> 安装指定版本<br>npm install xxx@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 全局安装<br>npm install -g<br><br><span class="hljs-regexp">//</span> 写入package.json的devDependencies中<br>npm install –D xxx<br></code></pre></td></tr></table></figure><h4 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 卸载<br>npm uninstall XXX<br><br><span class="hljs-regexp">//</span> 卸载并在 package.json 中移除<br>npm uninstall -S XXX<br>npm uninstall -D XXX<br><br><span class="hljs-regexp">//</span> 卸载全局依赖<br>npm uninstall -g XXX<br></code></pre></td></tr></table></figure><h4 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 检查更新<br>npm outdated<br><br><span class="hljs-regexp">//</span> 执行更新<br>npm update<br></code></pre></td></tr></table></figure><h4 id="查看包"><a href="#查看包" class="headerlink" title="查看包"></a>查看包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 查看全局安装的包<br>npm list -g --depth <span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 查看某个包的版本<br>npm list vue-cli<br></code></pre></td></tr></table></figure><h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>Node Version Management</p><p>管理 node 版本的工具，通过它可以安装和切换不同版本的 node.js</p><p>不同的项目需要不同的 node 版本</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><p><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><h3 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a><strong>常用指令</strong></h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 本地 node 版本<br>nvm list<br><br><span class="hljs-regexp">//</span> 官方 node 版本<br>nvm list available<br><br><span class="hljs-regexp">//</span> 安装<br>nvm install <span class="hljs-number">18.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 卸载<br>nvm uninstall <span class="hljs-number">18.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 切换当前版本<br>nvm use <span class="hljs-number">18.2</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>npm registry manager</p><p>npm 的镜像源管理工具</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 全局安装<br>npm install -g nrm<br></code></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 查看所有源<br>nrm ls<br><br><span class="hljs-regexp">//</span> 添加源 nrm add &lt;registry&gt; &lt;url&gt;<br>nrm add baidu www.baidu.com<br><br><span class="hljs-regexp">//</span> 切换源<br>nrm use taobao<br><br><span class="hljs-regexp">//</span> 删除源<br>nrm use taobao<br><br><span class="hljs-regexp">//</span> 测试源相应时长<br>nrm test taobao<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>包管理工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vite</title>
    <link href="/2022/06/30/Vite/"/>
    <url>/2022/06/30/Vite/</url>
    
    <content type="html"><![CDATA[<h1 id="Vite（未完）"><a href="#Vite（未完）" class="headerlink" title="Vite（未完）"></a>Vite（未完）</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://vitejs.cn/guide/why.html#the-problems">官方文档</a></p><h2 id="Vite的优势"><a href="#Vite的优势" class="headerlink" title="Vite的优势"></a>Vite的优势</h2><h3 id="更快的服务器启动"><a href="#更快的服务器启动" class="headerlink" title="更快的服务器启动"></a><strong>更快的服务器启动</strong></h3><p>Vite 通过在一开始将应用中的模块区分为 <strong>依赖</strong> 和 <strong>源码</strong> 两类，改进了开发服务器启动时间</p><p><strong>依赖</strong> 大多为在开发时不会变动的纯 JavaScript。</p><p>Vite 将会使用 **<a href="https://esbuild.github.io/">esbuild</a> <a href="https://vitejs.cn/guide/dep-pre-bundling.html">预构建依赖</a>**。Esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。</p><p><strong>源码</strong> 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue&#x2F;Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。</p><p>Vite 以 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules"><strong>原生 ESM</strong></a> 方式提供源码。这实际上是<strong>让浏览器接管了打包程序的部分工作</strong>：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景<strong>动态导入</strong>代码，即只在当前屏幕上实际使用时才会被处理。</p><h3 id="更快的更新"><a href="#更快的更新" class="headerlink" title="更快的更新"></a>更快的更新</h3><p>轻量快速的 HMR</p><p>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。</p><h3 id="传统构建与-vite-构建对比图"><a href="#传统构建与-vite-构建对比图" class="headerlink" title="传统构建与 vite 构建对比图"></a>传统构建与 vite 构建对比图</h3><p>一次全部打包</p><img src="/2022/06/30/Vite/bundler.37740380.png" class="" title="基于打包器的开发服务器"><p>按需动态引入</p><img src="/2022/06/30/Vite/esm.3070012d.png" class="" title="基于 ESM 的开发服务器"><h2 id="快速搭建一个项目"><a href="#快速搭建一个项目" class="headerlink" title="快速搭建一个项目"></a>快速搭建一个项目</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>初始化<br><span class="hljs-regexp">//</span> yarn create vite<br><span class="hljs-built_in">npm</span> init vite@latest<br><br><span class="hljs-number">2.</span>进入文件夹后安装依赖包<br><span class="hljs-built_in">npm</span> install<br><br><span class="hljs-number">3.</span>启动()<br><span class="hljs-built_in">npm</span> run dev<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json 命令解析</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 启动开发服务器，别名：`vite dev`，`vite serve`</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite build&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 为生产环境构建产物</span><br>    <span class="hljs-attr">&quot;preview&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite preview&quot;</span> <span class="hljs-comment">// 本地预览生产构建产物</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>项目目录</p><img src="/2022/06/30/Vite/image-20220701002419270.png" class="" title="image-20220701002419270"><p>public 下放无需编译的静态资源（图片 &#x2F; js）</p><p>assets 放可被编译的静态资源（图片 -&gt; base64）</p><p>components 公共组件</p>]]></content>
    
    
    <categories>
      
      <category>vite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pinia</title>
    <link href="/2022/06/28/pinia/"/>
    <url>/2022/06/28/pinia/</url>
    
    <content type="html"><![CDATA[<h1 id="Pinia（未完）"><a href="#Pinia（未完）" class="headerlink" title="Pinia（未完）"></a>Pinia（未完）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是-pinia"><a href="#什么是-pinia" class="headerlink" title="什么是 pinia"></a>什么是 pinia</h3><p>Vue 的状态管理库，会逐渐取代 Vuex</p><h3 id="pinia-的优势"><a href="#pinia-的优势" class="headerlink" title="pinia 的优势"></a>pinia 的优势</h3><p>1.完全支持 ts</p><p>2.移除了 mutations，actions 同时支持同步和异步</p><p>3.轻量 压缩后体积只有 1kb 左右</p><p>4.没有模块嵌套，只有 store，每一个 store 都是独立的</p><p>5.store 一旦创建便会自动添加，无需手动添加 store</p><p>6.支持 vue2 与 vue3</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="安装-pinia"><a href="#安装-pinia" class="headerlink" title="安装 pinia"></a>安装 pinia</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install pinia <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="创建-store"><a href="#创建-store" class="headerlink" title="创建 store"></a>创建 store</h3><p>新建 src&#x2F;store 目录并在其下面创建 index.ts，导出 store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/store/index.ts</span><br><span class="hljs-keyword">import</span> &#123;createPinia&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createPinia</span>()<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br></code></pre></td></tr></table></figure><p>vue3 是 createPinia </p><p>vue2 是 PiniaVuePlugin</p><p>在 main.ts 中引入并使用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/main.ts</span><br><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br>app.<span class="hljs-title function_">use</span>(store)<br></code></pre></td></tr></table></figure><h3 id="定义-store"><a href="#定义-store" class="headerlink" title="定义 store"></a>定义 store</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//src/store/user.ts</span><br><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTestStore = <span class="hljs-title function_">defineStore</span>(&#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-comment">// id必填，唯一值(可以理解成命名空间)</span><br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// vuex中的state是对象, pinia中是箭头函数返回对象</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;lwj&#x27;</span>,<br>            <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;23&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">getters</span>: &#123;<br><br>    &#125;,<br>    <span class="hljs-attr">actions</span>: &#123;<br><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &#123;&#123;Test.name&#125;&#125;-&#123;&#123;Test.age&#125;&#125;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    import &#123;useTestStore&#125; from &#x27;./store/user.ts&#x27;<br>    const Test = useTestStore()<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>修改 state 的五种方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> c<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>状态管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量提升与函数提升</title>
    <link href="/2022/06/27/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/"/>
    <url>/2022/06/27/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<h1 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h1><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>只有var定义的变量才会被提升</p><p>只提升声明，不提升赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a= <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//  &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>只提升函数声明式，不提升函数字面量式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//函数声明式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span> () &#123;&#125;<br><span class="hljs-comment">//函数字面量式 </span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>会整体提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getName</span>()<span class="hljs-comment">// 小明</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;小明&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.后面覆盖前面</p><p>2.如果变量和函数同名，提升的是函数</p><p>3.变量提升会区分作用域</p><h2 id="一道经典题目"><a href="#一道经典题目" class="headerlink" title="一道经典题目"></a>一道经典题目</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br><span class="hljs-title function_">a</span>();<br><span class="hljs-keyword">var</span> a=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span> ()&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>a=<span class="hljs-number">6</span>;<br><span class="hljs-title function_">a</span>()<br><br><span class="hljs-comment">//输出结果：function a () &#123;console.log()&#125;  10 3  TypeError </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端性能优化</title>
    <link href="/2022/06/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/06/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="前端性能优化的手段"><a href="#前端性能优化的手段" class="headerlink" title="前端性能优化的手段"></a>前端性能优化的手段</h2><h3 id="减少-http-请求"><a href="#减少-http-请求" class="headerlink" title="减少 http 请求"></a>减少 http 请求</h3><ol><li>base64 处理图片</li><li>减少重定向</li><li>使用缓存</li><li>不使用 css 的 @import</li></ol><h3 id="减少资源太小-压缩"><a href="#减少资源太小-压缩" class="headerlink" title="减少资源太小(压缩)"></a>减少资源太小(压缩)</h3><ol><li><strong>webpack</strong></li></ol><p>压缩 htmlHtmlWebpackPlugin 配置 minify</p><p>压缩 css   optimize-css-assets-webpack-plugin</p><p>压缩 js  mode: ‘production’(自动使用 terser-webpack-plugin)</p><ol start="2"><li><strong>开启 gzip 编码</strong></li></ol><p>开发模式下：webpack-dev-server 配置 compress: true</p><p>生产模式下：服务端配置，如 express 使用 compression 中间件</p><h3 id="优化网络连接"><a href="#优化网络连接" class="headerlink" title="优化网络连接"></a>优化网络连接</h3><ol><li><strong>内容分发网络 CDN</strong></li></ol><p>根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上</p><ol start="2"><li><strong>DNS 预解析</strong></li></ol><p>DNS 预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度</p><p>方法是在 head 标签里面写上几个 link 标签</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;dns-prefecth&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;https://www.google.com&quot;</span>&gt;<br>&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;dns-prefecth&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;https://www.google-analytics.com&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间</p><h3 id="优化资源加载"><a href="#优化资源加载" class="headerlink" title="优化资源加载"></a>优化资源加载</h3><ol><li><strong>资源加载位置</strong></li></ol><p>通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用</p><p>CSS文件放在head中</p><p>JS文件放在body底部，或者使用 defer&#x2F;async</p><ol start="2"><li><strong>资源加载时机</strong></li></ol><p>按需加载</p><p>懒加载与预加载</p><h3 id="减少重绘回流"><a href="#减少重绘回流" class="headerlink" title="减少重绘回流"></a>减少重绘回流</h3><ol><li><p>避免使用层级较深的选择器</p></li><li><p>防抖节流</p></li><li><p>DocumentFragment</p></li></ol><p>让DOM操作发生在内存中，而不是页面上；可以实现离线更新</p><ol start="4"><li>事件代理</li><li>动画 GPU 加速</li></ol><h3 id="性能更好的API"><a href="#性能更好的API" class="headerlink" title="性能更好的API"></a>性能更好的API</h3><ol><li>requestAnimationFrame来替代setTimeout和setInterval</li><li>使用IntersectionObserver来实现图片可视区域的懒加载</li></ol><h3 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h3><ol><li><p>treeshaking 去除无用代码</p></li><li><p>文件缓存</p></li></ol><p>hash chunkhash contenthash</p>]]></content>
    
    
    <categories>
      
      <category>优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块化</title>
    <link href="/2022/06/22/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2022/06/22/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起；</p><p>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>避免命名冲突、避免全局变量污染</p><p>便于代码编写和维护</p><h2 id="早期的模块化"><a href="#早期的模块化" class="headerlink" title="早期的模块化"></a>早期的模块化</h2><p>立即执行函数</p><p>通过函数作用域解决了命名冲突、污染全局的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-comment">// 在这里面声明各种变量、函数都不会污染全局作用域</span><br>&#125;)(a)<br></code></pre></td></tr></table></figure><h2 id="模块化方案"><a href="#模块化方案" class="headerlink" title="模块化方案"></a>模块化方案</h2><h3 id="1、CommonJS"><a href="#1、CommonJS" class="headerlink" title="1、CommonJS"></a>1、CommonJS</h3><p>①在node环境下使用，不支持浏览器环境<br>②NodeJS遵循的规范<br>③使用require()进行引入依赖<br>④使用exports进行暴露模块</p><h3 id="2、AMD"><a href="#2、AMD" class="headerlink" title="2、AMD"></a>2、AMD</h3><p>①浏览器环境下的异步加载模块<br>②RequireJS遵循的规范<br>③依赖于require.js模块管理工具库<br>④AMD 推崇依赖前置</p><h3 id="3、CMD"><a href="#3、CMD" class="headerlink" title="3、CMD"></a>3、CMD</h3><p>①浏览器环境下，同时支持异步和同步加载<br>②SeaJS遵循的规范<br>③CMD 推崇依赖就近</p><h3 id="4、ES6-module"><a href="#4、ES6-module" class="headerlink" title="4、ES6 module"></a>4、ES6 module</h3><p>ES6模块化语法在编译时就能确定模块的依赖关系，还能确定好输入输出的变量声明，已经不仅仅是模块规范，现在已经作为JS语言的标准语法使用，有以下特性：</p><p>①浏览器环境、<a href="https://www.yisu.com/">服务器</a>环境都支持<br>②编译时就能确定模块的依赖关系及变量，其他模块规范都是在运行时确定的<br>③export命令用于规定模块的对外接口<br>④import命令用于输入其他模块提供的功能</p><h3 id="CommonJs和ES6-module的区别"><a href="#CommonJs和ES6-module的区别" class="headerlink" title="CommonJs和ES6 module的区别"></a>CommonJs和ES6 module的区别</h3><p><strong>CommonJS</strong> 是一种模块规范，最初被应用于 <strong>Nodejs</strong>，成为 Nodejs 的模块规范。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br><span class="hljs-comment">// 导出</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = 导出的值<br></code></pre></td></tr></table></figure><p>运行在<strong>浏览器</strong>端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: <strong>AMD</strong>)，用来对前端模块进行管理。</p><p>自 ES6 起，引入了一套新的 <strong>ES6 Module 规范</strong>，在语言标准的层面上实现了模块功能，而且实现得相当简单，<strong>有望成为浏览器和服务器通用的模块解决方案</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;模块路径&quot;</span><br><span class="hljs-keyword">import</span> &#123;a,b&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;模块路径&quot;</span><br><span class="hljs-keyword">import</span> c <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;模块路径&quot;</span><span class="hljs-comment">//默认导入</span><br><br><br><span class="hljs-comment">// 导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">b</span> = (<span class="hljs-params"></span>)=&gt;&#123;&#125;<br><span class="hljs-comment">//默认导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">xx</span>:yy,<br><span class="hljs-attr">aa</span>:bb<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>但目前浏览器对 ES6 Module <strong>兼容还不太好</strong>，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。</p><p>在**<a href="https://blog.csdn.net/qq_45890970/article/details/123541700?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123541700-blog-123954229.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=3">使用上的差别</a>**主要有：</p><p><strong>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong>（一旦输出一个值，模块内部的变化就影响不到这个值）</p><p><strong>CommonJS 是同步加载模块，ES6 是异步加载模块。</strong>（主要用于服务器编程，模块文件一般都已经存在于本地，加载起来比较快）</p><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p><p>CommonJs 是单个值导出，ES6 Module可以导出多个</p><p>CommonJs 是<strong>动态语法可以写在判断里</strong>，ES6 Module <strong>静态语法只能写在顶层</strong></p><p>CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.yisu.com/zixun/452499.html">https://www.yisu.com/zixun/452499.html</a></p><p><a href="https://blog.csdn.net/weixin_39690316/article/details/122946850">https://blog.csdn.net/weixin_39690316/article/details/122946850</a></p><p><a href="https://blog.csdn.net/qq_45890970/article/details/123541700?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123541700-blog-123954229.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/qq_45890970/article/details/123541700?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123541700-blog-123954229.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>模块化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AJAX</title>
    <link href="/2022/06/21/AJAX/"/>
    <url>/2022/06/21/AJAX/</url>
    
    <content type="html"><![CDATA[<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Asynchronous JavaScript And XML（异步的 JS 和 XML）</p><p>AJAX 是在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页。（<strong>无刷新获取数据</strong>）</p><h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点：</strong></p><ol><li><p>无需刷新页面与服务端通信</p></li><li><p>允许根据用户事件来更新部分页面内容</p></li></ol><p><strong>缺点：</strong></p><ol><li>没有浏览历史、不能回退</li><li>存在跨域问题</li><li>不易SEO</li></ol><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>传统Ajax 指的是 XMLHttpRequest（XHR），最早出现的向后端发送请求的技术，隶属于原始 js 中</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h4><ul><li>创建对象 （XMLHttpRequest 对象）</li><li>请求 （将请求发送到服务器，使用 XMLHttpRequest 对象的 open() 和 send() 方法）</li><li>响应 （获得来自服务器的响应，使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性）</li><li>根据XMLHttpRequest的readyState判定调用哪个回调函数 （onreadystatechange 事件）</li><li>更新页面</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 请求成功回调函数</span><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request success&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 请求结束回调函数</span><br>xhr.<span class="hljs-property">onloadend</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request loadend&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 请求出错回调函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request error&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 请求超时回调函数</span><br>xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request timeout&#x27;</span>);<br>&#125;;<br><br>xhr.<span class="hljs-property">timeout</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 设置超时时间,0表示永不超时</span><br><span class="hljs-comment">// 初始化请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET/POST/DELETE/...&#x27;</span>, <span class="hljs-string">&#x27;/url&#x27;</span>, <span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 设置期望的返回数据类型 &#x27;json&#x27; &#x27;text&#x27; &#x27;document&#x27; ...</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-comment">// 设置请求头</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-comment">// 发送请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span> || <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span> || <span class="hljs-string">&#x27;a=1&amp;b=2&#x27;</span> || <span class="hljs-string">&#x27;json字符串&#x27;</span>);<br><br><span class="hljs-comment">// 请求回调函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> === <span class="hljs-number">304</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request success&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request error&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 取消请求</span><br>xhr.<span class="hljs-title function_">abort</span>()<br></code></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>浏览器通过 XMLHttpRequest 对象进行 http 通信，多个请求之间如果有先后关系的话，就会出现 <a href="https://www.cnblogs.com/bala/p/11650296.html#callback-hell"><strong>回调地狱</strong></a></p><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>fetch 号称是 AJAX 的替代品，是在 ES6 出现的，使用了ES6 中的 promise 对象。Fetch 是基于 promise 设计的。</p><p><strong>fetch 不是 ajax的进一步封装，而是原生 JS ， 没有使用 XMLHttpRequest 对象。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 一个简单的fetch 请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/movies.json&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)&#123;<br>        <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>()<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">myJson</span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myJson) <br>    &#125;)<br><br><br><span class="hljs-comment">// 一个带有参数的fetch请求</span><br><span class="hljs-title function_">postData</span>(<span class="hljs-string">&#x27;http://example.com/answer&#x27;</span>,&#123;<span class="hljs-attr">answer</span>: <span class="hljs-number">42</span>&#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))  <span class="hljs-comment">// JSON from &#x27;response.json()&#x27; call</span><br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error))<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">postData</span>(<span class="hljs-params">url, data</span>) &#123;<br>  <span class="hljs-comment">// Default options are marked with *</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>       <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data),  <span class="hljs-comment">// must match &#x27;Content-Type&#x27; header</span><br>       <span class="hljs-attr">cache</span>: <span class="hljs-string">&#x27;no-cache&#x27;</span>,  <span class="hljs-comment">// * default, no-cache, reload, force-cache, only-if-cached</span><br>        <span class="hljs-attr">headers</span>: &#123;<br>            <span class="hljs-string">&#x27;user-agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/4.0 MDN Example&#x27;</span>,<br>             <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>        &#125;,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-comment">// *GET, POST, PUT, DELETE, etc.</span><br>        <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;cors&#x27;</span>, <span class="hljs-comment">// no-cors, cors, *same-origin</span><br>        <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;follow&#x27;</span>, <span class="hljs-comment">// manual, *follow, error</span><br>        <span class="hljs-attr">referrer</span>: <span class="hljs-string">&#x27;no-referrer&#x27;</span>, <span class="hljs-comment">// *client, no-referrer    </span><br>  &#125;)    <br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>()) <span class="hljs-comment">// parses response to JSON</span><br></code></pre></td></tr></table></figure><p>fetch 的优点：</p><p>　　1、语法简洁，更加语义化</p><p>　　2、基于标准 Promise 实现，支持 async &#x2F; await</p><p>　　3、同构方便，使用<code>[isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)</code></p><p>　　4、更加底层，提供的 API 丰富 （request， response）</p><p>　　5、脱离了 XHR，是 ES 规范中新的实现方式。</p><p>缺点：</p><p>　　1、fetch 只对网络请求报错，对400,500都当作成功的请求，服务器返回400， 500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时， fetch 才会被 reject。需要封装去处理。</p><p>　　2、fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</p><p>　　3、**<a href="https://www.cnblogs.com/bala/p/11650296.html#abort-controller">fetch 不支持 abort</a>** （xhr 有个 xhr.abort 方法可以直接阻断请求），不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求，请求过程继续在后台运行，造成了流量的浪费。</p><p>　　4、fetch 没有办法原生监测请求的进度，而 XHR 可以。</p><p>　　5、fetch 兼容性并不太好，IE 不支持</p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios 是一个基于 <a href="https://www.cnblogs.com/bala/p/11650296.html#promise">Promise</a> 的 http请求库，可以用在浏览器和 node.js 中，本质上也是<strong>对原生XHR的封装</strong>，只不过它是Promise 的实现版本，符合最新的ES规则。是目前最常用的请求方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 配置 baseURL</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;http://localhost:8000&#x27;</span>;<br><br><span class="hljs-comment">// GET 请求</span><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/axios-server&#x27;</span>, &#123;<br>    <span class="hljs-comment">// url 参数</span><br>    <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-number">100</span>,<br>        <span class="hljs-attr">vip</span>: <span class="hljs-number">7</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 请求头信息</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;atguigu&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error) <br>&#125;)<br><br><span class="hljs-comment">// POST 请求</span><br>axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/axios-server&#x27;</span>, &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>&#125;, &#123;<br>    <span class="hljs-comment">// url</span><br>    <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-attr">vip</span>: <span class="hljs-number">9</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 请求头参数</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">height</span>: <span class="hljs-number">180</span>,<br>        <span class="hljs-attr">weight</span>: <span class="hljs-number">180</span>,<br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error) <br>&#125;)<br><br><span class="hljs-comment">// 通用</span><br><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-comment">// 请求方法</span><br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-comment">//url</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/axios-server&#x27;</span>,<br>    <span class="hljs-comment">// url参数</span><br>    <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">vip</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">level</span>: <span class="hljs-number">30</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 头信息</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">a</span>: <span class="hljs-number">100</span>,<br>        <span class="hljs-attr">b</span>: <span class="hljs-number">200</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 请求体参数</span><br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>        <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>    <span class="hljs-comment">// 响应状态码</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">status</span>);<br>    <span class="hljs-comment">// 响应状态字符串</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">statusText</span>);<br>    <span class="hljs-comment">// 响应头信息</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">headers</span>);<br>    <span class="hljs-comment">// 响应体</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error) <br>&#125;)<br><br><span class="hljs-comment">// 利用 async await</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/axios-server&#x27;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)                   <br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)  <br>    &#125;  <br></code></pre></td></tr></table></figure><p>axios 的特征：</p><p>　　1、从浏览器中创建XMLHttpRequest</p><p>　　<strong>2、支持 Promise API，不会产生回调地狱的问题</strong></p><p>　　<strong>3、客户端支持防止 CSRF</strong></p><p>　　4、提供了一些**<a href="https://www.cnblogs.com/bala/p/11650296.html#concurrent">并发</a>**请求的接口（重要，方便了很多的操作）</p><p>　　5、从 node.js 创建 http 请求</p><p>　　<strong>6、拦截请求和响应</strong></p><p>　　7、转换请求和响应数据</p><p>　　8、取消请求</p><p>　　9、自动转换JSON数据</p><h3 id="xhr-封装-axios"><a href="#xhr-封装-axios" class="headerlink" title="xhr 封装 axios"></a>xhr 封装 axios</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">axios</span>(<span class="hljs-params">method, url, data</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>        xhr.<span class="hljs-title function_">open</span>(method, url)<br>        xhr.<span class="hljs-title function_">send</span>(data)<br>        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">response</span>))<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>                       <br><span class="hljs-comment">// 调用</span><br><span class="hljs-title function_">axios</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;接口地址&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)  <br></code></pre></td></tr></table></figure><h3 id="如何终止-http-请求"><a href="#如何终止-http-请求" class="headerlink" title="如何终止 http 请求"></a><a href="https://www.jianshu.com/p/a7d367dd270b">如何终止 http 请求</a></h3><p><strong>XMLHttpRequest</strong></p><p><strong>abort()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ajax = <span class="hljs-title class_">XMLHttpRequest</span><br>ajax.<span class="hljs-title function_">open</span>()<br>ajax.<span class="hljs-title function_">send</span>()<br>ajax.<span class="hljs-property">onreadystateChange</span> = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br><br><span class="hljs-comment">// 终止请求</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    ajax.<span class="hljs-title function_">abort</span>()<br>&#125;, <span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure><p><strong>fetch</strong></p><p>fetch需要配合<a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController"><strong>AbortController</strong></a>实例来完成请求的取消</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br><span class="hljs-keyword">let</span> signal = controller.<span class="hljs-property">signal</span>;<br><br><span class="hljs-keyword">const</span> downloadBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.download&#x27;</span>);<br><span class="hljs-keyword">const</span> abortBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.abort&#x27;</span>);<br><br>downloadBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, fetchVideo);<br><br>abortBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  controller.<span class="hljs-title function_">abort</span>();<span class="hljs-comment">// 终止请求</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Download aborted&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchVideo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-title function_">fetch</span>(url, &#123;signal&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    reports.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;Download error: &#x27;</span> + e.<span class="hljs-property">message</span>;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>axios</strong></p><p> 跟fetch有点像，使用CancelToken.source创建一个 <strong>cancel token</strong> 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cancelToken = axios.<span class="hljs-property">CancelToken</span><br><span class="hljs-keyword">const</span> source = cancelToken.<span class="hljs-title function_">source</span>()<br>axios.<span class="hljs-title function_">get</span>(url, &#123;<br>    <span class="hljs-attr">cancelToken</span>: source.<span class="hljs-property">token</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br><br><span class="hljs-comment">// 终止请求</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    source.<span class="hljs-title function_">cancel</span>()<br>&#125;, <span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>AJAX</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueRouter</title>
    <link href="/2022/06/18/%E8%B7%AF%E7%94%B1hash%E5%92%8Chistory/"/>
    <url>/2022/06/18/%E8%B7%AF%E7%94%B1hash%E5%92%8Chistory/</url>
    
    <content type="html"><![CDATA[<h1 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h1><p>路由，vue是单页面应用，通过组件来显示不同的视图，路由就是通过设定路径来控制组件的显示与隐藏，实现页面的跳转与切换。</p><p>一个路由就是一个键值对，键是路径，值是组件。</p><h3 id="VueRouter的作用"><a href="#VueRouter的作用" class="headerlink" title="VueRouter的作用"></a>VueRouter的作用</h3><p>vue的核心概念之一：页面组件化、SPA。</p><p>由于vue是单页面应用，且每个功能模块都可以封装为组件，因此不可能和多页面应用一样直接通过超链接跳转，换句话说只有一个html，还能跳转到哪儿去？那如何让vue可以在一个页面中如何切换不同的组件？<br>这也是vue-router要解决的根本目的：让SPA像多页面应用一样实现跳转。</p><h3 id="vue-router钩子函数"><a href="#vue-router钩子函数" class="headerlink" title="vue-router钩子函数"></a>vue-router钩子函数</h3><p>全局的：beforeEach、beforeResolve、afterEach<br>路由的：beforeEnter<br>组件的：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave<br>参数：to、from、next；正对不同的钩子函数参数有所差异。</p><p>除了afterEach全局后置外，其他的守卫中务必要调用next(),否则无法完成导航<br>还有注意全局前置守卫可以用来进行拦截（登录拦截）</p><h3 id="route和router有什么区别"><a href="#route和router有什么区别" class="headerlink" title="route和router有什么区别"></a><a href="https://www.cnblogs.com/itgezhu/p/12177288.html">route和router有什么区别</a></h3><p><strong>route：代表当前路由信息对象，可以获取到当前路由的信息参数</strong></p><p>$route.fullPath ：完成解析后的url，包含查询参数和hash的完整路径</p><p>$route.path：路径，字符串类型，解析为绝对路径</p><p>$route.hash： 当前路由的hash值（带#号的），如果没有hash值则为空字符串</p><p>$route.name：当前路由的名称，如果有的话（用于命名路由）</p><p>$route.params：一个键值对对象，路由参数</p><p>$route.query：一个键值对对象，表示url查询参数</p><p>$route.matched：一个包含了当前路由的所有嵌套路径片段的路由记录（routes配置数组中的对象副本）</p><p>$route.redirectedFrom：重定向来源的路由的名字，如果存在重定向的话。</p><p><strong>router：代表路由实例的对象，包含了路由的跳转方法，钩子函数等</strong></p><p>属性：</p><p>$router.app ：配置了router的Vue根实例</p><p>$router.mode：路由模式，这里是hash</p><p>$router.currentRoute：当前路由的路由信息对象，包含了当前匹配路由的信息</p><p>方法：</p><p>守卫：router.afterEach()</p><p>路由跳转：router.push( location )router.replace( location )</p><h3 id="路由之间如何跳转"><a href="#路由之间如何跳转" class="headerlink" title="路由之间如何跳转"></a>路由之间如何跳转</h3><p>组件导航<br>router-link router-view</p><p>编程导航<br>router.push<br>router.replace<br>router.go</p><h3 id="vue-router完整的导航解析流程"><a href="#vue-router完整的导航解析流程" class="headerlink" title="vue-router完整的导航解析流程"></a>vue-router完整的导航解析流程</h3><p>1.导航被触发；</p><p>2.在失活的组件里调用beforeRouteLeave守卫；</p><p>3.调用全局beforeEach守卫；</p><p>4.在复用组件里调用beforeRouteUpdate守卫；</p><p>5.调用路由配置里的beforeEnter守卫；</p><p>6.解析异步路由组件；</p><p>7.在被激活的组件里调用beforeRouteEnter守卫；</p><p>8.调用全局beforeResolve守卫；</p><p>9.导航被确认；</p><p>10.调用全局的afterEach钩子；</p><p>11.DOM更新；</p><p>12.用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数。</p><h3 id="从零开始写一个vue路由"><a href="#从零开始写一个vue路由" class="headerlink" title="从零开始写一个vue路由"></a>从零开始写一个vue路由</h3><ol><li>为了方便后期维护，建议独立出一个 router.js 文件</li><li>npm install vue-router</li><li>引入注册</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li>向外暴露出一个router实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    ...<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>动态导入，需要跳转到要用的页面的时候在对该页面进行加载</p><p>1.vue的异步组件：resolve&#x3D;&gt;require([‘需要异步加载的组件’]，resolve)</p><p><strong>2.es6的import方法：</strong></p><p>利用 <strong>箭头函数 和 import</strong> 来实现动态加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 将 import UserDetails from &#x27;./views/UserDetails&#x27; 替换成</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">UserDetails</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./views/UserDetails&#x27;</span>)<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">routes</span>: [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserDetails</span> &#125;],<br>&#125;)<br></code></pre></td></tr></table></figure><p>3.webpack的 require.ensure： r &#x3D;&gt; require.ensure([],()&#x3D;&gt;r( require(需要异步加载的组件))，chunkName)</p><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>在用户访问一个特定的地址时,将其重定向到另一个指定的地址 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/goback&#x27;</span>,<br><span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h3><p>active-class是vue-router模块的router-link组件中的属性，用来做选中样式的切换；</p><h3 id="如何获取路由传过来的参数？"><a href="#如何获取路由传过来的参数？" class="headerlink" title="如何获取路由传过来的参数？"></a><a href="https://github.com/haizlin/fe-interview/issues/379#">如何获取路由传过来的参数？</a></h3><p>如果使用<code>query</code>方式传入的参数使用<code>this.$route.query</code> 接收<br>如果使用<code>params</code>方式传入的参数使用<code>this.$route.params</code>接收</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p>vue-router插件的其中一个组件, 用于跳转路由, 类似于a标签, 它一般也会渲染成a标签, 但是可以通过<code>tag</code>来变更默认渲染元素, 通过<code>to</code>来跳转</p><h3 id="路由有几种模式"><a href="#路由有几种模式" class="headerlink" title="路由有几种模式"></a>路由有几种模式</h3><p>路由配置时，设置 mode，默认为 hash</p><p>前端路由实现的本质是<strong>监听 url 变化</strong>，实现方式有两种：<strong>Hash 模式和 History 模式</strong>，<strong>无需刷新页面就能重新加载相应的页面</strong>。</p><p>Hash url 的格式为<code>www.a.com/#/</code>，当#后的哈希值发生变化时，通过 <strong>hashchange</strong> 事件监听，然后页面跳转。</p><p>History url 通过<code>history.pushState</code>和<code>history.replaceState</code>改变 url。 </p><p>两种模式的区别：</p><ul><li>hash 只能改变#后的值，而 history 模式可以随意设置同源 url；</li><li>hash 只能添加字符串类的数据，而 history 可以通过 API 添加多种类型的数据；</li><li>hash 的历史记录只显示之前的<code>www.a.com</code>而不会显示 hash 值，而 history 的每条记录都会进入到历史记录；</li><li>hash 无需后端配置且兼容性好，而 history 需要配置<code>index.html</code>用于匹配不到资源的情况。</li></ul><h3 id="vue-router怎么配置404页面？"><a href="#vue-router怎么配置404页面？" class="headerlink" title="vue-router怎么配置404页面？"></a>vue-router怎么配置404页面？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123; <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>, <span class="hljs-attr">routes</span>: [ &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">NotFoundComponent</span> &#125; ] &#125;)<br></code></pre></td></tr></table></figure><p>path: ‘*’  注意要放在最后</p><p>*代表全匹配 你放在第一个 不管地址是什么都会 匹配到了 放在最后一个 前面有的就不会匹配到</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收</title>
    <link href="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="为什么需要垃圾回收"><a href="#为什么需要垃圾回收" class="headerlink" title="为什么需要垃圾回收"></a>为什么需要垃圾回收</h2><p>V8引擎已经帮我们自动进行了内存的分配和管理，JS 不需要手动开辟和释放内存。</p><p>存在写代码的过程中不够严谨而容易引发内存泄漏的问题</p><h2 id="V8引擎的内存限制"><a href="#V8引擎的内存限制" class="headerlink" title="V8引擎的内存限制"></a>V8引擎的内存限制</h2><p>JS 是单线程，垃圾回收的过程阻碍了主线程逻辑的执行。会导致主线程的等待时间长，浏览器长时间得不到响应。</p><p>V8引擎直接粗暴的限制了堆内存的大小。在浏览器端一般也不会遇到需要操作几个G内存这样的场景。在node端我们可以手动调整。</p><h2 id="经典垃圾回收策略"><a href="#经典垃圾回收策略" class="headerlink" title="经典垃圾回收策略"></a>经典垃圾回收策略</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数会跟踪每个值被引用的次数，当引用数为0时变量，内存就会被释放。因为存在<strong>循环引用</strong>的问题，所以很少使用这种方法。</p><p>在代码运行时就会自动的增减，因此效率高。</p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>第一个阶段是标记，也就是找垃圾的过程，从根节点出发遍历对象，对所有访问过的对象打上标记，表示对象可达。第二阶段是清除，对那些没有标记的对象进行回收。以下几种情况都可以作为根节点：</p><ol><li>全局对象</li><li>本地函数的局部变量和参数</li><li>当前嵌套调用链上的其他函数的变量和参数</li></ol><p>因为需要暂停下来遍历对象，所以效率相对较低。</p><h2 id="V8的垃圾回收策略"><a href="#V8的垃圾回收策略" class="headerlink" title="V8的垃圾回收策略"></a>V8的垃圾回收策略</h2><h3 id="V8的内存结构"><a href="#V8的内存结构" class="headerlink" title="V8的内存结构"></a>V8的内存结构</h3><p><code>新生代(new_space)</code>：<strong>大多数的对象</strong>（如执行上下文）开始都会被分配在这里，这个<strong>区域相对较小</strong>但是<strong>垃圾回收特别频繁</strong>，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。</p><p><code>老生代(old_space)</code>：<strong>新生代中的对象在存活一段时间后就会被转移到老生代内存区</strong>（如全局变量、自定义类、函数等），相对于新生代该内存区域的垃圾回收频率较低。老生代又分为<code>老生代指针区</code>和<code>老生代数据区</code>，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。</p><p><code>大对象区(large_object_space)</code>：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。</p><p><code>代码区(code_space)</code>：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。</p><p><code>map区(map_space)</code>：存放Cell和Map，每个区域都是存放相同大小的元素，结构简单(这里没有做具体深入的了解，有清楚的小伙伴儿还麻烦解释下)。</p><img src="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/16ee12280b78399dtplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp" class="" title="1620974853612-a480b43e-b3bb-452f-a502-3a0162548a7f"><p>上图中的带斜纹的区域代表暂未使用的内存，新生代(new_space)被划分为了两个部分，其中一部分叫做inactive new space，表示暂未激活的内存区域，另一部分为激活状态。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新生代的垃圾回收过程中主要采用了**<code>Scavenge</code>**算法。</p><p><code>Scavenge</code>算法是一种典型的牺牲空间换取时间的算法，对于老生代内存来说，可能会存储大量对象，如果在老生代中使用这种算法，势必会造成内存资源的浪费，但是在新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。</p><p>在<code>Scavenge</code>算法的具体实现中，主要采用了<code>Cheney</code>算法，它将新生代内存一分为二，每一个部分的空间称为<code>semispace</code>，也就是我们在上图中看见的new_space中划分的两个区域，其中处于激活状态的区域我们称为<code>From</code>空间，未激活(inactive new space)的区域我们称为<code>To</code>空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到<code>From</code>空间，当进行垃圾回收时，如果<code>From</code>空间中尚有存活对象，则会被复制到<code>To</code>空间进行保存，非存活的对象会被自动回收。当复制完成后，<code>From</code>空间和<code>To</code>空间完成一次角色互换，<code>To</code>空间会变为新的<code>From</code>空间，原来的<code>From</code>空间则变为<code>To</code>空间。</p><p><code>Scavenge</code>算法的垃圾回收过程主要就是将存活对象在<code>From</code>空间和<code>To</code>空间之间进行复制，同时完成两个空间之间的角色互换，因此该算法的缺点也比较明显，浪费了一半的内存用于复制。</p><h3 id="对象晋升"><a href="#对象晋升" class="headerlink" title="对象晋升"></a>对象晋升</h3><p>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时（在将对象从<code>From</code>空间复制到<code>To</code>空间之前），该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为<code>晋升</code>。<br> 对象晋升的条件主要有以下两个（满足任意一个则会晋升）：</p><ul><li>对象是否经历过一次<code>Scavenge</code>算法</li><li><code>To</code>空间的内存占比是否已经超过<code>25%</code></li></ul><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><p>在老生代中，因为管理着大量的存活对象，如果依旧使用<code>Scavenge</code>算法的话，很明显会浪费一半的内存，因此已经不再使用<code>Scavenge</code>算法，而是采用新的算法**<code>Mark-Sweep(标记清除)</code>和<code>Mark-Compact(标记整理)</code>**来进行管理。</p><p>标记清除的问题是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现<strong>内存碎片</strong>的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。</p><p>为了解决这种内存碎片的问题，<code>Mark-Compact(标记整理)</code>算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，<strong>回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存</strong>。</p><h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><p>全停顿 <img src="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/153329224-c2120a5d-4f25-4659-9347-d6217d5a5ce8.png" class="" title="1620974853612-a480b43e-b3bb-452f-a502-3a0162548a7f"></p><p>增量标记 <img src="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/153329251-e6a21086-f646-48d5-a23c-c2e3351497ef.png" class="" title="1620975019709-efc33748-fbfc-4fb5-a19d-97abadbf8f97"></p><p>为了减少垃圾回收带来的停顿时间，V8引擎又引入了<strong>Incremental Marking(增量标记)<strong>的概念，即将</strong>原本需要一次性遍历堆内存的操作改为增量标记的方式</strong>，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p><p>得益于增量标记的好处，V8引擎后续继续引入了<strong>延迟清理(lazy sweeping)<strong>和</strong>增量式整理(incremental compaction)<strong>，让清理和整理的过程也变成增量式的。同时为了充分利用多核CPU的性能，也将引入</strong>并行标记</strong>和<strong>并行清理</strong>，进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。</p><h2 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h2><ol><li><strong>尽可能少地创建全局变量</strong></li></ol><p>会无形地挂载到<code>window</code>全局对象上，变成根节点，必须要将其设置为 null 才能回收</p><ol start="2"><li><p><strong>记得手动清除定时器</strong></p></li><li><p><strong>少使用闭包</strong></p></li><li><p><strong>使用弱引用</strong></p></li></ol><p>WeakMap, WeakSet</p><p>弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904016325902344#heading-2">https://juejin.cn/post/6844904016325902344#heading-2</a></p><p><a href="https://www.bilibili.com/video/BV1bP4y1u7GF?spm_id_from=333.337.search-card.all.click&amp;vd_source=1616b746cefe2e7615c229563ba38eb4">https://www.bilibili.com/video/BV1bP4y1u7GF?spm_id_from=333.337.search-card.all.click&amp;vd_source=1616b746cefe2e7615c229563ba38eb4</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>垃圾回收</tag>
      
      <tag>V8引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON</title>
    <link href="/2022/06/17/JSON/"/>
    <url>/2022/06/17/JSON/</url>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h2><p>是一种数据格式，之所以需要这样一种数据格式，是因为前后端的编程语言不同，数据的表示形式也不同，所以需要有这样一种格式来作为桥梁传递数据。</p><h2 id="JSON-和-JS-对象的区别"><a href="#JSON-和-JS-对象的区别" class="headerlink" title="JSON 和 JS 对象的区别"></a>JSON 和 JS 对象的区别</h2><p>JSON和JS有相同的语法，JSON和JS对象也非常的像，但还是有一定区别的，JSON的要求更多一些，区别在于：</p><img src="/2022/06/17/JSON/image-20220701002710162.png" class="" title="image-20220701002710162"><p>在我们前端向后端发送数据时，需要将JS对象转换为一个JSON字符串，可以通过JSON.stringify()这个JS方法来实现，并且提供了一些参数来对转换过程做一些处理。相反，我们收到的后端的数据也是JSON格式，我们需要通过JSON.parse()来将其转化为JS对象之后再使用。</p><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value[, replacer [, space]])<br><span class="hljs-comment">// value: 将要序列化成一个 JSON 字符串的值</span><br></code></pre></td></tr></table></figure><ul><li><strong>转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。</strong></li><li>非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。</li><li>布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。</li><li><strong><code>undefined</code>、任意的函数以及 symbol 值，在序列化过程中会被忽略</strong>（出现在非数组对象的属性值中时）或者被转换成 <code>null</code>（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如<code>JSON.stringify(function()&#123;&#125;)</code> or <code>JSON.stringify(undefined)</code>.</li><li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</li><li>所有以 symbol 为属性键的属性都会被完全忽略掉，即便 <code>replacer</code> 参数中强制指定包含了它们。</li><li>Date 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理。</li><li><strong>NaN 和 Infinity 格式的数值及 null 都会被当做 null。</strong></li><li>其他类型的对象，包括 Map&#x2F;Set&#x2F;WeakMap&#x2F;WeakSet，仅会序列化可枚举的属性。</li></ul><h2 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> oldJson = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">const</span> newJson = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(oldJson));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>terser是如何压缩js代码的</title>
    <link href="/2022/06/17/terser%E6%98%AF%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9js%E4%BB%A3%E7%A0%81%E7%9A%84/"/>
    <url>/2022/06/17/terser%E6%98%AF%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9js%E4%BB%A3%E7%A0%81%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="js代码压缩整体策略"><a href="#js代码压缩整体策略" class="headerlink" title="js代码压缩整体策略"></a>js代码压缩整体策略</h2><p>通过 AST 分析，根据选项配置一些策略，来<strong>生成一颗更小体积的 AST</strong> 并生成代码。</p><h2 id="压缩-AST-的方式"><a href="#压缩-AST-的方式" class="headerlink" title="压缩 AST 的方式"></a>压缩 AST 的方式</h2><p>目前前端工程化中使用 <a href="https://terser.org/docs/api-reference#compress-options">terser</a>和 <a href="https://swc.rs/docs/configuration/minification">swc</a>进行 JS 代码压缩，他们拥有相同的 API。</p><p>常见用以压缩 AST 的几种方案如下:</p><ol><li><strong>去除多余字符: 空格，换行及注释</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (a, b) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span> a+b&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>压缩变量名：变量名，函数名及属性名</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (first, second) &#123;<br>  <span class="hljs-keyword">return</span> first + second;  <br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (x, y) &#123;<br>  <span class="hljs-keyword">return</span> x + y;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>合并声明以及布尔值简化</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>编译预计算</strong></li></ol><p><strong>数学</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ONE_YEAR</span> = <span class="hljs-number">365</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span><br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ONE_YAAR</span> = <span class="hljs-number">31536000</span><br></code></pre></td></tr></table></figure><p><strong>函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span> () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello, world&#x27;</span>)<br>&#125;<br><br><span class="hljs-title function_">hello</span>()<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello, world&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="在-webpack-中开启-js-代码压缩"><a href="#在-webpack-中开启-js-代码压缩" class="headerlink" title="在 webpack 中开启 js 代码压缩"></a>在 webpack 中开启 js 代码压缩</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">mode:</span> <span class="hljs-comment">&#x27;production&#x27;</span><br></code></pre></td></tr></table></figure><p>生产环境会自动压缩 js 代码（会自动使用一些插件，如terser-webpack-plugin）</p><p><code>terser-webpack-plugin</code> 内部封装了 <a href="https://link.zhihu.com/?target=https://github.com/terser/terser">terser</a> 库，用于处理 js 的压缩和混淆，通过 <code>webpack plugin</code> 的方式对代码进行处理</p>]]></content>
    
    
    <categories>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>terser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="/2022/06/14/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/06/14/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="对象的深拷贝与浅拷贝"><a href="#对象的深拷贝与浅拷贝" class="headerlink" title="对象的深拷贝与浅拷贝"></a>对象的深拷贝与浅拷贝</h2><h3 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝"></a>什么是浅拷贝</h3><p><strong>只拷贝了数据对象的第一层，深层次的数据值与原始数据会互相影响（拷贝后的数据与原始数据还存有关联）</strong></p><p>常见浅拷贝的方式：Object.assign()、扩展运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-attr">info</span>: &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> &#125; &#125;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj1)<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1 &#125;<br><br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;cat&#x27;</span><br>obj2.<span class="hljs-property">info</span>.<span class="hljs-property">age</span> = <span class="hljs-number">4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1) <span class="hljs-comment">// &#123; name: &#x27;dog&#x27;, info: &#123; age: 4 &#125; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2) <span class="hljs-comment">// &#123; name: &#x27;cat&#x27;, info: &#123; age: 4 &#125; &#125;</span><br></code></pre></td></tr></table></figure><h3 id="什么是深拷贝"><a href="#什么是深拷贝" class="headerlink" title="什么是深拷贝"></a>什么是深拷贝</h3><p><strong>不管数据对象有多少层，改变拷贝后的值都不会影响原始数据的值。（拷贝后的数据与原始数据毫无关系）</strong></p><p>常见深拷贝的方式：JSON.parse()  和  JSON.stringify()  配合使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-attr">info</span>: &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> &#125;, <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125; &#125;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1))<br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;cat&#x27;</span><br>obj2.<span class="hljs-property">info</span>.<span class="hljs-property">age</span> = <span class="hljs-number">4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1) <span class="hljs-comment">// &#123; name: &#x27;dog&#x27;, info: &#123; age: 3 &#125;, fn: function()&#123;&#125; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2) <span class="hljs-comment">// &#123; name: &#x27;cat&#x27;, info: &#123; age: 4 &#125; &#125;</span><br></code></pre></td></tr></table></figure><p>浅拷贝可以使用  Object.assign 或者<strong>遍历赋值</strong>的方式手动实现。</p><p>深拷贝可以通过JSON.stringify() 与 JSON.parse()实现，但对于对象有要求，因为在遇到函数，undefined，Sybmol，Date对象时会自动忽略，遇到正则时会返回空对象。也可以通过<strong>递归</strong>的方式手动实现深拷贝。</p><h3 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h3><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p><strong>Object.assign()</strong> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历赋值"><a href="#遍历赋值" class="headerlink" title="遍历赋值"></a>遍历赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br>    <br>    <span class="hljs-comment">// Object.keys不会遍历到原型链中的属性</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) &#123;<span class="hljs-comment">// for of 遍历元素值</span><br>cloneObj[key] = obj[key]<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br><br><br><span class="hljs-keyword">let</span> c1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>: &#123;<br>        <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>,<br>        <span class="hljs-attr">e</span>: <span class="hljs-number">5</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> d1 = <span class="hljs-title function_">clone</span>(c1)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c1, d1)<br><br>c1.<span class="hljs-property">c</span>.<span class="hljs-property">d</span> = <span class="hljs-number">12</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c1, d1)<br></code></pre></td></tr></table></figure><h3 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a><a href="https://juejin.cn/post/7072528644739956773#heading-15">深拷贝的实现</a></h3><h4 id="JSON-stringify-与-JSON-parse"><a href="#JSON-stringify-与-JSON-parse" class="headerlink" title="JSON.stringify() 与 JSON.parse()"></a>JSON.stringify() 与 JSON.parse()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：遇到函数，undefined，Sybmol，Date对象时会自动忽略，遇到正则时会返回空对象</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h5 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-comment">// 处理 null date reg 原始类型</span><br>    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj)<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> obj<br><br>    <span class="hljs-comment">// 处理对象和数组</span><br>    <span class="hljs-keyword">const</span> cloneObj = <span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)      <span class="hljs-comment">// 根据对象和数组自动生成</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) &#123;<br>        cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key])<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="稍微复杂版"><a href="#稍微复杂版" class="headerlink" title="稍微复杂版"></a>稍微复杂版</h5><ol><li>解决 symbol 无法作为键的问题</li></ol><p>Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组 等于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</p><ol start="2"><li>解决循环引用问题</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>&#125;<br>obj.<span class="hljs-property">b</span> = obj<br><br><span class="hljs-keyword">const</span> newObj = <span class="hljs-title function_">deepClone</span>(obj)<br></code></pre></td></tr></table></figure><p>报错：栈内存溢出，死循环了。</p><p>因为在递归遍历obj的属性时，obj有属性指向自身，因此会无限循环。</p><p>开辟新内存记录出现过的 obj，如果已经出现过就不再遍历，直接返回。</p><ol start="3"><li>解决垃圾回收问题</li></ol><p>使用 WeakMap，WeakMap是弱引用，不影响垃圾回收（WeakMap键指向的对象的其它引用被清除后，该对象会被垃圾回收）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>    <span class="hljs-comment">// 处理 null date reg 原始类型</span><br>    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj)<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> obj<br><br>    <span class="hljs-comment">// 解决循环引用问题</span><br>    <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj)             <span class="hljs-comment">// 说明 obj 在属性中出现过，再去遍历就会造成循环引用，因此直接返回hash中的记录</span><br><br>    <span class="hljs-comment">// 处理对象和数组</span><br>    <span class="hljs-keyword">const</span> cloneObj = <span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)      <span class="hljs-comment">// 根据对象和数组自动生成</span><br><br>    hash.<span class="hljs-title function_">set</span>(obj, cloneObj)                     <span class="hljs-comment">// 记录出现过的 obj</span><br><br>    <span class="hljs-comment">// Reflect.ownKeys 解决 Symbol 无法作为键的问题</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash)<br>    &#125;)<br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="日常开发"><a href="#日常开发" class="headerlink" title="日常开发"></a>日常开发</h3><p>日常开发中，如果要使用深拷贝，为了兼容各种边界情况，一般是使用三方库如 lodash</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-built_in">npm</span> i --save lodash<br><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span><br><span class="hljs-keyword">const</span> cloneObj = _.cloneDeep(obj)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>深拷贝与浅拷贝</tag>
      
      <tag>手撕代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两栏布局/圣杯布局/双飞翼布局</title>
    <link href="/2022/06/11/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <url>/2022/06/11/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h1><p>HTML 结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-浮动-margin-left"><a href="#1-浮动-margin-left" class="headerlink" title="1.浮动 + margin-left"></a>1.浮动 + margin-left</h2><ol><li>左边元素宽度固定 ，设置浮动。右元素设置 <code>margin-left</code> 。因为右边元素的 <code>width</code> 默认为 <code>auto</code> ，所以会自动撑满父元素。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-绝对定位-margin-left"><a href="#2-绝对定位-margin-left" class="headerlink" title="2.绝对定位 + margin-left"></a>2.绝对定位 + margin-left</h2><p>绝对定位和浮动是一样的都是为了让左元素脱离标准流</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">position</span>: absolute;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-绝对定位-left"><a href="#3-绝对定位-left" class="headerlink" title="3.绝对定位 + left"></a>3.绝对定位 + left</h2><p>与上面不同在于，给右元素浮动定位，设置 left top right bottom（不可省略）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-flex"><a href="#4-flex" class="headerlink" title="4.flex"></a>4.flex</h2><p>左边元素固定宽度，右边的元素设置 <code>flex: 1</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h1><img src="/2022/06/11/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/image-20220122135020616.png" class="" title="image-20220122135020616"><h2 id="float-相对定位"><a href="#float-相对定位" class="headerlink" title="float + 相对定位"></a>float + 相对定位</h2><p>步骤：</p><p>1.设置基本样式</p><p>2.设置父元素container的padding，空出左右元素的位置</p><p>3.设置三个子元素左浮动，清除浮动</p><p>4.设置center的width:100%，单独站一行。此时left和right被挤到第二行</p><p>5.设置left和right的margin-left，将left和right放回第一行</p><p>6.设置<strong>子元素的相对定位</strong>，将left和right移动到合适的位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>头部<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>主区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>底部<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span>, <span class="hljs-selector-tag">footer</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">color</span>: wheat;<br>    <span class="hljs-attribute">text-align</span>: center;     <span class="hljs-comment">/* 水平居中 */</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;           <span class="hljs-comment">/* 盒子高度 */</span><br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">60px</span>;      <span class="hljs-comment">/* line-height是行高; line-height = height 单行文字垂直居中 */</span><br>&#125;<br><br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.center</span>, <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;     <span class="hljs-comment">/* 相对定位，将左右盒子移动到正确的位置 */</span><br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">left</span>: -<span class="hljs-number">200px</span>;           <span class="hljs-comment">/* 将左盒子移动到最左侧 */</span><br>    <span class="hljs-attribute">background-color</span>: green;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;     <span class="hljs-comment">/* 第二行移动到第一行 */</span><br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<span class="hljs-comment">/* 中间能够自适应的原因 */</span><br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">right</span>: -<span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">300px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;   <span class="hljs-comment">/* 空出放左盒子和右盒子的空间(上右下左) */</span><br>&#125;<br><br><span class="hljs-comment">/* 清除浮动，不然container盒子高度会变0 */</span><br><span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>步骤：</p><p>1.设置基本样式</p><p>2.给父元素container设置display:flex。三个div子元素会排列到一行</p><p>3.给center设置flex:1。会分配所有剩余的空间（一行中去除左右盒子的部分，也就实现了自适应）</p><p>4.给left设置order:-1，将其排到最左侧。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span>, <span class="hljs-selector-tag">footer</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">color</span>: wheat;<br>    <span class="hljs-attribute">text-align</span>: center;     <span class="hljs-comment">/* 水平居中 */</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;           <span class="hljs-comment">/* 盒子高度 */</span><br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">60px</span>;      <span class="hljs-comment">/* line-height是行高; line-height = height 单行文字垂直居中 */</span><br>&#125;<br><br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.center</span>, <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;        <span class="hljs-comment">/* 分配所有剩余的空间 */</span><br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: green;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;      <span class="hljs-comment">/* 数值越小排列越前 */</span><br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h1><p>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决 “中间栏div内容不被遮挡”问题的思路不一样。圣杯布局是利用了相对定位。</p><p>而双飞翼布局没有给父盒子加padding，而是给中间子盒子里面的内容套了层div，再给div加padding，这样左右两个盒子就会自己在最左侧和最右侧，而不需要再定位过去了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>头部<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>主区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 包裹一层div --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>底部<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span>, <span class="hljs-selector-tag">footer</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">color</span>: wheat;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">60px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.center</span>, <span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-comment">/* 不需要相对定位了 */</span><br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: green;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.content</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">300px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;   <span class="hljs-comment">/* 不是父盒子padding，而是center内容的div加padding */</span><br>&#125;<br><br><span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2022/06/10/Promise/"/>
    <url>/2022/06/10/Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Promise 是 JS 中进行异步编程的新解决方案（旧方案是单纯使用回调函数）</p><p>从语法上来说: Promise 是一个<strong>构造函数</strong></p><p>从功能上来说: promise 对象用来<strong>封装一个异步操作并可以获取其成功&#x2F;失败的结果值</strong></p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>pending</p><p>resolved&#x2F;fulfilled</p><p>rejected</p><p>无论变为成功还是失败, 都会有一个结果数据</p><p>成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><img src="/2022/06/10/Promise/image-20220610202339657.png" class="" title="image-20220610202339657"><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li><p><strong>指定回调函数更加灵活</strong>，原先需要在异步任务前指定。如今异步任务在new时写入，成功&#x2F;失败回调在then中绑定</p></li><li><p>支持<strong>链式调用</strong>，解决<strong>回调地狱</strong>问题</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.创建一个Promise实例</span><br><span class="hljs-comment">//2.Promise构造函数接收一个函数作为参数，函数的两个参数分别是resolve和reject。它们均是函数</span><br><span class="hljs-keyword">const</span> promise=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>     <span class="hljs-keyword">if</span>(操作是否成功)&#123;<br>          <span class="hljs-title function_">resolve</span>(value)<br>          <span class="hljs-comment">//3.当异步操作成功时，调用resolve()。状态发生改变（pending-&gt;fulfilled），并将结果作为参数传递出去</span><br>     &#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-title function_">reject</span>(error)<br>         <span class="hljs-comment">//4.当异步操作失败是，调用reject()。状态发生改变（pending-&gt;rejected），并将错误作为参数传递出去</span><br>     &#125;<br>&#125;)<br><span class="hljs-comment">//5.可以使用then方法指定resolved状态和rejected状态的回调函数.then方法接收两个回调函数作为参数（这俩个函数都是可选的）</span><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-comment">//6.状态变为resolved(在这里统一只指`fulfilled`状态)时调用，可使用传出的value</span><br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;<br>   <span class="hljs-comment">// 7.状态变为rejected时调用，可使用传出的error</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="手写API"><a href="#手写API" class="headerlink" title="手写API"></a>手写API</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><ol><li>Promise.all()接受一个promise的iterable类型</li><li>只有数组中全部的 Promise 都变为 resolve 的时候，返回一个成果结果的数组</li><li>只要有一个失败，状态就变成 rejected，将失败的那个结果给失败状态的回调函数</li></ol><p><strong>使用例子</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 全部resolve, 输出数组</span><br><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);<br>&#125;);<br><span class="hljs-comment">// expected output: Array [3, 42, &quot;foo&quot;]</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<span class="hljs-params">values</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> results = [];<span class="hljs-comment">// 结果数组</span><br>        <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">processData</span> = (<span class="hljs-params">value, index</span>) =&gt; &#123;<br>            results[index] = value;<br>            <span class="hljs-comment">// 当成功的个数 和 当前的参数个数相等就把结果抛出去</span><br>            <span class="hljs-keyword">if</span>(++i === value.<span class="hljs-property">length</span>) &#123;<br>                <span class="hljs-title function_">resolve</span>(results);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = values[i]<br>            <span class="hljs-comment">// 判断是否为 promise</span><br>            <span class="hljs-keyword">if</span> (current <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                current.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> <span class="hljs-title function_">processData</span>(y, i), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">reject</span>(err))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">processData</span>(current, i)<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;one&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;two&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1, promise2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>  <span class="hljs-comment">// Both resolve, but promise2 is faster</span><br>&#125;);<br><span class="hljs-comment">// expected output: &quot;two&quot;</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(<span class="hljs-params">values</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = values[i]<br>            <span class="hljs-keyword">if</span> (current <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                current.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(res), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">reject</span>(err))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(current)<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>Promise.allSettled() 可用于并行执行独立的异步操作，并收集这些操作的结果。</p><p>该函数接受一个 promise 数组(通常是一个可迭代对象)作为参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> statusesPromise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises);<br></code></pre></td></tr></table></figure><p>当所有的输入 <code>promises</code> 都被 <code>fulfilled</code> 或 <code>rejected</code> 时，<code>statusesPromise</code> 会解析为一个具有它们状态的数组</p><ol><li><code>&#123; status: &#39;fulfilled&#39;, value: value &#125;</code> — 如果对应的 promise 已经 <code>fulfilled</code></li><li>或者 <code>&#123;status: &#39;rejected&#39;， reason: reason&#125;</code> 如果相应的 promise 已经被 <code>rejected</code></li></ol><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(reject, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>));<br><span class="hljs-keyword">const</span> promises = [promise1, promise2];<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises).<br>  <span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">status</span>)));<br><br><span class="hljs-comment">// expected output:</span><br><span class="hljs-comment">// &quot;fulfilled&quot;</span><br><span class="hljs-comment">// &quot;rejected&quot;</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(<span class="hljs-params">values</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> res = []<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">addData</span> = (<span class="hljs-params">status, value, i</span>) =&gt; &#123;<br>            res[i] = &#123;<br>                status,<br>                value<br>            &#125;<br>            count++<br>            <span class="hljs-keyword">if</span> (count === values.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(res)<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = values[i]<br>            <span class="hljs-keyword">if</span> (current <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                current.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, res, i), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>, err, i))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, current, i)<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><ul><li>如果有一个Promise成功，则返回这个成功结果</li><li>如果所有Promise都失败，则报错</li></ul><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);<br>&#125;);<br><span class="hljs-comment">// expected output: Array [3, 42, &quot;foo&quot;]</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>(<span class="hljs-params">values</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = values[i]<br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(val), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                count++<br>                <span class="hljs-keyword">if</span> (count === values.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>))<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-控制并发数"><a href="#Promise-控制并发数" class="headerlink" title="Promise 控制并发数"></a>Promise 控制并发数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// values 是数组</span><br><span class="hljs-comment">// iteratorFn 是每个 promise 需要执行的异步操作。</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncPool</span>(<span class="hljs-params">values, limit, iteratorFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = []          <span class="hljs-comment">// 存放所有 promise 实例</span><br>    <span class="hljs-keyword">const</span> executing = []    <span class="hljs-comment">// 存放目前正在执行的 promise</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> values) &#123;<br>        <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">iteratorFn</span>(item))     <span class="hljs-comment">// 异步操作应当返回 promise, 包裹一层 Promise.resolve 避免返回的不是 promise</span><br>        res.<span class="hljs-title function_">push</span>(p)<br>        <span class="hljs-keyword">if</span> (limit &lt;= values.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">const</span> e = p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> executing.<span class="hljs-title function_">splice</span>(executing.<span class="hljs-title function_">indexOf</span>(e), <span class="hljs-number">1</span>))   <span class="hljs-comment">// 当这个promise状态变为fulfilled后，将其从正在执行的promise列表executing中删除</span><br>            executing.<span class="hljs-title function_">push</span>(e)<br>            <span class="hljs-keyword">if</span> (executing.<span class="hljs-property">length</span> &gt;= limit) &#123;<br>                <span class="hljs-comment">// 一旦正在执行的promise列表数量等于限制数，就使用Promise.race等待某一个promise状态发生变更，</span><br>                <span class="hljs-comment">// 状态变更后，就会执行上面then的回调，将该promise从executing中删除，</span><br>                <span class="hljs-comment">// 然后再进入到下一次for循环，生成新的promise进行补充</span><br>                <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(executing)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(res)<br>&#125;<br><br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">timeout</span> = (<span class="hljs-params">i</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;开始&#x27;</span>, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(i);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;结束&#x27;</span>, i);<br>    &#125;, i));<br>&#125;;<br><br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncPool</span>(<span class="hljs-number">2</span>, [<span class="hljs-number">1000</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">2000</span>], timeout);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异步编程</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入URL后浏览器发生了什么变化</title>
    <link href="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/"/>
    <url>/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="输入-url-后浏览器发生了什么变化"><a href="#输入-url-后浏览器发生了什么变化" class="headerlink" title="输入 url 后浏览器发生了什么变化"></a>输入 url 后浏览器发生了什么变化</h1><h2 id="步骤简单总结"><a href="#步骤简单总结" class="headerlink" title="步骤简单总结"></a>步骤简单总结</h2><ul><li><p><strong>网络请求</strong></p></li><li><ul><li><strong>DNS</strong> 查询（得到 IP），建立 TCP 连接（三次握手）</li><li>浏览器发送 HTTP 请求</li><li>收到请求响应，得到 HTML（解析 HTML 过程中，遇到静态资源还会继续发起网络请求）</li></ul></li><li><p><strong>解析</strong>（字符串 -&gt; 结构化数据）</p></li><li><ul><li>HTML 构建 <strong>DOM</strong> 树</li><li>CSS 构建 <strong>CSSOM</strong> 树</li><li>两者结合形成 <strong>render</strong> tree</li></ul></li><li><p><strong>渲染</strong></p></li><li><ul><li><strong>layout</strong> 计算布局：（文档流， 盒模型， 计算各个元素的大小、位置）</li><li><strong>paint</strong> 绘制：（将边框颜色、文字颜色、阴影等都画出来）</li><li>composite 合成：根据层叠关系显示画面</li><li>遇到 JS 执行</li><li>异步 CSS，图片加载，可能会触发重新渲染</li></ul></li></ul><h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>通过域名查找 IP 地址</p><h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><p>递归实现</p><p>先在<strong>本地计算机缓存</strong>查找，找不到再将请求发送给 dns 服务器</p><p>在<strong>本地 dns 服务器</strong>找</p><p>再到<strong>根域名服务器</strong>找</p><p>再到<strong>顶级域名服务器</strong>找</p><p>以 <a href="http://www.google.com/">www.google.com</a> 为例：</p><p>. -&gt; .com -&gt; google.com. -&gt; <a href="http://www.google.com/">www.google.com</a></p><h3 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h3><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>DNS缓存指DNS返回了正确的IP之后，系统就会将这个结果临时储存起来。并且它会为缓存设定一个失效时间 (例如N小时)，在这N小时之内，当你再次访问这个网站时，系统就会直接从你<strong>电脑本地的DNS缓存</strong>中把结果交还给你，而<strong>不必再去询问DNS服务器</strong>，变相“加速”了网址的解析。</p><h4 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h4><p>你访问大公司域名的时候，每次响应的并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问。DNS可以返回一个<strong>合适的机器的IP</strong>给用户，例如可以根据每台<strong>机器的负载量</strong>，该机器离用户<strong>地理位置</strong>的距离等等，这种过程就是DNS负载均衡。</p><h2 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>在 TCP&#x2F;IP 协议中，TCP 协议提供可靠的连接服务，采用三次握手建立一个连接。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/20150603155505255.png" class="" title="img"> <p><strong>第一次握手</strong>：建立连接时，客户端发送 syn 包(syn&#x3D;j)到服务器，并进入 SYN_SEND 状态，等待服务器确认； </p><p><strong>第二次握手</strong>：服务器收到 syn 包，必须确认客户的 SYN（ack&#x3D;j+1），同时自己也发送一个 SYN 包（syn&#x3D;k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；<br><strong>第三次握手</strong>：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack&#x3D;k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/20150511164615901.jpeg" class="" title="img"> <p>通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。 <strong>三次握手的最主要目的是保证连接是双工的，可靠更多的是通过重传机制来保证的。</strong></p><p><strong>为什么是三次？</strong></p><p>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。 </p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。</p><p>那TCP 的四次握手，<strong>是为了保证通信双方都关闭了连接</strong>，具体过程如下：</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/20150603155803953.png" class="" title="img"> <p>1）客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送；<br>2）服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号；<br>3）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A；<br>4）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。</p><p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p><p>这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。<strong>但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了，但是你还可以给对方发送数据，也有这么种可能，你还有一些数据在传给对方的途中，所以你不能立马关闭连接</strong>,也即你可能还需要把在传输途中的数据给对方之后，又或者，你还有一些数据需要传输给对方后，（再关闭连接）再发送FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p><h3 id="TCP-x2F-UDP-的区别"><a href="#TCP-x2F-UDP-的区别" class="headerlink" title="TCP&#x2F;UDP 的区别"></a>TCP&#x2F;UDP 的区别</h3><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接，是指发送数据之前必须在两端建立TCP连接，连接方式为三次握手（打电话）</td><td>不面向连接（写信）</td></tr><tr><td>可靠传输，流量控制与拥塞控制</td><td>不可靠传输，尽最大努力交付</td></tr><tr><td>传输方式上以字节流的形式传输</td><td>以报文形式传输</td></tr><tr><td>只能是一对一通信</td><td>支持一对一、一对多、多对多、多对一交互通信</td></tr><tr><td>最小20字节，最多60字节</td><td>首部开销较小，只有 8 字节</td></tr><tr><td>适用于要求<strong>可靠传输</strong>的应用（传文件）</td><td><strong>适用于实时应用，如视频会议、直播等</strong>（丢几帧无所谓）</td></tr></tbody></table><p><strong>DNS使用什么协议传输？为什么？</strong></p><p>-  UDP 机制简单 开销小 性能更好</p><h2 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h2><h3 id="1-HTTP报文结构"><a href="#1-HTTP报文结构" class="headerlink" title="1. HTTP报文结构"></a>1. HTTP报文结构</h3><p>HTTP报文由<strong>报文首部</strong>和<strong>报文主体</strong>构成，中间由一个<strong>空行分隔</strong>。<strong>报文首部包含请求行和请求头部</strong>，报文主体主要包含被发送的信息。</p><p>报文首部是客户端或服务端需要处理请求或响应的内容及属性，可以传递额外的信息。</p><p>一个HTTP报文示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.enjoytoday.cn<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36<br>Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://www.enjoytoday.cn/posts/326<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, sdch<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8<br><br><span class="language-ini"><span class="hljs-attr">username</span>=hfcai&amp;sex=man</span><br></code></pre></td></tr></table></figure><h4 id="1-1-请求报文"><a href="#1-1-请求报文" class="headerlink" title="1-1. 请求报文"></a>1-1. 请求报文</h4><p>一个HTTP请求报文由<strong>请求行，请求头部，空行和请求数据</strong>4部分组成。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/278526F9CD532C9C14FBF3ADB9A2A930.png" class="" title="图片说明"> <p>请求行：三部分组成，方法 + URI + HTTP版本</p><p>请求头部：首部字段名和字段值构成，中间用 : 分隔。首部字段格式： 首部字段名:字段值</p><h4 id="1-2-响应报文"><a href="#1-2-响应报文" class="headerlink" title="1-2. 响应报文"></a>1-2. 响应报文</h4><p>HTTP响应报文由<strong>状态行、响应头部、空行和响应体</strong>4部分组成</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/FB5C81ED3A220004B71069645F112867.png" class="" title="图片说明"> <p>状态行：HTTP版本 + 状态码 + 响应短语</p><h3 id="2-HTTP首部字段"><a href="#2-HTTP首部字段" class="headerlink" title="2. HTTP首部字段"></a>2. HTTP首部字段</h3><p>给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等</p><h4 id="2-1-HTTP通用首部字段"><a href="#2-1-HTTP通用首部字段" class="headerlink" title="2-1. HTTP通用首部字段"></a>2-1. HTTP通用首部字段</h4><p>通用首部字段是请求报文和响应报文都会使用的字段，例如：</p><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td><strong>Date</strong></td><td>有</td><td></td><td>表示请求和响应生成的日期，GTM时间。例如 <code>Tue, 02 Mar 2021 12:31:25 GMT</code></td></tr><tr><td>Pragma</td><td>有</td><td></td><td>表示数据是否允许被缓存的通信选项</td></tr><tr><td><strong>Cache-Control</strong></td><td></td><td>有</td><td>控制缓存的相关信息<br />no-store表示不缓存<br />no-cache表示不缓存过期的资源</td></tr><tr><td><strong>Connection</strong></td><td></td><td>有</td><td>设置发送响应之后 TCP 连接是否继续保持<br />http1.1前需如下所示手动设置 Connection: Keep-Alive<br /><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606145754409.png" class="" title="img"></td></tr><tr><td>Transfer-Encoding</td><td></td><td>有</td><td>表示消息主体的编码格式</td></tr><tr><td>Via</td><td></td><td>有</td><td>记录途中经过的代理和网关</td></tr></tbody></table><h4 id="2-2-HTTP请求首部字段"><a href="#2-2-HTTP请求首部字段" class="headerlink" title="2-2. HTTP请求首部字段"></a>2-2. HTTP请求首部字段</h4><p>补充请求的附加信息、客户端信息、对相应内容相关的优先级</p><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td><strong>Host</strong></td><td></td><td>有</td><td>接受请求的服务器IP地址和端口号</td></tr><tr><td><strong>Accept</strong></td><td>有</td><td>有</td><td>客户端可支持的数据类型<br /><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606151327313.png" class="" title="img"><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606151859848-16548294901661.png" class="" title="img"></td></tr><tr><td>User-Agent</td><td>有</td><td>有</td><td></td></tr><tr><td><strong>If-Modified-Since</strong></td><td>有</td><td>有</td><td>UMT时间，表示该时间之后资源是否修改<br /><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606154802921.png" class="" title="img"></td></tr><tr><td><strong>If-None-Match</strong></td><td></td><td>有</td><td>返回服务器响应头的 Etag 值</td></tr><tr><td>Referer</td><td>有</td><td>有</td><td>通过点击超链接进入下一个页面时，在这里会记录上一个页面的 URI</td></tr><tr><td>Accept-Encoding</td><td>有</td><td>有</td><td>客户端可支持的编码格式<br />gzip&#x2F;compress&#x2F;deflate&#x2F;identify</td></tr><tr><td>Accept-Language</td><td>有</td><td>有</td><td>客户端可支持的语言（中文&#x2F;英文）</td></tr><tr><td><strong>If-Match</strong></td><td></td><td>有</td><td>If-xxx 条件请求  判断为真时，服务器才会执行请求<br />If-Match 和 ETag 值一致时，服务器才会接受请求</td></tr><tr><td>If-Unmodified-Since</td><td></td><td>有</td><td></td></tr><tr><td>Range</td><td></td><td>有</td><td>当只需要回去部分数据时，可通过这个字段指定要获取的数据范围</td></tr><tr><td>Authorization</td><td></td><td></td><td><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606152828630.png" class="" title="img"></td></tr></tbody></table><h4 id="2-3-HTTP响应首部字段"><a href="#2-3-HTTP响应首部字段" class="headerlink" title="2-3. HTTP响应首部字段"></a>2-3. HTTP响应首部字段</h4><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td>Location</td><td>有</td><td>有</td><td>令客户端重定向至URI，绝对路径</td></tr><tr><td>Server</td><td>有</td><td>有</td><td>服务器程序的名称和版本号相关信息</td></tr></tbody></table><h4 id="2-4-HTTP实体（消息体）首部字段"><a href="#2-4-HTTP实体（消息体）首部字段" class="headerlink" title="2-4. HTTP实体（消息体）首部字段"></a>2-4. HTTP实体（消息体）首部字段</h4><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td>Allow</td><td>有</td><td>有</td><td>表示指定的 URI 支持的方法</td></tr><tr><td>Content-Encoding</td><td>有</td><td>有</td><td>消息的编码格式</td></tr><tr><td>Content-Length</td><td>有</td><td>有</td><td>消息体的长度</td></tr><tr><td>Content-Type</td><td>有</td><td>有</td><td>消息体的数据类型</td></tr><tr><td><strong>Expires</strong></td><td>有</td><td>有</td><td>消息体的有效期，UMT 时间</td></tr><tr><td><strong>Last-Modified</strong></td><td>有</td><td>有</td><td>数据最后更新的日期</td></tr><tr><td><strong>Etag</strong></td><td></td><td>有</td><td>资源的唯一标识符，控制是否使用缓存</td></tr></tbody></table><h3 id="3-HTTP方法"><a href="#3-HTTP方法" class="headerlink" title="3. HTTP方法"></a>3. HTTP方法</h3><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p><p>HTTP1.0 定义了三种请求方法：GET、POST 和 HEAD 方法</p><p>HTTP1.1 新增了六种方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>用于从服务器获取数据</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过响应中没有具体的内容，<strong>用户获取报头</strong></td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求。数据被包含在请求体中，POST请求可能导致新的资源的建立或已有资源的修改</td></tr><tr><td>PUT</td><td>客户端向服务器传送的数据取代指定的文档内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的资源</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>CONNECT</td><td>HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606122333035.png" class="" title="img"><p><strong>GET与POST方法的区别：</strong></p><ol><li>get 是从指定的资源请求数据，post 是向指定的资源提交要处理的数据 </li><li>get 请求可以被缓存，post 请求不会被缓存 </li><li>get 请求传输的数据有长度限制，一般为 2048 字符，post 请求传输的数据没有大小限制 </li><li>get 请求的数据一般追加在 URL 的末尾，post 请求的数据在 http 请求体中</li></ol><p>一般不使用 GET 请求发送如密码这样的敏感信息。我认为 post 请求比 get请求更安全。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>304状态码是在协商缓存，缓存命中的时候服务器返回的，告诉客户端，服务器资源没有修改，可以使用客户端自己的缓存。</p><p>浏览器缓存分<strong>为本地缓存（强缓存）和协商缓存（弱缓存）</strong>。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/57B66CA5C634CC9645E63287A8BA90AC.png" class="" title="图片说明"> <p><strong>如上图所示，在浏览器第一次发出请求之后，需要再次发送请求的时候，浏览器首先获取该资源缓存的 header 信息，然后根据 Cache-Control 和 Expires 字段判断缓存是否过期。如果没有过期，直接使用浏览器缓存，并不会与服务器通信。该过程为判断是否使用强缓存，即本地缓存。</strong></p><ol><li><p><strong>Cache-Control</strong></p><p><strong>设置是否缓存与缓存时间等</strong>，通用字段，请求头和响应头中都有</p><p>该字段是 HTTP1.1 规范，一般利用该字段的 <strong>max-age</strong> 属性来判断，这个值是一个<strong>相对时间</strong>，单位为 s，代表资源的有效期。例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">Cache-Control:max-age=3600<br></code></pre></td></tr></table></figure><p>除此之外还有几个常用的值：</p><ul><li>no-cache：表示<strong>不使用强缓存</strong>，需要使用协商缓存 </li><li>no-store：禁止<strong>浏览器缓存数据</strong>，每次请求下载完整的资源 </li><li>public：可以被所有用户缓存，包括终端用户和中间代理服务器 </li><li>private：只能被终端用户的浏览器缓存</li></ul></li><li><p><strong>Expires</strong></p><p>该字段是 HTTP1.0 规范，他是一个<strong>绝对时间</strong>的 GMT 格式的时间字符串。例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">expires:Mar, 06 Apr 2020 10:57:09 GMT<br></code></pre></td></tr></table></figure><p>这个时间代表资源的失效时间，只要发送请求的时间在这之前，都会使用强缓存。</p><p>由于失效时间是一个绝对时间，因此当<strong>服务器时间与客户端时间偏差较大时，就会导致缓存混乱</strong>。</p></li></ol><p><strong>如果缓存过期，浏览器会向服务器发送请求，即 使用协商缓存。本次请求会带着第一次请求返回的有关缓存的 header 字段信息，比如以下两个字段：</strong>最后更新时间（<code>last-modified</code>）和文件标识（<code>ETag</code>）</p><p><strong>Etag&#x2F;If-None-Match</strong></p><p>判断响应头中是否存在 Etag 字段，如果存在，浏览器则发送一个带有 If-None-Match 字段的请求头的请求，该字段的值为 Etag 值。服务器通过对比客户端发过来的Etag值是否与服务器相同。如果相同，说明缓存命中，服务器返回 304 状态码，并将 If-None-Match 设为 false，客户端继续使用本地缓存。如果不相同，说明缓存未命中，服务器返回 200 状态码，并将 If-None-Match 设为 true，并且返回请求的数据。</p><p><strong>Last-Modified</strong>&#x2F;If-Modified-Since</p><p>除了 Etag 字段之外，客户端还会通过服务器返回的 Last-Modified 字段判断是否继续使用缓存，该字段为服务器返回的资源的最后修改时间，为UMT时间。浏览器发送一个带有 If-Modified-Since 字段的请求头的请求给服务器，该字段的值为 Last-Modified 值。服务器收到之后，通过这个时间判断，在该时间之后，资源有无修改，如果未修改，缓存命中，返回 304 状态码；如果未命中，返回 200 状态码，并返回最新的内容。</p><p>Etag和Last-Modified是服务器响应头里的；请求头里会加上If-None-Match和If-Modified-Since给服务器用于判断是否采用协商缓存</p><p><strong>Cache-Control 与 Expires 的优先级：</strong></p><p>两者可以在服务端配置同时使用，<strong>Cache-Control 的优先级高于 Expires。</strong></p><p><strong>Last-Modified&#x2F;If-Modified-Since 已经可以判断缓存是否失效了，为什么出现 Etag&#x2F;If-None-Match?</strong></p><p>Etag&#x2F;If-None-Match 是实体标签，是一个资源的唯一标识符，资源的变化都会导致 ETag 的变化。出现 Etag 的主要原因是解决 Last-Modified 比较难解决的问题：</p><ul><li>一些文件也许会周期性的修改，但是他的内容并不发生改变，这个时候我们并不希望客户端认为这个文件修改了 </li><li>某些文件在秒以下的时间内进行修改了，If-Modified-Since无法判断。UNIX时间只能精确到秒</li></ul><p>Last-Modified 和 Etag 可以一起使用， <strong>Etag 的优先级更高</strong>。</p><p><strong>E-tag 的缺点</strong></p><p>服务器需要计算Etag，会有性能损失</p><p>不同操作系统，web服务器对于ETag的计算方法也不同，当使用不同操作系统，不同类型的web服务器做负载均衡的时候，如果用ETag作为判断条件，在被负载均衡到不同服务器后，则很容易导致缓存失效。</p><p><strong>刷新页面的问题：</strong></p><p>F5刷新：不使用强缓存，使用协商缓存</p><p>ctrl+F5：二者都不使用</p><h2 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h2><h3 id="浏览器渲染步骤"><a href="#浏览器渲染步骤" class="headerlink" title="浏览器渲染步骤"></a>浏览器渲染步骤</h3><p> （1）首先解析收到的文档（HTML文件），根据文档定义<strong>构建一棵 DOM 树</strong>，DOM 树是由 DOM 元素及属性节点组成的。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115170857468.png" class="" title="img"><p> （2）然后对 CSS 进行解析，<strong>生成 CSSOM 规则树</strong>。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171024474.png" class="" title="img"><p> （3）根据 DOM 树和 CSSOM 规则树<strong>构建渲染树</strong>。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171208070.png" class="" title="img"><p> （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会<strong>根据渲染树来进行布局</strong>（也可以叫做<strong>回流</strong>）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171453541.png" class="" title="img"><p> （5）<strong>布局阶段结束后是绘制阶段</strong>，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</p><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是<strong>解析完一部分内容就显示一部分内容</strong>，同时，可能还在通过网络下载其余内容。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171612862.png" class="" title="img"><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><h4 id="阻塞关系"><a href="#阻塞关系" class="headerlink" title="阻塞关系"></a>阻塞关系</h4><ul><li><p>CSS </p></li><li><ul><li><strong>CSS 不会阻塞 HTML 的解析</strong>，解析 HTML 和解析 CSS 是并行的；</li><li>页面渲染依照 CSS Tree +DOM Tree 合成 Render Tree，因此 <strong>CSS 会阻塞页面的渲染</strong></li><li><strong>CSS 下载解析会阻塞 JS 执行</strong>，JS 需要读取 CSS 的结果</li></ul></li><li><p><strong>JS 会阻塞 HTML 解析</strong>：</p></li><li><ul><li>JS 可能会修改 DOM，需要阻塞 HTML 的解析</li><li>JS 执行线程是单独的线程，和浏览器解析渲染线程互斥</li></ul></li></ul><p>解析页面过程中如果遇到一个 script 标签，会停止 HTML 解析，去下载 script 脚本，下载完毕之后立即执行脚本，然后接着解析 HTML，所以如果 script 下载速度很慢，会造成页面<strong>白屏</strong>。因此我们常常<strong>把 script 标签放到 body 底部</strong>。当然在当下，并不是说 script 标签必须放在底部，因为你可以<strong>给 script 标签添加 defer 或者 async 属性</strong>。</p><h4 id="async-和-defer-的作用是什么？有什么区别？"><a href="#async-和-defer-的作用是什么？有什么区别？" class="headerlink" title="async 和 defer 的作用是什么？有什么区别？"></a><strong>async 和 defer 的作用是什么？有什么区别？</strong></h4><p>script ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</p><p>async script ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</p><p>defer script ：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220611161332407.png" class=""><h3 id="渲染页面时常见哪些不良现象？"><a href="#渲染页面时常见哪些不良现象？" class="headerlink" title="渲染页面时常见哪些不良现象？"></a>渲染页面时常见哪些不良现象？</h3><p>FOUC：主要指的是<strong>样式闪烁</strong>的问题，由于浏览器渲染机制（比如firefox），<strong>在 CSS 加载之前，先呈现了 HTML</strong>，就会导致展示出<strong>无样式</strong>内容，然后<strong>样式突然呈现</strong>的现象。会出现这个问题的原因主要是 <strong>css 加载时间过长，或者 css 被放在了文档底部</strong>。</p><p><strong>白屏</strong>：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 <strong>CSS 部分放在 HTML 尾部</strong>，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 <strong>js 文件放在头部</strong>，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</p><h3 id="浏览器的绘制过程"><a href="#浏览器的绘制过程" class="headerlink" title="浏览器的绘制过程"></a>浏览器的绘制过程</h3><h4 id="什么是重绘和回流（重拍）？"><a href="#什么是重绘和回流（重拍）？" class="headerlink" title="什么是重绘和回流（重拍）？"></a>什么是重绘和回流（重拍）？</h4><p><strong>重绘</strong>: 当渲染树中的一些元素需要更新属性，而这些属性<strong>只是影响元素的外观、风格，而不会影响布局</strong>的操作，比如 background-color，我们将这样的操作称为重绘。</p><p><strong>回流</strong>：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会<strong>影响到布局的操作</strong>，这样<br>的操作我们称为回流。</p><p><strong>常见引起回流属性和方法：</strong></p><p><strong>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</strong></p><p> （1）添加或者删除可见的 DOM 元素；<br> （2）元素尺寸改变——边距、填充、边框、宽度和高度<br> （3）内容变化，比如用户在 input 框中输入文字<br> （4）浏览器窗口尺寸改变——resize事件发生时<br> （5）计算 offsetWidth 和 offsetHeight 属性<br> （6）设置 style 属性的值<br> （7）当你修改网页的默认字体时。</p><p><strong>回流必定会发生重绘，重绘不一定会引发回流</strong>。回流的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><p><strong>常见引起重绘属性和方法：</strong></p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/68747470733a2f2f636176737a686f75796f752d313235343039333639372e636f732e61702d63686f6e6771696e672e6d7971636c6f75642e636f6d2f6e6f74652d31342e706e67.png" class="" title="常见引起回流属性和方法"><p><strong>常见引起回流属性和方法：</strong></p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/68747470733a2f2f636176737a686f75796f752d313235343039333639372e636f732e61702d63686f6e6771696e672e6d7971636c6f75642e636f6d2f6e6f74652d31332e706e67.png" class="" title="常见引起重绘属性和方法"><h4 id="如何减少回流？"><a href="#如何减少回流？" class="headerlink" title="如何减少回流？"></a>如何减少回流？</h4><ol><li><p><strong>最小化重绘和重排</strong>，比如<strong>样式集中改变</strong>，使用添加新样式类名 <code>.class</code> 或 <code>cssText</code> 。</p></li><li><p><strong>批量操作 DOM</strong>，比如读取某元素 <code>offsetWidth</code> 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。</p></li><li><p><strong>使用  absolute 或 fixed 使元素脱离文档流</strong>，这在制作复杂的动画时对性能的影响比较明显。</p></li><li><p><strong>开启 GPU 加速</strong>，利用 css 属性 <code>transform</code> 、<code>will-change</code> 等，比如改变元素位置，我们使用 <code>translate</code> 会比使用绝对定位改变其 <code>left</code> 、<code>top</code> 等来的高效，因为它不会触发重排或重绘，<code>transform</code> 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。</p></li><li><p><strong>opacity替代visibility</strong>： 前者回流重绘都不会触发(前提是它单独在一个图层)，后者两个都会触发。</p></li></ol><h4 id="为什么操作-DOM-慢？"><a href="#为什么操作-DOM-慢？" class="headerlink" title="为什么操作 DOM 慢？"></a>为什么操作 DOM 慢？</h4><p>一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</p><p>DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。</p><h2 id="JS-解析"><a href="#JS-解析" class="headerlink" title="JS 解析"></a>JS 解析</h2><p>事件循环，放在 JS 部分里</p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>DNS</tag>
      
      <tag>TCP/UDP</tag>
      
      <tag>缓存</tag>
      
      <tag>浏览器解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
