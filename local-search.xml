<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>continue跳出多重循环</title>
    <link href="/2022/11/25/continue%E8%B7%B3%E5%87%BA%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF/"/>
    <url>/2022/11/25/continue%E8%B7%B3%E5%87%BA%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>做leetcode809时，碰到了跳出二重循环的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>continue跳出多重循环</title>
    <link href="/2022/11/25/%E8%B7%B3%E5%87%BA%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF/"/>
    <url>/2022/11/25/%E8%B7%B3%E5%87%BA%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>做 leetcode809 时，碰到了continue需要跳出二层循环的场景，我不知道如何使用二层循环，于是多建了一个标识符。实际上结合out就可以实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">out</span>:<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word <span class="hljs-keyword">of</span> words) &#123;<br>        <span class="hljs-keyword">let</span> m = word.<span class="hljs-property">length</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != word[j]) <span class="hljs-keyword">continue</span> out<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不加out会跳出while，继续执行for…of循环。</p><p>加上out会直接跳出out指向的循环（即for…of循环）</p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>xhr封装axios</title>
    <link href="/2022/11/24/xhr%E5%B0%81%E8%A3%85axios/"/>
    <url>/2022/11/24/xhr%E5%B0%81%E8%A3%85axios/</url>
    
    <content type="html"><![CDATA[<h2 id="xhr封装axios"><a href="#xhr封装axios" class="headerlink" title="xhr封装axios"></a>xhr封装axios</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">axios</span>(<span class="hljs-params">method, url, data=&#123;&#125;, params=&#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 1.方法转大写</span><br>        method = method.<span class="hljs-title function_">toUpperCase</span>()<br>        <br>        <span class="hljs-comment">// 2.将 query 参数拼接到 url 上</span><br>        <span class="hljs-keyword">let</span> queryString = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(params).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>            queryString += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>&amp; `</span><br>        &#125;)<br>        <br>        <span class="hljs-comment">// 判断 queryString 中有没有值</span><br>        <span class="hljs-keyword">if</span> (queryString) &#123;<br>            <span class="hljs-comment">// 去除最后的 &amp;</span><br>            queryString = queryString.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, queryString.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 接到 url 上</span><br>            url += <span class="hljs-string">&#x27;?&#x27;</span> + queryString<br>        &#125;<br>        <br>        <span class="hljs-comment">// 3.xhr 发请求</span><br>        <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>        xhr.<span class="hljs-title function_">open</span>(method, url)<br>        <span class="hljs-keyword">if</span> (method === <span class="hljs-string">&#x27;GET&#x27;</span>) &#123;<br>            xhr.<span class="hljs-title function_">send</span>()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method === <span class="hljs-string">&#x27;POST&#x27;</span>) &#123;<br>            xhr.<span class="hljs-title function_">setRequestHeader</span>(<br>            <span class="hljs-string">&quot;Content-Type&quot;</span>,<br>                <span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span><br>            )<br>            xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data))<br>        &#125;<br>        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">const</span> &#123; status, statusText &#125; = xhr<br>            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> (status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>) &#123;<br>                <span class="hljs-comment">// 准备结果数据对象 response</span><br>                <span class="hljs-keyword">const</span> response = &#123;<br>                    <span class="hljs-attr">data</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(request.<span class="hljs-property">response</span>),<br>                    status,<br>                    statusText<br>                &#125;<br>                <span class="hljs-title function_">resolve</span>(response)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;request error status is &quot;</span> + status))<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>                       <br><span class="hljs-comment">// 调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testPost</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title function_">axios</span>(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost:3000/posts&quot;</span>,<br><span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br><span class="hljs-attr">data</span>: &#123;<br><span class="hljs-attr">title</span>: <span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-attr">author</span>: <span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-attr">id</span>: <span class="hljs-number">4</span><br>&#125;<br>&#125;).<span class="hljs-title function_">then</span>(<br><span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>&#125;,<br><span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>);<br>&#125;<br>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>手写代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>手写函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>登录滑块验证</title>
    <link href="/2022/11/22/%E7%99%BB%E5%BD%95%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81/"/>
    <url>/2022/11/22/%E7%99%BB%E5%BD%95%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="GEETEST"><a href="#GEETEST" class="headerlink" title="GEETEST"></a>GEETEST</h1><p>文档：<a href="http://docs.geetest.com/sensebot/apirefer/api/web#onSuccess-callback">http://docs.geetest.com/sensebot/apirefer/api/web#onSuccess-callback</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实习期间，安全部门提出后台管理系统的登录页面有隐患，要求在发送验证码前加入滑块验证。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>主要流程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;captcha-box&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loading-tip&quot;</span>&gt;</span>加载中，请稍后...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">initGeetest</span>(&#123;<br><span class="hljs-comment">// 省略必须的配置参数</span><br><br><span class="hljs-attr">product</span>: <span class="hljs-string">&#x27;float&#x27;</span><br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">captchaObj</span>) &#123;<br>captchaObj.<span class="hljs-title function_">appendTo</span>(<span class="hljs-string">&quot;#captchaBox&quot;</span>); <span class="hljs-comment">//将验证按钮插入到宿主页面中captchaBox元素内</span><br>captchaObj.<span class="hljs-title function_">onReady</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// DOM 准备好后，隐藏 #loading-tip 元素</span><br>        <span class="hljs-comment">// 仅作示例用，用您适合的方式隐藏即可</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;loading-tip&#x27;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>;<br>&#125;).<span class="hljs-title function_">onSuccess</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">const</span> result = captchaObj.<span class="hljs-title function_">getValidate</span>();<br><br>        <span class="hljs-comment">// ajax 伪代码</span><br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/api/gt-validate&#x27;</span>, &#123;<br>            <span class="hljs-attr">geetest_challenge</span>: result.<span class="hljs-property">geetest_challenge</span>,<br>            <span class="hljs-attr">geetest_validate</span>: result.<span class="hljs-property">geetest_validate</span>,<br>            <span class="hljs-attr">geetest_seccode</span>: result.<span class="hljs-property">geetest_seccode</span>,<br><br>            <span class="hljs-comment">// 其他服务端需要的数据，比如登录时的用户名和密码</span><br>        &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>            <span class="hljs-comment">// 根据服务端二次验证的结果进行跳转等操作</span><br>            <span class="hljs-keyword">if</span> (data.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;fail&#x27;</span>) &#123;<br>                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;用户名或密码错误，请重新输入并完成验证&#x27;</span>);<br>                captchaObj.<span class="hljs-title function_">reset</span>(); <span class="hljs-comment">// 调用该接口进行重置</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;success&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 结合业务逻辑，判断是否需要移除验证</span><br>                captchaObj.<span class="hljs-title function_">destroy</span>();<br>            &#125;<br>        &#125;);<br>&#125;).<span class="hljs-title function_">onError</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">// 出错啦，可以提醒用户稍后进行重试</span><br>        <span class="hljs-comment">// error 包含error_code、msg</span><br>&#125;).<span class="hljs-title function_">onClose</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 用户把验证关闭了，这时你可以提示用户需要把验证通过后才能进行后续流程</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>业务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符集、编码、码点</title>
    <link href="/2022/11/20/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%9B%86/"/>
    <url>/2022/11/20/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>最早的 127 个字符，大小写英文字母、制表符、换行符等。几乎所有后出的字符集都会兼容</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode 是国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。</p><p>Unicode 字符集的编码范围是 <strong>0x0000 - 0x10FFFF</strong> , 可以容纳一百多万个字符， 每个字符都有一个独一无二的编码，也即每个字符都有一个二进制数值和它对应，这里的二进制数值也叫 <strong>码点</strong> , 比如：汉字 <strong>“中”</strong> 的 码点是 <strong>0x4E2D</strong>, 大写字母 <strong>A</strong> 的码点是 <strong>0x41</strong>, 具体字符对应的 Unicode 编码可以查询 <a href="https://link.zhihu.com/?target=https://home.unicode.org/">Unicode字符编码表</a></p><h2 id="地区字符集"><a href="#地区字符集" class="headerlink" title="地区字符集"></a>地区字符集</h2><p>不同国家&#x2F;地区语言的特定编码格式，互相之间是冲突的，因为码点是重的。</p><h3 id="GB"><a href="#GB" class="headerlink" title="GB"></a>GB</h3><p>GB（国标），简体中文编码。</p><p>占空间小（因为字符编码集小，字符没有那么长）</p><p>同一个字符 GB 和 Unicode 码点不一致</p><p>GB2312 -&gt; GBK(GB13000) -&gt; GB18030</p><h3 id="ISO-8859"><a href="#ISO-8859" class="headerlink" title="ISO-8859"></a>ISO-8859</h3><p>东欧的</p><h3 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h3><p>台湾的</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>Unicode 是一个符号集， 它只规定了每个符号的二进制值，但是符号具体如何存储它。</p><p>UTF-8、UTF-16、UTF-32 才是真正的字符编码规则。</p><p>UTF（Unicode Transformation Format”）意思是 Unicode 转换格式，后面的数字表明至少使用多少个比特位来存储字符</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/427488961">https://zhuanlan.zhihu.com/p/427488961</a></p>]]></content>
    
    
    <categories>
      
      <category>重学前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符集、编码、码点</title>
    <link href="/2022/11/20/%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81%E7%BC%96%E7%A0%81%E3%80%81%E7%A0%81%E7%82%B9/"/>
    <url>/2022/11/20/%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81%E7%BC%96%E7%A0%81%E3%80%81%E7%A0%81%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>最早的 127 个字符，大小写英文字母、制表符、换行符等。几乎所有后出的字符集都会兼容</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>超大合集，划分不同片区，什么语言都有</p><h2 id="GB"><a href="#GB" class="headerlink" title="GB"></a>GB</h2><p>GB（国标），简体中文编码。</p><p>占空间小（因为字符编码集小，字符没有那么长）</p><p>同一个字符 GB 和 Unicode 码点不一致</p><p>GB2312 -&gt; GBK(GB13000) -&gt; GB18030</p><h3 id="ISO-8859"><a href="#ISO-8859" class="headerlink" title="ISO-8859"></a>ISO-8859</h3><p>东欧的</p><h3 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h3><p>台湾的</p><p>不同国家&#x2F;地区语言的特定编码格式，互相之间是冲突的，因为码点是重的。</p><h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h2><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/427488961">https://zhuanlan.zhihu.com/p/427488961</a></p>]]></content>
    
    
    <categories>
      
      <category>重学前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.IEEE754</title>
    <link href="/2022/11/20/IEEE754/"/>
    <url>/2022/11/20/IEEE754/</url>
    
    <content type="html"><![CDATA[<h2 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h2><p>EcmaScript规范定义Number的类型遵循IEEE754</p><p>在 IEEE754 中，双精度浮点数采用 64 位存储，其中1个符号位，11个指数位，52个小数位</p><p><strong>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度</strong></p><p>存储结构如下：</p><img src="/2022/11/20/IEEE754/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjY1MDUyOC1lMjMwMjk5NjhlYjU3MmQzLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwfGltYWdlVmlldzIvMi93Lzc4Ni9mb3JtYXQvd2VicA" class="" title="img"><p>计算方式如下：</p><img src="/2022/11/20/IEEE754/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjY1MDUyOC04NTQxZTZhYzA4ZGIyNWNkLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwfGltYWdlVmlldzIvMi93LzgwMC9mb3JtYXQvd2VicA" class="" title="img"><p>范围：±[2^(-1023), 2^1024]</p><h2 id="为什么0-1-0-2-x3D-x3D-0-3"><a href="#为什么0-1-0-2-x3D-x3D-0-3" class="headerlink" title="为什么0.1+0.2!&#x3D;&#x3D;0.3"></a>为什么0.1+0.2!&#x3D;&#x3D;0.3</h2><p>ES规范定义 Number 类型遵循 IEEE-754，IEEE-754由64位浮点数表示，其中1位符号位、11位指数位、52位小数位，精度由小数位控制，因为位数有限所以肯定无法精确表示每一个数字。将十进制数字转化为二进制时，如果无法精确表示就会产生误差，所以这就是不等的原因。</p><p>解决方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>((<span class="hljs-number">0.1</span>+<span class="hljs-number">0.2</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">10</span>)) === <span class="hljs-number">0.3</span>  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_34629352/article/details/106455790">https://blog.csdn.net/qq_34629352/article/details/106455790</a></p>]]></content>
    
    
    <categories>
      
      <category>重学前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS原子化</title>
    <link href="/2022/11/17/CSS%E5%8E%9F%E5%AD%90%E5%8C%96/"/>
    <url>/2022/11/17/CSS%E5%8E%9F%E5%AD%90%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS-原子化"><a href="#CSS-原子化" class="headerlink" title="CSS 原子化"></a>CSS 原子化</h1><h2 id="什么是-CSS-原子化"><a href="#什么是-CSS-原子化" class="headerlink" title="什么是 CSS 原子化"></a>什么是 CSS 原子化</h2><p>会提前定义很多 CSS 类，将 CSS 类的颗粒度细化到最小（所谓原子）。在需要样式时，在 html 写类名即可，不用再写 css 了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 等价于 width:100%; height:100% --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;w-full h-full&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li><strong>设立了一种必须遵守的样式规范</strong></li></ol><p>每个项目其实都有约定的规范，但随着人员的流动、屡次的迭代，可能规范就丢失了，因为没有成熟的体系。</p><ol start="2"><li><p><strong>增加复用性，减小 css 体积</strong></p></li><li><p><strong>确实能提升开发速度（熟练的话）</strong></p></li><li><p><strong>减小起名复杂度</strong></p></li><li><p><strong>更方便的响应式</strong></p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1024px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>,<span class="hljs-built_in">minmax</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>fr));<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">minmax</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>fr));<br>  &#125;<br>&#125;<br><br><span class="hljs-selector-class">.conainer</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">1rem</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 只要一行 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ol><li><strong>学习成本较高</strong></li></ol><p>要记很多类。</p><ol start="2"><li><strong>html 结构变得复杂，体积变大，难以调试（其实还好）</strong></li></ol><p>即使 HTML 因为类名过多造成体积增大，由于 class 高度相似，gzip 也将会得到一个很大的压缩比例（对于 gzip，重复度越高的文件可压缩的空间就越大）。</p><ol start="3"><li><strong>无法完全摆脱 css</strong></li></ol><p>一些情况下无法</p><ol start="4"><li><strong>样式覆盖问题</strong></li></ol><p>以下 red 与 blue 两个样式哪个会生效？无法确定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red blue&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="TailWind-CSS"><a href="#TailWind-CSS" class="headerlink" title="TailWind CSS"></a>TailWind CSS</h1><p>最常用的原子化框架</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://www.tailwindcss.cn/docs/guides/vue-3-vite">https://www.tailwindcss.cn/docs/guides/vue-3-vite</a></p><h2 id="vscode-插件"><a href="#vscode-插件" class="headerlink" title="vscode 插件"></a>vscode 插件</h2><p>Tailwind CSS IntelliSense   自动补全、高亮错误等功能</p><h2 id="purgecss"><a href="#purgecss" class="headerlink" title="purgecss"></a>purgecss</h2><p>打包之后发现包体增加了很多，这是因为打包时直接打包了整个tailwindcss的缘故，引入purgecss之后，会自动去除没有使用的css,直接减少css的体积。</p><p><a href="https://www.purgecss.cn/">https://www.purgecss.cn/</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/7022810832379576357">https://juejin.cn/post/7022810832379576357</a></p><p><a href="https://www.qiyuandi.com/zhanzhang/zonghe/11209.html">https://www.qiyuandi.com/zhanzhang/zonghe/11209.html</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scss</title>
    <link href="/2022/11/16/Scss/"/>
    <url>/2022/11/16/Scss/</url>
    
    <content type="html"><![CDATA[<h1 id="Scss"><a href="#Scss" class="headerlink" title="Scss"></a>Scss</h1><p>scss 和 less 都是 css 的预处理语言，其中有很多相似的功能，因此本文主要列出 scss 和 less 的相同和不同之处。具体可看文档。</p><p>scss 更强大，更接近编译语言。</p><p>scss 需要 ruby 环境，less 直接 npm install</p><h2 id="变量不同"><a href="#变量不同" class="headerlink" title="变量不同"></a>变量不同</h2><p>less：@</p><p>scss：$可以使用 !global声明全局变量</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#main</span> &#123;<br>  <span class="hljs-variable">$width</span>: <span class="hljs-number">5em</span> !global;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br><br><span class="hljs-selector-id">#sidebar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量插值不同"><a href="#变量插值不同" class="headerlink" title="变量插值不同"></a>变量插值不同</h2><p>less：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@main-top :</span> search;<br>.@&#123; <span class="hljs-selector-tag">main</span><span class="hljs-selector-tag">-top</span> &#125; &#123;<br>    <span class="hljs-selector-tag">font-size</span> ： <span class="hljs-number">24px</span>；<br>    <span class="hljs-selector-tag">color</span> : <span class="hljs-selector-id">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>scss：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$name</span>: foo;<br><span class="hljs-variable">$attr</span>: border;<br><span class="hljs-selector-tag">p</span>.#&#123;<span class="hljs-variable">$name</span>&#125; &#123;<br>  #&#123;<span class="hljs-variable">$attr</span>&#125;-<span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.foo</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: blue; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>都有 mixin</p><p>less 将定义好的规则集，放到其它规则集中加()即可</p><p>scss 使用 @mixin 定义混入样式，使用 includes 引入混入样式</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* 定义 */</span><br><span class="hljs-keyword">@mixin</span> large-text &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* 引入 */</span><br><span class="hljs-selector-class">.page-title</span> &#123;<br>  <span class="hljs-keyword">@include</span> large-text;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>都能嵌套，都有父选择器 &amp;</p><p>scss 还可以嵌套属性</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 相同前缀的 css 属性，可以以下面的方式嵌套</span><br><span class="hljs-selector-class">.funky</span> &#123;<br>  <span class="hljs-attribute">font</span>: &#123;<br>    family: fantasy;<br>    size: <span class="hljs-number">30em</span>;<br>    weight: bold;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>都可以运算</p><h2 id="条件语句与循环语句"><a href="#条件语句与循环语句" class="headerlink" title="条件语句与循环语句"></a>条件语句与循环语句</h2><p>scss 可以使用 if else 以及 for while each</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* Sample Sass “if” statement */</span><br><span class="hljs-keyword">@if</span> lightness(<span class="hljs-variable">$color</span>) &gt; <span class="hljs-number">30%</span> &#123;<br><br>&#125; <span class="hljs-keyword">@else</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">/* Sample Sass “for” loop */</span><br><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> to <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-selector-class">.border-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123;<br>        <span class="hljs-attribute">border</span>: #&#123;<span class="hljs-variable">$i</span>&#125;px solid blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>less 也可以，但使用的是 when、each</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://less.bootcss.com/">less文档</a></p><p><a href="https://www.sass.hk/docs/">scss文档</a></p><p><a href="https://www.cnblogs.com/cntian/p/13526794.html">https://www.cnblogs.com/cntian/p/13526794.html</a></p><p><a href="https://juejin.cn/post/7091644504586846216#heading-4">https://juejin.cn/post/7091644504586846216#heading-4</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跨端开发</title>
    <link href="/2022/11/11/%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    <url>/2022/11/11/%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="APP-的三种开发方式"><a href="#APP-的三种开发方式" class="headerlink" title="APP 的三种开发方式"></a>APP 的三种开发方式</h2><h3 id="Native-App"><a href="#Native-App" class="headerlink" title="Native App"></a>Native App</h3><p>原生，需要安装app，质量高</p><p>但有 ios 和 安卓 两套系统，开发成本高</p><h3 id="Web-App"><a href="#Web-App" class="headerlink" title="Web App"></a>Web App</h3><p>就是基于浏览器的 app，开发速度快，成本低</p><p>代码放在服务器中，用户不需要手动更新</p><p>不同浏览器效果不一样</p><p>前端技术没有办法实现所有原生功能</p><h3 id="H5-与-Native-的区别"><a href="#H5-与-Native-的区别" class="headerlink" title="H5 与 Native 的区别"></a>H5 与 Native 的区别</h3><table><thead><tr><th>name</th><th>H5</th><th>Native</th></tr></thead><tbody><tr><td>稳定性</td><td>调用系统浏览器内核，稳定性较差</td><td>使用原生内核，更加稳定</td></tr><tr><td>灵活性</td><td>版本迭代快，上线灵活</td><td>迭代慢，需要应用商店审核，上线速度受限制</td></tr><tr><td>受网速 影响</td><td>较大</td><td>较小</td></tr><tr><td>流畅度</td><td>有时加载慢，给用户“卡顿”的感觉</td><td>加载速度快，更加流畅</td></tr><tr><td>用户体验</td><td>功能受浏览器限制，体验有时较差</td><td>原生系统 api 丰富，能实现的功能较多，体验较好</td></tr><tr><td>可移植性</td><td>兼容跨平台跨系统，如 PC 与 移动端，iOS 与 Android</td><td>可移植性较低，对于 iOS 和 Android 需要维护两套代码</td></tr></tbody></table><h3 id="Hybrid-App"><a href="#Hybrid-App" class="headerlink" title="Hybrid App"></a>Hybrid App</h3><p>混合应用</p><h2 id="Hybrid-开发"><a href="#Hybrid-开发" class="headerlink" title="Hybrid 开发"></a>Hybrid 开发</h2><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>前端：绝大多数页面和业务</p><p>原生：封装原生功能，供前端调用</p><p>两者如何结合？</p><p>利用原生中一个非常强大的浏览器 Web View，既可以使用 Web API，也可以使用原生 API，将前端页面运行在 Web View 中。</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p><strong>框架的作用：</strong></p><p>1.提供前端运行环境 Web View</p><p>2.实现前端与原生交互</p><p>3.封装原生功能，提供插件机制</p><img src="/2022/11/11/%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/image-20221111105941613.png" class="" title="image-20221111105941613"><p><strong>有哪些框架</strong></p><p>Cordova</p><p>混合应用开发平台：</p><img src="/2022/11/11/%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/image-20221111112843373.png" class="" title="image-20221111112843373"><p>只要前端就能开发，普通的原生需求内部都已经实现好了，扩展原生需求，使用其提供的插件平台或插件生态。</p><p>还有一些其它框架：React Native（可将前端代码编译成原生代码）、INOIC、Weex、NativeScript、Flutter</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>ui 要求不高，功能导向</p><p>快速开发</p><h2 id="JSBridge"><a href="#JSBridge" class="headerlink" title="JSBridge"></a>JSBridge</h2><p>使用框架时，我们可以直接利用框架提供的方法来调用原生方法。</p><p>不适用框架时，我们可以使用 JSBridge 来进行跨端通信。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>给 JavaScript 提供调用 Native 功能的接口</strong>，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。</p><p>它的核心是 <strong>构建 Native 和非 Native 间消息通信的通道</strong>，而且是 <strong>双向通信的通道</strong>。</p><p>JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。</p><p>Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。</p><h3 id="JS-调用-Native"><a href="#JS-调用-Native" class="headerlink" title="JS 调用 Native"></a>JS 调用 Native</h3><h4 id="注入-API"><a href="#注入-API" class="headerlink" title="注入 API"></a><strong>注入 API</strong></h4><p>注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</p><p>总之，无论是 ios（UIWebView 还是 WKWebView） 还是 安卓（WebView） ，拿到 API 直接调用就完事了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">postBridgeMessage</span>(message);<br></code></pre></td></tr></table></figure><h4 id="拦截-URL-SCHEME"><a href="#拦截-URL-SCHEME" class="headerlink" title="拦截 URL SCHEME"></a><strong>拦截 URL SCHEME</strong></h4><p>URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy:&#x2F;&#x2F;hy&#x2F;url?url&#x3D;<a href="https://link.juejin.cn/?target=http://ymfe.tech">ymfe.tech</a>，protocol 是 qunarhy，host 则是 hy。</p><p>拦截 URL SCHEME 的主要流程是：<strong>Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</strong></p><p><strong>缺陷：</strong></p><ol><li><p>使用 iframe.src 发送 URL SCHEME 优 URL 长度的隐患</p></li><li><p>创建请求需要一定耗时</p></li></ol><h3 id="Native-调用-JS"><a href="#Native-调用-JS" class="headerlink" title="Native 调用 JS"></a>Native 调用 JS</h3><p>Native 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此只要 H5 将 JS 方法暴露在 Window 上给 Native 调用即可。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）</p><h3 id="JSBridge-的引入"><a href="#JSBridge-的引入" class="headerlink" title="JSBridge 的引入"></a>JSBridge 的引入</h3><h4 id="H5-引入"><a href="#H5-引入" class="headerlink" title="H5 引入"></a>H5 引入</h4><p>采用本地引入 npm 包的方式进行调用。</p><p>优点：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；</p><p>缺点：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。</p><h4 id="Native-引入"><a href="#Native-引入" class="headerlink" title="Native 引入"></a>Native 引入</h4><p>优点：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；</p><p>缺点：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903585268891662">https://juejin.cn/post/6844903585268891662</a></p><p><a href="https://juejin.cn/post/6844904070881214471">https://juejin.cn/post/6844904070881214471</a></p>]]></content>
    
    
    <categories>
      
      <category>业务与工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>clip-path</title>
    <link href="/2022/11/10/clip-path/"/>
    <url>/2022/11/10/clip-path/</url>
    
    <content type="html"><![CDATA[<h2 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h2><h3 id="什么是-clip-path"><a href="#什么是-clip-path" class="headerlink" title="什么是 clip-path"></a>什么是 clip-path</h3><p>剪裁，可以按照 svg 路径、盒子模型、基本多边形路径等几种不同的方式来裁切。</p><p><code>clip-path</code> 主要分三类，分别为：</p><ul><li><code>basic-shape</code>： 基本图形，包括 <code>inset()</code>、<code>circle()</code>、<code>ellipse()</code>、<code>polygon()</code></li><li><code>clip-source</code>： 通过 <code>url()</code> 方法引用一段 <code>SVG</code> 的 <code>&lt;clipPath&gt;</code> 来作为剪裁路径</li><li><code>geometry-box</code>：单独使用时，将指定框的边缘作为剪裁路径，或者配合 <code>basic-shape</code> 使用，用于定义剪裁的参考框（Reference Box）<code>（由于该属性浏览器支持度比较低，本文暂不讨论）</code></li></ul><h3 id="svg-剪裁"><a href="#svg-剪裁" class="headerlink" title="svg 剪裁"></a>svg 剪裁</h3><p>语法：<code>clip-path: url ()</code></p><p>先定义一个svg路径。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">defs</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">clipPath</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;svgPath&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;heart&quot;</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M 250 500 Q 50 250 200 350 Q 200 350 300 450 Q 300 150 350 350 C 400 400 400 150 450 450 C 500 450 600 400 600 250 A 50 50 0 1 1 250 500 Z&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">clipPath</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">defs</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clipImg&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://pic.qqtn.com/up/2019-9/15690311636958128.jpg&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>然后给元素加上<code>clip-path: url(#id)</code>，其中id 为 <code>clipPath</code> 标签的 id。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clipImg</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">800px</span>;<br>    <span class="hljs-attribute">clip-path</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">#svgPath</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本图形"><a href="#基本图形" class="headerlink" title="基本图形"></a>基本图形</h3><h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><p>按矩形剪裁，语法 <code>clip-path:inset(top,right,bottom,left)</code>;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">10%</span> <span class="hljs-number">10%</span> <span class="hljs-number">10%</span> <span class="hljs-number">10%</span>);<br></code></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1ee10118c2a452e91363d1c5ad9077a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image (3).png"></p><h5 id="一个动画-demo"><a href="#一个动画-demo" class="headerlink" title="一个动画 demo"></a><strong>一个动画 demo</strong></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c3f8d30b6174ff7bb41de2cb70ce713~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="9b31d0422c11eab6e5dddfb94c6ef752.gif"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;border&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.text</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br><span class="hljs-selector-class">.border</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid;<br>    <span class="hljs-attribute">border-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">45deg</span>, <span class="hljs-built_in">rgb</span>(<span class="hljs-number">184</span>, <span class="hljs-number">159</span>, <span class="hljs-number">218</span>), <span class="hljs-built_in">rgb</span>(<span class="hljs-number">15</span>, <span class="hljs-number">48</span>, <span class="hljs-number">194</span>)) <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">96%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">animation</span>: clipPath <span class="hljs-number">5s</span> infinite linear;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> clipPath &#123;<br>    <span class="hljs-number">0%</span>&#123;<br>        <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">96%</span> <span class="hljs-number">0</span>);<br>        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">0deg</span>);<br>    &#125;<br>    <span class="hljs-number">25%</span> &#123;<br>        <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">96%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-number">50%</span> &#123;<br>        <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">96%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>);<br>        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">360deg</span>);<br>    &#125;<br>    <span class="hljs-number">75%</span> &#123;<br>        <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">96%</span>);<br>    &#125;<br>    <span class="hljs-number">100%</span> &#123;<br>        <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">96%</span> <span class="hljs-number">0</span>);<br>        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">0deg</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h4><p>按圆形剪裁，语法 <code>clip-path:circle(50% at 50% 50%）</code>，at 前的50%代表半径为50% ， 后面的 50% 50% 代表圆心的位置。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15ceb0dc649e4964917f965ebf1fface~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image (8).png"></p><h4 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h4><p>按椭圆剪裁，语法<code>clip-path: ellipse(50px 60px at 0 10% 20%)</code>; at 前参数为圆心位置，at后面参数为椭圆半径。椭圆就是基于圆形变化而来，参数含义结构都是类似的，只是半径不是一个值。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/552be802036142eaa39c1e472bf8c7df~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image (9).png"></p><h4 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h4><p>按多边形剪裁，语法 <code>clip-path: polygon(30% 50%，20% 10% ，20% 10%)</code>,每个具体的点位之间用『逗号』分割，每个具体的点位由（x y）组成；点位个数不限。以三角形为例说明具体数值含义：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c9f5fba51da4f7e94cd8f12746c411d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="cbbb677d48784ce50242d84700e82f37.png"></p><p>也正是因为 <code>polygon</code> 点位数不限的灵活性，可实现多种形状的剪裁，例如五角星，多边形等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*五角星*/</span><br><span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>, <span class="hljs-number">61%</span> <span class="hljs-number">35%</span>, <span class="hljs-number">98%</span> <span class="hljs-number">35%</span>, <span class="hljs-number">68%</span> <span class="hljs-number">57%</span>, <span class="hljs-number">79%</span> <span class="hljs-number">91%</span>, <span class="hljs-number">50%</span> <span class="hljs-number">70%</span>, <span class="hljs-number">21%</span> <span class="hljs-number">91%</span>, <span class="hljs-number">32%</span> <span class="hljs-number">57%</span>, <span class="hljs-number">2%</span> <span class="hljs-number">35%</span>, <span class="hljs-number">39%</span> <span class="hljs-number">35%</span>);<br><span class="hljs-comment">/*五边形*/</span><br><span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>, <span class="hljs-number">100%</span> <span class="hljs-number">38%</span>, <span class="hljs-number">82%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">18%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">0%</span> <span class="hljs-number">38%</span>);<br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/7163075335058096141">https://juejin.cn/post/7163075335058096141</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据埋点</title>
    <link href="/2022/11/10/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9/"/>
    <url>/2022/11/10/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="数据埋点"><a href="#数据埋点" class="headerlink" title="数据埋点"></a>数据埋点</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实习开会的时候，说需要一些用户数据，提到埋点，此时我并不知道什么是埋点，故会后阅读了一些文章，这篇文章作为记录与总结。</p><h2 id="为什么需要数据埋点"><a href="#为什么需要数据埋点" class="headerlink" title="为什么需要数据埋点"></a>为什么需要数据埋点</h2><p>对于产品，我们需要关注用户的行为</p><ul><li>用户在产品里 主要做什么操作、停留多久、访问几次</li><li>用户点击率占比如何，会不会出现某些功能设计对于用户而言是无效的</li><li>用户在核心使用流程上是否顺畅，页面反馈是否正常友好</li><li>可能有哪些潜在的用户的功能需要更新</li></ul><p>要收集这些数据就需要进行埋点。</p><p>总的来说：<strong>收集数据</strong>，分析数据，评估项目质量和重要性，指明产品优化方向。</p><h2 id="前端埋点要考虑哪些方面"><a href="#前端埋点要考虑哪些方面" class="headerlink" title="前端埋点要考虑哪些方面"></a>前端埋点要考虑哪些方面</h2><h3 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h3><p>用户行为就是在网页应用中进行的一系列操作，但用户的操作有很多种，都需要记录下来是不可能的，一般需要记录用户的以下几种行为：</p><ul><li>用户浏览页面次数，PV（Page View）<ul><li>用户每次访问网站中的一个页面就被记录为 <code>1</code> 个 <code>PV</code>，多次访问同一个页面，访问量就会累计</li></ul></li><li>页面浏览用户数，UV（Unique visitor）<ul><li>通过网络正常访问页面的使用者，通常一台电脑客户端或一个用户账号为一个访客，一般同一个客户端或用户账号在 <code>24h</code> 内多次访问只会被记录为 <code>1</code> 个 <code>UV</code>，计算策略视具体情况而定</li></ul></li><li>用户点击按钮次数<ul><li>以上两种可以认为是 **<code>自动式触发埋点</code>**，而点击按钮次数就属于是 **<code>互动式触发埋点</code>**，便于去了解这个功能按钮的使用情况</li></ul></li></ul><p>还有如 停留时长（Time On Site）和跳出率（Bounce Rate）等</p><h3 id="错误警告"><a href="#错误警告" class="headerlink" title="错误警告"></a>错误警告</h3><p>页面中代码运行产生的错误，可能会导致用户核心操作流程被中断，为了避免大量用户受到影响，我们需要获取 <strong>生产环境的错误数据</strong>，这样才能便于开发者及时进行修复。</p><p>通常来讲代码中的错误会包含以下几大类：</p><ul><li><strong>全局错误</strong>，即未被捕获的错误</li><li><strong>局部错误</strong>，即通过 <code>try...catch、promise.then、promise.catch</code> 等捕获的错误</li><li><strong>接口请求错误</strong>，即在二次封装请求 <code>API</code> 中进行请求和接收响应时的错误</li><li><strong>组件级错误</strong>，即使用 <code>Vue/React</code> 组件时发生的错误</li></ul><h3 id="页面性能"><a href="#页面性能" class="headerlink" title="页面性能"></a>页面性能</h3><p>页面性能其实也是前端性能优化中一个需要考虑和优化的点，毕竟如果一个网站老是发生 <strong>白屏、交互卡顿、页面资源加载时间长</strong> 等问题，肯定是没办法留住用户的，特别是用户的真实环境各不相同，如 <code>Windows x、MACOS、Android、iOS</code> 等，更加需要统计和收集相关数据，便于进行集中优化处理，提升用户体验。</p><ul><li><strong>首次绘制（<code>First Paint，FP</code>）</strong><ul><li>在渲染进程确认要渲染当前响应资源后，渲染进程会先创建一个空白页面，通常把创建空白页面的这个时间点称为 <code>First Paint</code>，简称 <code>FP</code></li><li>所谓的 <strong>白屏时间</strong> 其实指的就是创建这个空白页面到浏览器开始渲染非空白内容的时间，比如页面背景发生变化等</li></ul></li><li><strong>首次内容绘制（<code>First Contentful Paint，FCP</code>）</strong><ul><li>当用户看见一些 “内容” 元素被绘制在页面上的时间点，和白屏是不一样，它可以是 <strong><code>文本</code></strong> 首次绘制，或 <code>SVG</code> 首次出现，或 <code>Canvas</code> 首次绘制等，即当页面中绘制了第一个 <strong>像素</strong> 时，这个时间点称为 <code>First Content Paint</code>，简称 <code>FCP</code></li></ul></li><li><strong>首屏时间 &#x2F; 最大内容绘制（<code>Largest Contentful Paint, LCP</code>）</strong><ul><li><code>LCP</code> 是一种新的性能度量标准，<code>LCP</code> 侧重于用户体验的性能度量标准，与现有度量标准相比，更容易理解与推理，当首屏内容完全绘制完成时，这个时间点称为 <code>Largest Content Paint</code>，简称 <code>LCP</code></li><li><strong>最大内容绘制应在 <code>2.5s</code> 内完成</strong></li></ul></li><li><strong>首次输入延迟（<code>First Input Delay, FID</code>）</strong><ul><li><code>FID</code> 测量的是当用户第一次在页面上交互的时候（<strong>点击链接</strong>、<strong>点击按钮</strong> 或 <strong>自定义基于 <code>js</code> 的事件</strong>），到浏览器实际开始处理这个事件的时间</li><li><strong>首次输入延迟应在 <code>100ms</code> 内完成</strong></li></ul></li><li><strong>累积布局偏移（<code>Cumulative Layout Shift, CLS</code>)</strong><ul><li><code>CLS</code> 是为了测量 <strong>视觉稳定性</strong>，以便提供良好的用户体验</li><li><strong>累积布局偏移应保持在 <code>0.1</code> 或更少</strong></li></ul></li><li><strong>首字节达到时间（<code>Time to First Byte，TTFB</code>）</strong><ul><li>指的是浏览器开始收到服务器响应数据的时间（<strong>后台处理时间 + 重定向时间</strong>），是反映服务端响应速度的重要指标</li><li><strong><code>TTFB</code> 时间如果超过 <code>500ms</code>，用户在打开网页的时就会感觉到明显的等待</strong></li></ul></li></ul><h2 id="神策数据埋点"><a href="#神策数据埋点" class="headerlink" title="神策数据埋点"></a><a href="https://blog.csdn.net/qq_41619796/article/details/112028163?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-112028163-blog-124500335.pc_relevant_3mothn_strategy_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3">神策数据埋点</a></h2><p><strong>文档：<a href="https://www.sensorsdata.cn/2.0/manual/js_sdk_faq.html">https://www.sensorsdata.cn/2.0/manual/js_sdk_faq.html</a></strong></p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a><strong>安装依赖</strong></h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">npm install --<span class="hljs-keyword">save</span> <span class="hljs-keyword">sa</span>-sdk-javascript<br></code></pre></td></tr></table></figure><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a><strong>项目配置</strong></h3><p>在 utils 文件夹下新建 sensors.js，配置单页应用的固定代码，（非单页应用不需要加上配置对象： is_track_single_page: true）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> sensors <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;sa-sdk-javascript&#x27;</span><br>sensors.<span class="hljs-title function_">init</span>(&#123; <span class="hljs-comment">// 神策系统配置</span><br>            <span class="hljs-attr">server_url</span>: <span class="hljs-string">&#x27;http://shence.ap-ec.cn:8106/debug&#x27;</span>, <span class="hljs-comment">// 数据接收地址</span><br>            <span class="hljs-attr">is_track_single_page</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 单页应用页面浏览事件采集(url改变就触发)</span><br>            <span class="hljs-attr">use_app_track</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">show_log</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 控制台显示数据开</span><br>            <span class="hljs-attr">heatmap</span>: &#123; <span class="hljs-comment">// 热图设置 default开启 not_collect关闭（详细配置解释看官方文档）</span><br>                <span class="hljs-attr">clickmap</span>: <span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-comment">// 点击热图，收集点击事件</span><br>                <span class="hljs-attr">scroll_notice_map</span>: <span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-comment">// 视区热图，收集页面区域停留时间</span><br>            &#125;<br>        &#125;)<br> <br>sensors.<span class="hljs-title function_">quick</span>(<span class="hljs-string">&#x27;autoTrack&#x27;</span>) <span class="hljs-comment">// 首次触发页面加载事件 $pageview</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> sensors<br></code></pre></td></tr></table></figure><h3 id="全局注册神策埋点"><a href="#全局注册神策埋点" class="headerlink" title="全局注册神策埋点"></a><strong>全局注册神策埋点</strong></h3><p>在 main.js 文件中，将神策埋点信息挂载到 vue 实例下，操作如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vue2 的挂载</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> sensors <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/sensors.js&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$sensors</span> = sensors<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$sensors</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vue3 的挂载</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> sensors <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/sensors.js&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br>app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$sensors</span> = sensors<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> currentInstance = <span class="hljs-title function_">getCurrentInstance</span>()<br><span class="hljs-keyword">const</span> &#123; $sensors &#125; = currentInstance.<span class="hljs-property">appContext</span>.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span><br></code></pre></td></tr></table></figure><h3 id="埋点操作"><a href="#埋点操作" class="headerlink" title="埋点操作"></a>埋点操作</h3><h4 id="1-自动采集事件埋点"><a href="#1-自动采集事件埋点" class="headerlink" title="1.自动采集事件埋点"></a>1.自动采集事件埋点</h4><p>主要用于主动触发页面浏览事件，一般只在页面配置后调用一次即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">sensors.<span class="hljs-title function_">quick</span>(<span class="hljs-string">&#x27;autoTrack&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="2-事件埋点（页面上事件用这个）"><a href="#2-事件埋点（页面上事件用这个）" class="headerlink" title="2. 事件埋点（页面上事件用这个）"></a>2. 事件埋点（页面上事件用这个）</h4><p>事件名+传递参数（必须是对象）+回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$sensors</span>.<span class="hljs-title function_">track</span>(<span class="hljs-string">&#x27;ViewSupplyChainDetails&#x27;</span>[, param][,callback])<br></code></pre></td></tr></table></figure><h4 id="3-公共属性埋点"><a href="#3-公共属性埋点" class="headerlink" title="3.公共属性埋点"></a>3.公共属性埋点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> param = &#123;<br>    <span class="hljs-attr">platform_type</span>: <span class="hljs-string">&#x27;WEB&#x27;</span>, <span class="hljs-comment">// 平台类型：App，H5，Web</span><br>    <span class="hljs-attr">app_name</span>: <span class="hljs-string">&#x27;沐甜商城网站&#x27;</span>, <span class="hljs-comment">// 应用名称</span><br>    <span class="hljs-attr">product_line</span>: <span class="hljs-string">&#x27;白糖&#x27;</span>,<br>&#125;<br> <br>sensors.<span class="hljs-title function_">registerPage</span>(param) <span class="hljs-comment">// 设置公共属性</span><br></code></pre></td></tr></table></figure><h4 id="4-给点击事件加触发埋点，使用vue的自定义指令"><a href="#4-给点击事件加触发埋点，使用vue的自定义指令" class="headerlink" title="4.给点击事件加触发埋点，使用vue的自定义指令"></a>4.给点击事件加触发埋点，使用vue的自定义指令</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指令：v-saclick</span><br><span class="hljs-comment"> * 使用示例：v-saclick=&quot;&#123;clickName:&#x27;XXX&#x27;,clickData:&#123;params1:&#x27;XXX&#x27;,params2:&#x27;XX&#x27;&#125;&#125;&quot;</span><br><span class="hljs-comment"> * clickName：埋点函数名</span><br><span class="hljs-comment"> * clickData | Object   params当前埋点函数所需参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> saclick = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;saclick&#x27;</span>, &#123;<br>  <span class="hljs-attr">bind</span>: <span class="hljs-function">(<span class="hljs-params">el, binding</span>) =&gt;</span> &#123;<br>    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> clickName = binding.<span class="hljs-property">value</span>.<span class="hljs-property">clickName</span> <span class="hljs-comment">// 携带的数据</span><br>      <span class="hljs-keyword">const</span> data = binding.<span class="hljs-property">value</span>.<span class="hljs-property">clickData</span> || &#123;&#125; <span class="hljs-comment">//接收传参</span><br>      sa.<span class="hljs-title function_">track</span>(clickName, data)<br>    &#125;)<br>  &#125;<br>&#125;)<br> <br><span class="hljs-keyword">export</span> &#123; preventReClick, saclick &#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7163046672874864676">https://juejin.cn/post/7163046672874864676</a></p><p><a href="https://juejin.cn/post/6844904061934780424">https://juejin.cn/post/6844904061934780424</a></p><p><a href="https://blog.csdn.net/qq_41619796/article/details/112028163?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-112028163-blog-124500335.pc_relevant_3mothn_strategy_recovery&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/qq_41619796/article/details/112028163?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-112028163-blog-124500335.pc_relevant_3mothn_strategy_recovery&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>]]></content>
    
    
    <categories>
      
      <category>业务与工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>h5支付</title>
    <link href="/2022/11/09/h5%E6%94%AF%E4%BB%98/"/>
    <url>/2022/11/09/h5%E6%94%AF%E4%BB%98/</url>
    
    <content type="html"><![CDATA[<h1 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实习项目想开展支付业务，项目是 h5 嵌入 app 的。</p><p>走 app 支付的话，如果走内购，苹果抽30%，太贵了。如果走第三方（支付宝&#x2F;微信），ios 审核比较严（想尽办法让你走内购，<a href="https://developer.apple.com/cn/app-store/review/guidelines/#other-purchase-methods">app store 审核政策</a>），流程麻烦，不一定能走通。于是让我试试 h5 支付能不能走通第三方。查看文档后发现，微信明确表示，<strong>H5 支付不建议在 APP 端使用，如需要在 APP 中使用微信支付，请接 APP 支付。</strong>所以这条路应该是走不通了，但是因为支付是一个很重要的业务，以后可能也会遇到，所以想记录一下查阅的资料，以便后续查阅。</p><p>还有一种方法是，h5 通过 app 提供的方法唤醒 微信&#x2F;支付宝，微信&#x2F;支付宝再跳转到支付页面？不知道能不能过审核。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><strong>微信</strong></p><p><a href="https://pay.weixin.qq.com/wiki/doc/apiv3/index.shtml">https://pay.weixin.qq.com/wiki/doc/apiv3/index.shtml</a></p><p><strong>支付宝</strong></p><p><a href="https://opendocs.alipay.com/open/204/105051">https://opendocs.alipay.com/open/204/105051</a></p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a><a href="https://juejin.cn/post/6859378614488530957">流程图</a></h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc73f1faca0f41119acaccf01890f51e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h3><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a><a href="https://blog.csdn.net/zcl_666/article/details/75655530">后端</a></h4><p>使用 SDK</p><h5 id="当前台点击支付按钮，开始调用支付接口"><a href="#当前台点击支付按钮，开始调用支付接口" class="headerlink" title="当前台点击支付按钮，开始调用支付接口"></a>当前台点击支付按钮，开始调用支付接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">CreatPayOrderForH5</span><span class="hljs-params">(HttpSession session, HttpServletRequest request,  HttpServletResponse response)</span><br>&#123;<br>    <span class="hljs-type">AlipayClient</span> <span class="hljs-variable">alipayClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>  <span class="hljs-title class_">DefaultAlipayClient</span>(AliPayConfig.URL, AliPayConfig.APPID, AliPayConfig.RSA_PRIVATE_KEY, AliPayConfig.FORMAT, AliPayConfig.input_charset, AliPayConfig.ALIPAY_PUBLIC_KEY, AliPayConfig.sign_type); <span class="hljs-comment">//获得初始化的AlipayClient</span><br>    <span class="hljs-type">AlipayTradeWapPayRequest</span> <span class="hljs-variable">alipayRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlipayTradeWapPayRequest</span>();<br>    <span class="hljs-comment">//发起支付宝支付</span><br>    <span class="hljs-comment">//设置支付完成后的返回地址</span><br>    alipayRequest.setReturnUrl(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<br>    <span class="hljs-comment">//设置回跳和通知地址</span><br>    alipayRequest.setNotifyUrl(<span class="hljs-string">&quot;www.google.com&quot;</span>);<br>    alipayRequest.setBizContent(<span class="hljs-string">&quot;&#123;&quot;</span> +<br>                                <span class="hljs-string">&quot;    \&quot;out_trade_no\&quot;:\&quot;&quot;</span>+订单号+<span class="hljs-string">&quot;\&quot;,&quot;</span> +<br>                                <span class="hljs-string">&quot;    \&quot;total_amount\&quot;:\&quot;&quot;</span>+订单金额+<span class="hljs-string">&quot;\&quot;,&quot;</span> +<br>                                <span class="hljs-string">&quot;    \&quot;subject\&quot;:\&quot;&quot;</span>+商品标题+<span class="hljs-string">&quot;\&quot;,&quot;</span> +<br>                                <span class="hljs-string">&quot;    \&quot;product_code\&quot;:\&quot;QUICK_WAP_PAY\&quot;&quot;</span> +<br>                                <span class="hljs-string">&quot;  &#125;&quot;</span>);<br>    String form=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-comment">// 调用SDK生成表单</span><br>        form = alipayClient.pageExecute(alipayRequest).getBody();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (AlipayApiException e)<br>    &#123;<br>        form = <span class="hljs-string">&quot;err&quot;</span>;<br>        e.printStackTrace();<br>    &#125; <br><br>    response.setContentType(<span class="hljs-string">&quot;text/html;charset=&quot;</span> + AliPayConfig.input_charset);<br>    <span class="hljs-comment">//直接将完整的表单html输出到页面</span><br>    response.getWriter().write(form);<br>    response.getWriter().flush();<br>    response.getWriter().close();<br>&#125;<br><br><span class="hljs-comment">/*说明：</span><br><span class="hljs-comment">    1、AliPayConfig为常量定义文件，里面包括支付宝支付的一些常用值，如AppId，公钥、私钥等等;</span><br><span class="hljs-comment">    2、支付接口不需要返回值，直接把支付宝生成的form输出到页面即可，from正确的话前台会开始跳转支付宝</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="支付完成后，支付宝开始调用回调接口"><a href="#支付完成后，支付宝开始调用回调接口" class="headerlink" title="支付完成后，支付宝开始调用回调接口"></a>支付完成后，支付宝开始调用回调接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">AlipayTradePayNotify</span><span class="hljs-params">(Map&lt;String, String[]&gt; requestParams)</span> <span class="hljs-keyword">throws</span> AlipayApiException<br>    &#123;<br>        Map&lt;String, String&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        <span class="hljs-keyword">for</span> (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext();)<br>        &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String)iter.next();<br>            String[] values = (String[])requestParams.get(name);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">valueStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; values.length; i++)<br>            &#123;<br>                valueStr = (i == values.length - <span class="hljs-number">1</span>) ? valueStr + values[i] : valueStr + values[i] + <span class="hljs-string">&quot;,&quot;</span>;<br>            &#125;<br>            <span class="hljs-comment">// 乱码解决，这段代码在出现乱码时使用。</span><br>            <span class="hljs-comment">// valueStr = new String(valueStr.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);</span><br>            params.put(name, valueStr);<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">signVerified</span> <span class="hljs-operator">=</span> AlipaySignature.rsaCheckV1(params, AliPayConfig.ALIPAY_PUBLIC_KEY, AliPayConfig.input_charset, AliPayConfig.sign_type); <br>        <span class="hljs-comment">// 调用SDK验证签名</span><br>        <span class="hljs-keyword">if</span> (signVerified)<br>        &#123;<br>            <span class="hljs-comment">//签名验证成功</span><br>           response.getWriter().print(<span class="hljs-string">&quot;success&quot;</span>);<br>           <span class="hljs-comment">//处理自己的逻辑</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 验证失败</span><br>            response.getWriter().print(<span class="hljs-string">&quot;failure&quot;</span>);<br>            <span class="hljs-comment">// 调试用，写文本函数记录程序运行情况是否正常</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sWord</span> <span class="hljs-operator">=</span> AlipaySignature.getSignCheckContentV1(params);<br>            AliPayConfig.logResult(sWord);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    说明：</span><br><span class="hljs-comment">    1、回调接口一定要写response.getWriter().print(&quot;状态&quot;)，否则支付宝收不到返回信息会一直回调该接口</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><h5 id="调接口获取表单，然后唤起支付宝"><a href="#调接口获取表单，然后唤起支付宝" class="headerlink" title="调接口获取表单，然后唤起支付宝"></a>调接口获取表单，然后唤起支付宝</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">doPayAlipay</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$apis</span>.<span class="hljs-title function_">doPayAlipay</span>(&#123;<br>      <span class="hljs-attr">oid</span>: res.<span class="hljs-property">data</span>, <span class="hljs-comment">// 取到的交易订单号</span><br>      <span class="hljs-attr">url</span>: yourBackUrl <span class="hljs-comment">// 成功后的回调地址</span><br>    &#125;)<br><br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-property">code</span>===<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">// 避免时间间隙造成的用户误操作，尽管拿到数据了仍然显示loading...直到跳转到支付宝的提供的页面</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$toast</span>.<span class="hljs-title function_">loading</span>(&#123;<br>          <span class="hljs-attr">mask</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;加载中...&#x27;</span><br>      &#125;);<br>      <span class="hljs-comment">// 把 form 插入页面中后, submit 唤醒支付宝</span><br>      <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>      div.<span class="hljs-property">innerHTML</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">form</span>;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div);<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">submit</span>();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h3><p>微信的 wap 端(手机浏览器端) 支付分为两种，微信内的公众号支付 和 微信外的 H5 支付。</p><h4 id="公众号支付"><a href="#公众号支付" class="headerlink" title="公众号支付"></a>公众号支付</h4><p>公众号支付是用户在微信中打开商户的 <code>H5</code> 页面，商户在 <code>H5</code> 页面通过调用微信支付提供的 <code>JSAPI</code> 接口调起微信支付模块完成支付。</p><p>注：<code>openid</code> 是微信用户在公众号 <code>appid</code> 下的唯一用户标识（appid 不同，则获取到的 openid 就不同），可用于永久标记一个用户，同时也是微信公众号支付的必传参数。网页授权获取用户 <code>openid</code> 接口文档。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">weixinPay</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">WeixinJSBridge</span> == <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">addEventListener</span>) &#123;<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;WeixinJSBridgeReady&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onBridgeReady</span>(data),<span class="hljs-literal">false</span>);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">attachEvent</span>) &#123;<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&quot;WeixinJSBridgeReady&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onBridgeReady</span>(data));<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&quot;onWeixinJSBridgeReady&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onBridgeReady</span>(data));<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onBridgeReady</span>(data);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">onBridgeReady</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">WeixinJSBridge</span>.<span class="hljs-title function_">invoke</span>(<br>      <span class="hljs-string">&quot;getBrandWCPayRequest&quot;</span>,<br>      &#123;<br>        <span class="hljs-attr">appId</span>: data.<span class="hljs-property">appid</span>, <span class="hljs-comment">//公众号名称，由商户传入</span><br>        <span class="hljs-attr">timeStamp</span>: data.<span class="hljs-property">timestamp</span>, <span class="hljs-comment">//时间戳，自1970年以来的秒数</span><br>        <span class="hljs-attr">nonceStr</span>: data.<span class="hljs-property">nonce_str</span>, <span class="hljs-comment">//随机串</span><br>        <span class="hljs-attr">package</span>: data.<span class="hljs-property">prepay_id</span>, <span class="hljs-comment">//订单详情扩展字符串</span><br>        <span class="hljs-attr">signType</span>: data.<span class="hljs-property">signType</span>, <span class="hljs-comment">//微信签名方式：</span><br>        <span class="hljs-attr">paySign</span>: data.<span class="hljs-property">paySign</span>, <span class="hljs-comment">//微信签名</span><br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-property">err_msg</span> == <span class="hljs-string">&quot;get_brand_wcpay_request:ok&quot;</span>)&#123;<br>          <span class="hljs-comment">// ...</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;支付失败！&quot;</span>);<br>        &#125;<br>      &#125;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="微信外支付"><a href="#微信外支付" class="headerlink" title="微信外支付"></a>微信外支付</h4><p><code>H5</code>支付是指商户在微信客户端外的移动端网页展示商品或服务，用户在前述页面确认使用微信支付时，商户发起本服务呼起微信客户端进行支付。主要用于触屏版的手机浏览器请求微信支付的场景。可以方便的从外部浏览器唤起微信支付。<br><strong>注意：</strong><code>H5</code> 支付不建议在 <code>APP</code> 端使用，如需要在 APP 中使用微信支付，请接 <code>APP</code> 支付。</p><p>后端通过拿到的参数请求微信后台去生成订单并同时返给前端一个路径 mweb_url，这个路径就是用来调起微信应用发起支付操作的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">doPaySubmit</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$apis</span>.<span class="hljs-title function_">doWechatPay</span>(&#123; <span class="hljs-attr">oid</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">trade_type</span>: <span class="hljs-string">&#x27;MWEB&#x27;</span>&#125;)<br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-property">code</span>===<span class="hljs-number">1</span>)&#123;<br>        <br><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">replace</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">mweb_url</span>+<span class="hljs-string">&#x27;&amp;redirect_url=&#x27;</span>+<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>+<span class="hljs-string">&#x27;&amp;tip=yes&#x27;</span>))<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6859378614488530957">https://juejin.cn/post/6859378614488530957</a></p><p><a href="https://blog.csdn.net/zcl_666/article/details/75655530">https://blog.csdn.net/zcl_666/article/details/75655530</a></p><p><a href="https://zhuanlan.zhihu.com/p/371738453">https://zhuanlan.zhihu.com/p/371738453</a></p>]]></content>
    
    
    <categories>
      
      <category>业务与工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Web Worker</title>
    <link href="/2022/11/04/Web%20Worker/"/>
    <url>/2022/11/04/Web%20Worker/</url>
    
    <content type="html"><![CDATA[<h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>JS 是单线程。当面临需要大量计算的场景时（如视频解码等），UI 线程就会被阻塞，甚至浏览器卡死。HTML5 中提出了 Web Worker 的概念。</p><p><strong>Web Worker 可以使脚本运行在新的线程中，它们独立于主线程，可以进行大量的计算活动，而不会影响主线程的 UI 渲染。</strong>当计算结束之后，它们可以把结果发送给主线程，从而形成了高效、良好的用户体验。Web Worker 具体可以细分为普通的 Worker、SharedWorker 和 ServiceWorker 等</p><h3 id="普通-Worker"><a href="#普通-Worker" class="headerlink" title="普通 Worker"></a>普通 Worker</h3><h4 id="创建-worker"><a href="#创建-worker" class="headerlink" title="创建 worker"></a>创建 worker</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>); <span class="hljs-comment">// 参数是url，这个url必须与创建者同源 </span><br></code></pre></td></tr></table></figure><h4 id="worker-的一些方法"><a href="#worker-的一些方法" class="headerlink" title="worker 的一些方法"></a>worker 的一些方法</h4><h5 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h5><p>主线程中可以在 Worker 上添加 onmessage 方法，用于监听 Worker 的信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>);<br>worker.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">messageEvent</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(messageEvent)<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="onmessageerror"><a href="#onmessageerror" class="headerlink" title="onmessageerror"></a>onmessageerror</h5><p>主线程中可以在 Worker 上添加 onmessageerror 方法，用于监听 Worker 的错误信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>);<br>worker.<span class="hljs-property">onmessageerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">messageEvent</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(messageEvent)<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage()"></a>postMessage()</h5><p>主线程通过此方法给 Worker 发送消息，发送参数的格式不限（可以是数组、对象、字符串等），可以根据自己的业务选择。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>);<br>worker.<span class="hljs-title function_">postMessage</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;start&#x27;</span>, <span class="hljs-attr">payload</span>: &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">666</span> &#125; &#125;); <span class="hljs-comment">// 发送信息给worker</span><br></code></pre></td></tr></table></figure><h5 id="terminate"><a href="#terminate" class="headerlink" title="terminate()"></a>terminate()</h5><p>主线程通过此方法终止 Worker 的运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>);<br>worker.<span class="hljs-title function_">terminate</span>();<br></code></pre></td></tr></table></figure><h4 id="worker-作用域"><a href="#worker-作用域" class="headerlink" title="worker 作用域"></a>worker 作用域</h4><p>Worker 的作用域跟主线程中的 Window 是相互独立的，并且 Worker 中是获取不到 DOM 元素的。所以在 Worker 中你无法使用 Window 变量。取而代之的是可以用 self 来表示全局对象。比较常用的方法是 onmessage、postMessage，主要用来跟主线程进行通信。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监听事件，主线程可以通过 postMessage 发送信息过来</span><br>self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">messageEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; type, payload &#125; = messageEvent.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;start&#x27;</span>:<br>            <span class="hljs-comment">// 通过 type 去区分不同的业务逻辑，payload 是传过来的数据</span><br>            <span class="hljs-keyword">const</span> result = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// ....,通过一系列处理之后，把最终的结果发送给主线程</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">postMessage</span>(result);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="worker-引入其它脚本"><a href="#worker-引入其它脚本" class="headerlink" title="worker 引入其它脚本"></a>worker 引入其它脚本</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Worker.js</span><br><span class="hljs-title function_">importScripts</span>(<span class="hljs-string">&#x27;constant.js&#x27;</span>);<br><span class="hljs-comment">// 下面就可以获取到 constant.js 中的所有变量了</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// constant.js</span><br><span class="hljs-comment">// 可以在 Worker 中使用</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">111</span>;<br><br><span class="hljs-comment">// 不可以在 Worker 中使用，原因未知</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 可以在 Worker 中使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>![image-20221104134525616](Web Worker&#x2F;image-20221104134525616.png)</p><p>控制台源代码中有专门的 worker.js</p><h4 id="常用使用场景"><a href="#常用使用场景" class="headerlink" title="常用使用场景"></a>常用使用场景</h4><h5 id="视频网站"><a href="#视频网站" class="headerlink" title="视频网站"></a>视频网站</h5><p>一般的视频网站 以优酷为例，当我们开始播放优酷视频的时候，就能看到它会调用 Worker，解码的代码应该写在 Worker 里面。</p><h5 id="需要大量计算的网站"><a href="#需要大量计算的网站" class="headerlink" title="需要大量计算的网站"></a>需要大量计算的网站</h5><p>比如 imgcook 这个网站，它能在前端解析 sketch 文件，这部分解析的逻辑就写在 Worker 里。</p><h4 id="一个例子说明-webworker-的效率"><a href="#一个例子说明-webworker-的效率" class="headerlink" title="一个例子说明 webworker 的效率"></a>一个例子说明 webworker 的效率</h4><p><strong>不使用 webworker，主线程运行3个斐波那契</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">fb</span>(<span class="hljs-params">n</span>)&#123;     </span><br><span class="language-javascript">            <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">2</span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-title function_">fb</span>(n-<span class="hljs-number">1</span>)+<span class="hljs-title function_">fb</span>(n-<span class="hljs-number">2</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;三个fb执行时间&#x27;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> result=<span class="hljs-title function_">fb</span>(<span class="hljs-number">40</span>)</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> result=<span class="hljs-title function_">fb</span>(<span class="hljs-number">40</span>)</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> result=<span class="hljs-title function_">fb</span>(<span class="hljs-number">40</span>) </span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;三个fb执行时间&#x27;</span>)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>时间：9669ms</p><p><strong>使用 webworker，创建三个进程，每个进程运行一个函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 主线程</span><br><span class="hljs-keyword">var</span> worker1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker1.js&#x27;</span>);<br><span class="hljs-keyword">var</span> worker2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker2.js&#x27;</span>);<br><span class="hljs-keyword">var</span> worker3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker3.js&#x27;</span>);<br>worker1.<span class="hljs-property">onmessage</span>=<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);<br>&#125;<br>worker2.<span class="hljs-property">onmessage</span>=<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);<br>&#125;<br>worker3.<span class="hljs-property">onmessage</span>=<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// worker1.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fb</span>(<span class="hljs-params">n</span>)&#123;<br><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fb</span>(n-<span class="hljs-number">1</span>)+<span class="hljs-title function_">fb</span>(n-<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;fb执行时间1&#x27;</span>);<br><span class="hljs-keyword">var</span> result=<span class="hljs-title function_">fb</span>(<span class="hljs-number">40</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;fb执行时间1&#x27;</span>)<br>self.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;worker1&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// worker2.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fb</span>(<span class="hljs-params">n</span>)&#123;<br><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fb</span>(n-<span class="hljs-number">1</span>)+<span class="hljs-title function_">fb</span>(n-<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;fb执行时间2&#x27;</span>);<br><span class="hljs-keyword">var</span> result=<span class="hljs-title function_">fb</span>(<span class="hljs-number">40</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;fb执行时间2&#x27;</span>)<br>self.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;worker2&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// worker3.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fb</span>(<span class="hljs-params">n</span>)&#123;<br><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fb</span>(n-<span class="hljs-number">1</span>)+<span class="hljs-title function_">fb</span>(n-<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;fb执行时间3&#x27;</span>);<br><span class="hljs-keyword">var</span> result=<span class="hljs-title function_">fb</span>(<span class="hljs-number">40</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;fb执行时间3&#x27;</span>)<br>self.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;worker3&#x27;</span>);<br></code></pre></td></tr></table></figure><p>时间分别为 2154、2185、2217</p><h3 id="SharedWorker"><a href="#SharedWorker" class="headerlink" title="SharedWorker"></a>SharedWorker</h3><p>SharedWorker 是一种共享数据的 Worker。它可以同时被多个浏览器环境访问。这些浏览器环境可以是多个 window, iframes 或者甚至是多个 Worker，只要这些 Workers 处于同一主域。为跨浏览器 tab 共享数据提供了一种解决方案。</p><h4 id="创建-worker-1"><a href="#创建-worker-1" class="headerlink" title="创建 worker"></a>创建 worker</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&quot;./shareWorker.js&quot;</span>); <span class="hljs-comment">// 参数是url，这个url必须与创建者同源 </span><br></code></pre></td></tr></table></figure><h4 id="SharedWorker-的一些方法"><a href="#SharedWorker-的一些方法" class="headerlink" title="SharedWorker 的一些方法"></a>SharedWorker 的一些方法</h4><p>方法都在 port 上</p><h5 id="port-onmessage"><a href="#port-onmessage" class="headerlink" title="port.onmessage"></a>port.onmessage</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;./shareWorker.js&#x27;</span>);<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">messageEvent</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(messageEvent)<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="port-postMessage"><a href="#port-postMessage" class="headerlink" title="port.postMessage()"></a>port.postMessage()</h5><p>参数格式不限</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;./shareWorker.js&#x27;</span>);<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">postMessage</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;increase&#x27;</span>, <span class="hljs-attr">payload</span>: &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">666</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><h5 id="post-start"><a href="#post-start" class="headerlink" title="post.start()"></a>post.start()</h5><p>主线程通过此方法开启 SharedWorker 之间的通信</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;./shareWorker.js&#x27;</span>);<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">start</span>()<br></code></pre></td></tr></table></figure><h5 id="port-close"><a href="#port-close" class="headerlink" title="port.close()"></a>port.close()</h5><p>主线程通过此方法关闭 SharedWorker</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;./shareWorker.js&#x27;</span>);<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">close</span>()<br></code></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;./shareWorker.js&#x27;</span>);<br><br>worker.<span class="hljs-property">port</span>.<span class="hljs-title function_">start</span>(); <span class="hljs-comment">// 开启端口</span><br><br><span class="hljs-comment">// 发送信息给shareWorker</span><br>worker.<span class="hljs-property">port</span>.<span class="hljs-title function_">postMessage</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;increase&#x27;</span>, <span class="hljs-attr">payload</span>: &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">666</span> &#125; &#125;); <br><br><span class="hljs-comment">// 接受shareWorker发过来的数据</span><br>worker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val.<span class="hljs-property">data</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// shareWorker.js</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">666</span>;<br><br>port.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">messageEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; type, payload &#125; = messageEvent.<span class="hljs-property">data</span>;<br><br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increase&#x27;</span>:<br>            port.<span class="hljs-title function_">postMessage</span>(++count);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrease&#x27;</span>:<br>            port.<span class="hljs-title function_">postMessage</span>(--count);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><p>在浏览器中查看和调试 SharedWorker 的代码，需要输入 chrome:&#x2F;&#x2F;inspect&#x2F;</p><p>![image-20221104140224970](Web Worker&#x2F;image-20221104140224970.png)</p><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>ServiceWorker 一般作为 Web 应用程序、浏览器和网络之间的代理服务。他们旨在创建有效的离线体验，拦截网络请求，以及根据网络是否可用采取合适的行动，更新驻留在服务器上的资源。他们还将允许访问推送通知和后台同步 API。</p><h4 id="创建-ServiceWorker"><a href="#创建-ServiceWorker" class="headerlink" title="创建 ServiceWorker"></a>创建 ServiceWorker</h4><p>navigator.serviceWorker.register().then()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        navigator.<span class="hljs-property">serviceWorker</span><br>            .<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;./serviceWorker.js&#x27;</span>, &#123; <span class="hljs-attr">scope</span>: <span class="hljs-string">&#x27;/page/&#x27;</span> &#125;)<br>            .<span class="hljs-title function_">then</span>(<br>                <span class="hljs-keyword">function</span> (<span class="hljs-params">registration</span>) &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>                        <span class="hljs-string">&#x27;ServiceWorker registration successful with scope: &#x27;</span>,<br>                        registration.<span class="hljs-property">scope</span><br>                    );<br>                &#125;,<br>                <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ServiceWorker registration failed: &#x27;</span>, err);<br>                &#125;<br>        );<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>只要创建了 ServiceWorker，不管这个创建 ServiceWorker 的 html 是否打开，这个 ServiceWorker 是一直存在的。它会代理范围是根据 scope 决定的，如果没有这个参数，则其代理范围是创建目录同级别以及子目录下所有页面的网络请求。代理的范围可以通过registration.scope 查看。</p><h4 id="ServiceWorker-的一些方法"><a href="#ServiceWorker-的一些方法" class="headerlink" title="ServiceWorker 的一些方法"></a>ServiceWorker 的一些方法</h4><h5 id="oninstall"><a href="#oninstall" class="headerlink" title="oninstall"></a>oninstall</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// serviceWorker.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">&#x27;cache-v1&#x27;</span>;<br><span class="hljs-comment">// 需要缓存的文件</span><br><span class="hljs-keyword">const</span> urlsToCache = [<br>    <span class="hljs-string">&#x27;/style/main.css&#x27;</span>,<br>    <span class="hljs-string">&#x27;/constant.js&#x27;</span>,<br>    <span class="hljs-string">&#x27;/serviceWorker.html&#x27;</span>,<br>    <span class="hljs-string">&#x27;/page/index.html&#x27;</span>,<br>    <span class="hljs-string">&#x27;/serviceWorker.js&#x27;</span>,<br>    <span class="hljs-string">&#x27;/image/131.png&#x27;</span>,<br>];<br>self.<span class="hljs-property">oninstall</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    event.<span class="hljs-title function_">waitUntil</span>(<br>        caches<br>        .<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>) <span class="hljs-comment">// 这返回的是promise</span><br>        .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">cache</span>) &#123;<br>            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>(urlsToCache); <span class="hljs-comment">// 这返回的是promise</span><br>        &#125;)<br>    );<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们可以看到，在 install 事件的回调中，我们打开了名字为 cache-v1 的缓存，它返回的是一个 promise。在打开缓存之后，我们需要把要缓存的文件 add 进去，基本上所有类型的资源都可以进行缓存，例子中缓存了 css、js、html、png。如果所有缓存数据都成功，就表示 ServiceWorker 安装成功；如果控制台提示 Uncaught (in promise) TypeError: Failed to execute ‘Cache’ on ‘addAll’: Request failed，则表示安装失败。</p><h5 id="onfetch"><a href="#onfetch" class="headerlink" title="onfetch"></a>onfetch</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">self.<span class="hljs-property">onfetch</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    event.<span class="hljs-title function_">respondWith</span>(<br>        caches<br>        .<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>) <span class="hljs-comment">// 此方法从 service worker 所创建的任何缓存中查找缓存的结果</span><br>        .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>            <span class="hljs-comment">// response为匹配到的缓存资源，如果没有匹配到则返回undefined，需要fetch资源</span><br>            <span class="hljs-keyword">if</span> (response) &#123;<br>                <span class="hljs-keyword">return</span> response;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>);<br>        &#125;)<br>    );<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 fetch 事件的回调中，我们去匹配 cache 中的资源。如果匹配到，则使用缓存资源；没有匹配到则用 fetch 请求。正因为 ServiceWorker 可以代理网络请求，所以为了安全起见，规范中规定它只能在 https 和 localhost 下才能开启。</p><h4 id="调试-2"><a href="#调试-2" class="headerlink" title="调试"></a>调试</h4><p>在浏览器中查看和调试 ServiceWorker 的代码，需要输入 chrome:&#x2F;&#x2F;inspect&#x2F;#service-workers</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>两张图片，缓存了图片1，断网后，图片1仍能显示，控制台&#x2F;网络能看到请求成功，200状态码后面写了(from service worker)，实际上文件被存到了 cacheStorage 中，控制台&#x2F;应用中可以看到。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>缓存资源文件，加快渲染速度</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th><strong>类型</strong></th><th>Worker</th><th>SharedWorker</th><th>ServiceWorker</th></tr></thead><tbody><tr><td><strong>通信方式</strong></td><td>postMessage</td><td>port.postMessage</td><td>单向通信，通过 addEventListener 监听 serviceWorker 的状态</td></tr><tr><td><strong>使用场景</strong></td><td>需要大量计算的场景</td><td>跨 tab、iframes 间共享数据</td><td>缓存资源、网络优化</td></tr><tr><td><strong>兼容性</strong></td><td>&gt;&#x3D; IE10     &gt;&#x3D; Chrome4</td><td>不支持 IE、Safari、Android、iOS<br/>&gt;&#x3D; Chrome 4</td><td>不支持 IE<br/>&gt;&#x3D; Chrome 40</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二进制及文件</title>
    <link href="/2022/11/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8A%E6%96%87%E4%BB%B6/"/>
    <url>/2022/11/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8A%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><h3 id="什么是-Blob"><a href="#什么是-Blob" class="headerlink" title="什么是 Blob"></a>什么是 Blob</h3><p>binary large object 二进制大对象</p><p>Blob 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream">ReadableStream</a> 来用于数据操作。</p><p>简单来说，Blob 对象就是一个不可修改的二进制文件。</p><img src="/2022/11/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8A%E6%96%87%E4%BB%B6/image-20221102144258008.png" class="" title="image-20221102144258008"><h3 id="创建-Blob"><a href="#创建-Blob" class="headerlink" title="创建 Blob"></a>创建 Blob</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>(array, options);<br></code></pre></td></tr></table></figure><p><code>array</code>：由 <code>ArrayBuffer</code>、<code>ArrayBufferView</code>、<code>Blob</code>、<code>DOMString</code> 等对象构成的，将会被放进 <code>Blob</code>；</p><p><code>options</code>：配置项</p><ul><li><code>type</code>：默认值为 “”，表示将会被放入到 <code>blob</code> 中的数组内容的 <strong>MIME 类型</strong>。</li><li><code>endings</code>：默认值为”<code>transparent</code>“，用于指定包含行结束符<code>\n</code>的字符串如何被写入，不常用。</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-string">&quot;Hello World&quot;</span>], &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text/plain&quot;</span>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(blob.<span class="hljs-property">size</span>); <span class="hljs-comment">// 11</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(blob.<span class="hljs-property">type</span>); <span class="hljs-comment">// &quot;text/plain&quot;</span><br></code></pre></td></tr></table></figure><p>这里可以成为动态文件创建，其正在创建一个类似文件的对象。这个 blob 对象上有两个属性：</p><ul><li><code>size</code>：Blob对象中所包含数据的大小（字节）；</li><li><code>type</code>：字符串，认为该Blob对象所包含的 MIME 类型。如果类型未知，则为空字符串。</li></ul><p>字符串”Hello World”是 UTF-8 编码的，因此它的每个字符占用 1 个字节。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>可以使用 URL.createObjectURL() 方法将将其转化为一个 URL，并在 Iframe 中加载：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;iframe&quot;</span>)[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-string">&quot;Hello World&quot;</span>], &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text/plain&quot;</span>&#125;);<br><br>iframe.<span class="hljs-property">src</span> = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);<br></code></pre></td></tr></table></figure><h3 id="Blob-切片"><a href="#Blob-切片" class="headerlink" title="Blob 切片"></a>Blob 切片</h3><p>Blob 对象内置了 slice() 方法用来将 blob 对象分片。</p><p>我们无法直接在 <code>Blob</code> 中更改数据，但我们可以通过 <code>slice</code> 获得 <code>Blob</code> 的多个部分，从这些部分创建新的 <code>Blob</code> 对象，将它们组成新的 <code>Blob</code>。类似 js 字符串。</p><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> blob = instanceOfBlob.<span class="hljs-title function_">slice</span>([start [, end [, contentType]]]&#125;;<br></code></pre></td></tr></table></figure><p><code>start</code>：设置切片的起点，即切片开始位置。默认值为 0，这意味着切片应该从第一个字节开始；</p><p><code>end</code>：设置切片的结束点，会对该位置之前的数据进行切片。默认值为<code>blob.size</code>；</p><p><code>contentType</code>：设置新 blob 的 MIME 类型。如果省略 type，则默认为 blob 的原始值。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;iframe&quot;</span>)[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-string">&quot;Hello World&quot;</span>], &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text/plain&quot;</span>&#125;);<br><br><span class="hljs-keyword">const</span> subBlob = blob.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br><br>iframe.<span class="hljs-property">src</span> = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(subBlob);<br></code></pre></td></tr></table></figure><p>页面显示 Hello</p><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="什么是-File"><a href="#什么是-File" class="headerlink" title="什么是 File"></a>什么是 File</h3><p>文件（File）接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。</p><p>实际上，<strong>File 对象是特殊类型的 Blob</strong>，且可以用在任意的 Blob 类型的 context 中。Blob 的属性和方法都可以用于 File 对象。</p><p>File 对象中只存在于浏览器环境中，在 Node.js 环境中不存在。</p><p>在 JavaScript 中，主要有两种方法来获取 File 对象：</p><ul><li><code>&lt;input&gt;</code> 元素上选择文件后返回的 FileList 对象；</li><li>文件拖放操作生成的 <code>DataTransfer</code> 对象；</li></ul><p>需要注意的是：<strong>前端无法像原生 APP 一样直接操作本地文件</strong>，否则的话打开个网页就能把用户电脑上的文件偷光了，只能通过用户触发。</p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span> <span class="hljs-attr">multiple</span>=<span class="hljs-string">&quot;multiple&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里给 <code>input</code> 标签添加了三个属性：</p><ul><li><code>type=&quot;file&quot;</code>：指定 <code>input</code> 的输入类型为文件；</li><li><code>id=&quot;fileInput&quot;</code>：指定 <code>input</code> 的唯一 id；</li><li><code>multiple=&quot;multiple&quot;</code>：指定 <code>input</code> 可以同时上传多个文件；</li></ul><p>下面来给 <code>input</code> 标签添加 <code>onchange</code> 事件，当选择文件并上传之后触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;fileInput&quot;</span>);<br><br>fileInput.<span class="hljs-property">onchange</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当点击上传文件时，控制台就会输出一个 FileList 数组，这个数组的每个元素都是一个 File 对象，一个上传的文件就对应一个 File 对象：</p><img src="/2022/11/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8A%E6%96%87%E4%BB%B6/image-20221102100344363.png" class="" title="image-20221102100344363"><p>每个 <code>File</code> 对象都包含文件的一些属性，这些属性都继承自 Blob 对象：</p><ul><li><code>lastModified</code>：引用文件最后修改日期，为自1970年1月1日0:00以来的毫秒数；</li><li><code>lastModifiedDate</code>：引用文件的最后修改日期；</li><li><code>name</code>：引用文件的文件名；</li><li><code>size</code>：引用文件的文件大小；</li><li><code>type</code>：文件的媒体类型（MIME）；</li><li><code>webkitRelativePath</code>：文件的路径或 URL。</li></ul><p>通常，我们在上传文件时，可以通过对比 size 属性来限制文件大小，通过对比 type 来限制上传文件的格式等。</p><h3 id="文件拖放"><a href="#文件拖放" class="headerlink" title="文件拖放"></a>文件拖放</h3><p>拖放区域用于响应放置操作并从放置的项目中提取信息。这些是通过 <code>ondrop</code> 和 <code>ondragover</code> 两个 API 实现的。</p><p><strong>例子</strong></p><p>定义放置区域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drop-zone&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加事件处理程序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> dropZone = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;drop-zone&quot;</span>);<br><br>dropZone.<span class="hljs-property">ondragover</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>&#125;<br><br>dropZone.<span class="hljs-property">ondrop</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-keyword">const</span> files = e.<span class="hljs-property">dataTransfer</span>.<span class="hljs-property">files</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(files)<br>&#125;<br></code></pre></td></tr></table></figure><p>当拖放文件到拖放区域时，控制台就会输出一个 FileList 数组，该数组的每一个元素都是一个 <code>File</code> 对象。这个 FileList 数组是从事件参数的 <code>dataTransfer</code> 属性的 <code>files</code> 获取的.</p><p>这里得到的 <code>File</code> 对象和通过 <code>input</code> 标签获得的 <code>File</code> 对象是完全一样的。</p><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><h3 id="什么是-FileReader"><a href="#什么是-FileReader" class="headerlink" title="什么是 FileReader"></a>什么是 FileReader</h3><p>异步 API，用于读取文件并提取内容以供进一步使用</p><p>FileReader 可以将 Blob 读取为不同的格式。</p><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br></code></pre></td></tr></table></figure><p>这个对象常用属性如下：</p><ul><li><code>error</code>：表示在读取文件时发生的错误；</li><li><code>result</code>：文件内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。</li><li>readyState：表示 FileReader 状态的数字</li></ul><table><thead><tr><th><strong>常量名</strong></th><th><strong>值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>EMPTY</td><td>0</td><td>还没有加载任何数据。</td></tr><tr><td>LOADING</td><td>1</td><td>数据正在被加载。</td></tr><tr><td>DONE</td><td>2</td><td>已完成全部的读取请求。</td></tr></tbody></table><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><ul><li><code>readAsArrayBuffer()</code>：读取指定 Blob 中的内容，完成之后，<code>result</code> 属性中保存的将是被读取文件的 <code>ArrayBuffer</code> 数据对象；</li><li><code>FileReader.readAsBinaryString()</code>：读取指定 Blob 中的内容，完成之后，<code>result</code> 属性中将包含所读取文件的原始二进制数据；</li><li><code>FileReader.readAsDataURL()</code>：读取指定 Blob 中的内容，完成之后，<code>result</code> 属性中将包含一个<code>data: URL</code> 格式的 Base64 字符串以表示所读取文件的内容。</li><li><code>FileReader.readAsText()</code>：读取指定 Blob 中的内容，完成之后，<code>result</code> 属性中将包含一个字符串以表示所读取的文件内容。</li></ul><p>上面这些方法都接受一个要读取的 blob 对象作为参数，读取完之后会将读取的结果放入对象的 <code>result</code> 属性中，只是结果的形式不同。</p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>FileReader 对象常用的事件如下：</p><ul><li><code>abort</code>：该事件在读取操作被中断时触发；</li><li><code>error</code>：该事件在读取操作发生错误时触发；</li><li><code>load</code>：该事件在读取操作完成时触发；</li><li><code>progress</code>：该事件在读取 Blob 时触发。</li></ul><p>当然，这些方法可以加上前置 on 后在HTML元素上使用，比如<code>onload</code>、<code>onerror</code>、<code>onabort</code>、<code>onprogress</code>。除此之外，由于<code>FileReader</code>对象继承自<code>EventTarget</code>，因此还可以使用 <code>addEventListener()</code> 监听上述事件。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h3><h5 id="上传图片并显示在页面上"><a href="#上传图片并显示在页面上" class="headerlink" title="上传图片并显示在页面上"></a><strong>上传图片并显示在页面上</strong></h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;preview&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;fileInput&quot;</span>);<br><span class="hljs-keyword">const</span> preview = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;preview&quot;</span>);<br><span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br><br><span class="hljs-comment">// 上传文件时触发</span><br>fileInput.<span class="hljs-property">onchange</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 读取为 dataurl 的形式</span><br>  reader.<span class="hljs-title function_">readAsDataURL</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]);<br>&#125;;<br><br><span class="hljs-comment">// reader.readAsDataURL 处理完毕后触发</span><br>reader.<span class="hljs-property">onload</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  preview.<span class="hljs-property">src</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="上传大文件监控进度"><a href="#上传大文件监控进度" class="headerlink" title="上传大文件监控进度"></a><strong>上传大文件监控进度</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br><br>reader.<span class="hljs-property">onprogress</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// progress 事件提供了两个属性：loaded（已读取量）和total（需读取总量）。</span><br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">loaded</span> &amp;&amp; e.<span class="hljs-property">total</span>) &#123;<br>    <span class="hljs-keyword">const</span> percent = (event.<span class="hljs-property">loaded</span> / event.<span class="hljs-property">total</span>) * <span class="hljs-number">100</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`上传进度: <span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.round(percent)&#125;</span> %`</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h2><img src="/2022/11/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8A%E6%96%87%E4%BB%B6/image-20221102143245073.png" class="" title="image-20221102143245073"><p>上面4行是 TypedArray，最后一行是 DataView</p><h3 id="什么是-ArrayBuffer"><a href="#什么是-ArrayBuffer" class="headerlink" title="什么是 ArrayBuffer"></a>什么是 ArrayBuffer</h3><p>在处理文件（创建、上传、下载），尤其是图像和音频时，经常会遇到二进制数据。</p><p>ArrayBuffer 对象用来表示对<strong>固定长度</strong>的<strong>连续内存空间的引用</strong>。</p><p>ArrayBuffer 本身就是一个黑盒，不能直接读写所存储的数据，需要借助以下视图对象来读写：</p><ul><li><strong>TypedArray</strong>：用来生成内存的视图，通过9个构造函数，可以生成9种数据格式的视图。</li><li><strong>DataViews</strong>：用来生成内存的视图，可以自定义格式和字节序。</li></ul><p>TypedArray视图和 DataView视图的区别主要是<strong>字节序</strong>，前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。</p><p>视图对象本身并不存储任何东西。它是一副“眼镜”，透过它来解释存储在 <code>ArrayBuffer</code> 中的字节。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="new-ArrayBuffer"><a href="#new-ArrayBuffer" class="headerlink" title="new ArrayBuffer()"></a>new ArrayBuffer()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(bytelength)<br></code></pre></td></tr></table></figure><p><code>ArrayBuffer()</code>构造函数可以分配指定字节数量的缓冲区，其参数和返回值如下：</p><ul><li><strong>参数</strong>：它接受一个参数，即 bytelength，表示要创建数组缓冲区的大小（以字节为单位。）；</li><li><strong>返回值</strong>：返回一个新的指定大小的ArrayBuffer对象，内容初始化为0。</li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="ArrayBuffer-prototype-byteLength"><a href="#ArrayBuffer-prototype-byteLength" class="headerlink" title="ArrayBuffer.prototype.byteLength"></a>ArrayBuffer.prototype.byteLength</h4><p>只读属性，表示 ArrayBuffer 的 byte 的大小</p><p>ArrayBuffer 构造完成时生成，不可改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">16</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer.<span class="hljs-property">byteLength</span>);  <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure><h4 id="ArrayBuffer-prototype-slice"><a href="#ArrayBuffer-prototype-slice" class="headerlink" title="ArrayBuffer.prototype.slice()"></a>ArrayBuffer.prototype.slice()</h4><p>截取 ArrayBuffer 实例，它返回一个新的 ArrayBuffer ，它的内容是这个 ArrayBuffer 的字节副本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">16</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));  <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure><p>这个方法实际上有两步操作，首先会分配一段指定长度的内存，然后拷贝原来ArrayBuffer对象的置顶部分。</p><h4 id="ArrayBuffer-isView"><a href="#ArrayBuffer-isView" class="headerlink" title="ArrayBuffer.isView()"></a>ArrayBuffer.isView()</h4><p>这个方法就是用来判断参数是否是 TypedArray 实例或者 DataView 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">16</span>);<br><span class="hljs-title class_">ArrayBuffer</span>.<span class="hljs-title function_">isView</span>(buffer)   <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(buffer);<br><span class="hljs-title class_">ArrayBuffer</span>.<span class="hljs-title function_">isView</span>(view)     <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h2><h3 id="什么是-TypedArray"><a href="#什么是-TypedArray" class="headerlink" title="什么是 TypedArray"></a>什么是 TypedArray</h3><p>TypedArray 对象一共提供 9 种类型的视图，每一种视图都是一种构造函数</p><img src="/2022/11/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8A%E6%96%87%E4%BB%B6/image-20221102104821408.png" class="" title="image-20221102104821408"><p>因此，一个 16 字节 <code>ArrayBuffer</code> 中的二进制数据可以解释为 16 个“小数字”，或 8 个更大的数字（每个数字 2 个字节），或 4 个更大的数字（每个数字 4 个字节），或 2 个高精度的浮点数（每个数字 8 个字节）。</p><img src="/2022/11/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8A%E6%96%87%E4%BB%B6/image-20221102142709530.png" class="" title="image-20221102142709530"><p>这些构造函数生成的对象统称为 TypedArray 对象。它们和正常的数组很类似，都有<code>length</code> 属性，都能用索引获取数组元素，<strong>所有数组的方法都可以在 TypedArray 上面使用</strong>。</p><p>那类型化数组和数组有什么区别呢？</p><ul><li>类型化数组的元素都是连续的，不会为空；</li><li>类型化数组的所有成员的类型和格式相同；</li><li>类型化数组元素默认值为 0；</li><li>类型化数组本质上只是一个视图层，不会存储数据，数据都存储在更底层的 ArrayBuffer 对象中。</li></ul><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><h4 id="new-TypedArray"><a href="#new-TypedArray" class="headerlink" title="new TypedArray()"></a>new TypedArray()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Int8Array</span>(length);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Int8Array</span>(typedArray);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Int8Array</span>(object);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Int8Array</span>(buffer [, byteOffset [, length]]);<br></code></pre></td></tr></table></figure><h4 id="BYTES-PER-ELEMENT"><a href="#BYTES-PER-ELEMENT" class="headerlink" title="BYTES_PER_ELEMENT"></a>BYTES_PER_ELEMENT</h4><p>每种视图的构造函数都有一个 <code>BYTES_PER_ELEMENT</code> 属性（实例上也有），表示这种数据类型占据的字节数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-title class_">Int8Array</span>.<span class="hljs-property">BYTES_PER_ELEMENT</span> <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Uint8Array</span>.<span class="hljs-property">BYTES_PER_ELEMENT</span> <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Int16Array</span>.<span class="hljs-property">BYTES_PER_ELEMENT</span> <span class="hljs-comment">// 2</span><br><span class="hljs-title class_">Uint16Array</span>.<span class="hljs-property">BYTES_PER_ELEMENT</span> <span class="hljs-comment">// 2</span><br><span class="hljs-title class_">Int32Array</span>.<span class="hljs-property">BYTES_PER_ELEMENT</span> <span class="hljs-comment">// 4</span><br><span class="hljs-title class_">Uint32Array</span>.<span class="hljs-property">BYTES_PER_ELEMENT</span> <span class="hljs-comment">// 4</span><br><span class="hljs-title class_">Float32Array</span>.<span class="hljs-property">BYTES_PER_ELEMENT</span> <span class="hljs-comment">// 4</span><br><span class="hljs-title class_">Float64Array</span>.<span class="hljs-property">BYTES_PER_ELEMENT</span> <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><h4 id="TypedArray-prototype-buffer"><a href="#TypedArray-prototype-buffer" class="headerlink" title="TypedArray.prototype.buffer"></a><strong>TypedArray.prototype.buffer</strong></h4><p>TypedArray 实例的 buffer 属性会返回内存中对应的 ArrayBuffer对象，只读属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(<span class="hljs-number">8</span>);<br><span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>(a.<span class="hljs-property">buffer</span>); <br></code></pre></td></tr></table></figure><h4 id="TypedArray-prototype-slice"><a href="#TypedArray-prototype-slice" class="headerlink" title="TypedArray.prototype.slice()"></a><strong>TypedArray.prototype.slice()</strong></h4><p>TypeArray 实例的 slice方法可以返回一个指定位置的新的 TypedArray实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int16Array</span>(<span class="hljs-number">8</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(view.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span> ,<span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><h4 id="byteLength-和-length"><a href="#byteLength-和-length" class="headerlink" title="byteLength 和 length"></a><strong>byteLength 和 length</strong></h4><ul><li><code>byteLength</code>：返回 TypedArray 占据的内存长度，单位为字节；</li><li><code>length</code>：返回 TypedArray 元素个数；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int16Array</span>(<span class="hljs-number">8</span>);<br>view.<span class="hljs-property">length</span>;      <span class="hljs-comment">// 8</span><br>view.<span class="hljs-property">byteLength</span>;  <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure><h2 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h2><h3 id="什么是-DataView"><a href="#什么是-DataView" class="headerlink" title="什么是 DataView"></a>什么是 DataView</h3><p><strong>DataView</strong> 视图是一个可以从 二进制 ArrayBuffer 对象中读写多种数值类型的底层接口，使用它时，不用考虑不同平台的字节序问题。</p><p>DataView视图提供更多操作选项，而且支持设定字节序。</p><p>在设计目的上，<strong>ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据</strong>，所以使用本机的字节序就可以了；而<strong>DataView视图的设计目的，是用来处理网络设备传来的数据</strong>，所以大端字节序或小端字节序是可以自行设定的。</p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><h4 id="new-DataView"><a href="#new-DataView" class="headerlink" title="new DataView()"></a>new DataView()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(buffer [, byteOffset [, byteLength]])<br></code></pre></td></tr></table></figure><p><code>buffer</code>：一个已经存在的 ArrayBuffer 对象，DataView 对象的数据源。</p><p><code>byteOffset</code>：可选，此 DataView 对象的第一个字节在 buffer 中的字节偏移。如果未指定，则默认从第一个字节开始。</p><p><code>byteLength</code>：可选，此 DataView 对象的字节长度。如果未指定，这个视图的长度将匹配 buffer 的长度。</p><h4 id="buffer、byteLength、byteOffset"><a href="#buffer、byteLength、byteOffset" class="headerlink" title="buffer、byteLength、byteOffset"></a>buffer、byteLength、byteOffset</h4><p>DataView实例有以下常用属性：</p><ul><li><code>buffer</code>：返回对应的ArrayBuffer对象；</li><li><code>byteLength</code>：返回占据的内存字节长度；</li><li><code>byteOffset</code>：返回当前视图从对应的ArrayBuffer对象的哪个字节开始。</li></ul><h4 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h4><p>getInt8：读取1个字节，返回一个8位整数。</p><p>getUint8：读取1个字节，返回一个无符号的8位整数。</p><p>getInt16：读取2个字节，返回一个16位整数。</p><p>getUint16：读取2个字节，返回一个无符号的16位整数。</p><p>getInt32：读取4个字节，返回一个32位整数。</p><p>getUint32：读取4个字节，返回一个无符号的32位整数。</p><p>getFloat32：读取4个字节，返回一个32位浮点数。</p><p>getFloat64：读取8个字节，返回一个64位浮点数。</p><p>参数都是一个字节序号，表示开始读取的字节位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">24</span>);<br><span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(buffer);<br><br><span class="hljs-comment">// 从第1个字节读取一个8位无符号整数</span><br><span class="hljs-keyword">const</span> view1 = view.<span class="hljs-title function_">getUint8</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 从第2个字节读取一个16位无符号整数</span><br><span class="hljs-keyword">const</span> view2 = view.<span class="hljs-title function_">getUint16</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 从第4个字节读取一个16位无符号整数</span><br><span class="hljs-keyword">const</span> view3 = view.<span class="hljs-title function_">getUint16</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h4 id="写入内存"><a href="#写入内存" class="headerlink" title="写入内存"></a>写入内存</h4><p>DataView 实例提供了以下方法来写入内存，它们都接受两个参数，第一个参数表示开始写入数据的字节序号，第二个参数为写入的数据：</p><ul><li>setInt8：写入1个字节的8位整数。</li><li>setUint8：写入1个字节的8位无符号整数。</li><li>setInt16：写入2个字节的16位整数。</li><li>setUint16：写入2个字节的16位无符号整数。</li><li>setInt32：写入4个字节的32位整数。</li><li>setUint32：写入4个字节的32位无符号整数。</li><li>setFloat32：写入4个字节的32位浮点数。</li><li>setFloat64：写入8个字节的64位浮点数。</li></ul><h2 id="Object-URL-x2F-Blob-URL"><a href="#Object-URL-x2F-Blob-URL" class="headerlink" title="Object URL &#x2F; Blob URL"></a>Object URL &#x2F; Blob URL</h2><h3 id="什么是-Object-URL"><a href="#什么是-Object-URL" class="headerlink" title="什么是 Object URL"></a>什么是 Object URL</h3><p>用来表示 File Object 的 URL</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7177d40eb374b09bb6413dd44a9212f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>Blob URL&#x2F;Object URL 是一种伪协议，允许将 Blob 和 File 对象用作图像、二进制数据下载链接等的 URL 源。</p><h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><h4 id="URL-createObjectURL"><a href="#URL-createObjectURL" class="headerlink" title="URL.createObjectURL()"></a>URL.createObjectURL()</h4><p>将 File 对象转为 URL</p><p><strong>input 上传图片，在 img 中显示</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;preview&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;fileInput&quot;</span>);<br><span class="hljs-keyword">const</span> preview = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;preview&quot;</span>);<br><br>fileInput.<span class="hljs-property">onchange</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// URL.createObjectURL() 将File 对象转化为一个 URL, 然后赋值给 img 的 src</span><br>  preview.<span class="hljs-property">src</span> = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(preview.<span class="hljs-property">src</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7f21bcf752940199d5985065baacb92~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h4 id="URL-revokeObjectURL"><a href="#URL-revokeObjectURL" class="headerlink" title="URL.revokeObjectURL"></a>URL.revokeObjectURL</h4><p>虽然浏览器会在文档卸载时自动释放 Data URL，但为了提高性能，我们应该使用<code>createObjectURL()</code>来手动清除 URL 释放内存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> objUrl = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>([<span class="hljs-string">&quot;&quot;</span>], <span class="hljs-string">&quot;filename&quot;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objUrl);<br><span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(objUrl);<br></code></pre></td></tr></table></figure><h2 id="Data-URL-x2F-base64"><a href="#Data-URL-x2F-base64" class="headerlink" title="Data URL &#x2F; base64"></a>Data URL &#x2F; base64</h2><p>Data URL 即 Data As URL。所以， <strong>如果资源过大，地址便会很长。</strong></p><p>base64 编码将<strong>二进制</strong>数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读“。</p><h3 id="为什么要将图片转为base64编码而不是直接传图片的url地址"><a href="#为什么要将图片转为base64编码而不是直接传图片的url地址" class="headerlink" title="为什么要将图片转为base64编码而不是直接传图片的url地址"></a><strong>为什么要将图片转为base64编码而不是直接传图片的url地址</strong></h3><ol><li><strong>减少http请求数</strong></li></ol><p>将图片转为base64编码放在html或css中，可以随着html的下载同时下载，不需要再请求服务器</p><ol start="2"><li><strong>先于内容加载</strong></li></ol><p>将编码成base64的图片置于css中，而css代码又一般是在html头部加载的，其加载顺序先于下面内容。</p><ol start="3"><li>可以像单独图片一样使用，而且对于同一张图片应用地方多，可以放入公共common块中</li></ol><h3 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h3><p>被base64编码的<strong>图片要足够小的尺寸</strong>：因为将图片生成的base64字符串编码一般而言都会比原文件大一些，即使能被gzip压缩，但是css样式代码中要写一大版的base64编码字符难看，消耗的是css文件体积</p><h3 id="使用Base64也不代表性能优化"><a href="#使用Base64也不代表性能优化" class="headerlink" title="使用Base64也不代表性能优化"></a><strong>使用Base64也不代表性能优化</strong></h3><p>使用Base64减少一个图片的http请求的同时<strong>Css文件就会付出体积增大的代价</strong></p><p><strong>文件体积增大意味着CRP的阻塞，同时页面解析CSS生成的CSSOM时间增加</strong> </p><h2 id="Object-URL-和-Data-URL-的区别"><a href="#Object-URL-和-Data-URL-的区别" class="headerlink" title="Object URL 和 Data URL 的区别"></a>Object URL 和 Data URL 的区别</h2><ul><li><code>blob</code>显示的形式<code>blob:域名/e61c67e3-df3a-453a-8f41-df740c1f5faf</code> ，dataURL的显示形式<code>data:image/jpeg;base64,/9j/4AAQ...</code></li><li><code>Blob URL</code>的长度一般比较短，但<code>Data URL</code>因为直接存储图片<code>base64</code>编码后的数据，往往很长，如上图所示，浏览器在显示<code>Data URL</code>时使用了省略号（…）。当显式大图片时，使用<code>Blob URL</code>能获取更好的可能性。</li><li><code>Blob URL</code>可以方便的使用<code>XMLHttpRequest</code>获取源数据（<code>xhr.responseType = &#39;blob&#39;</code>）。对于<code>Data URL</code>，并不是所有浏览器都支持通过<code>XMLHttpRequest</code>获取源数据的</li><li><strong><code>Blob URL</code> 只能在当前应用内部使用，把<code>Blob URL</code>复制到浏览器的地址栏中，是无法获取数据的。<code>Data URL</code>相比之下，就有很好的移植性，你可以在任意浏览器中使用。</strong></li><li><code>Blob URL</code>除了可以用作图片资源的网络地址，<code>Blob URL</code>也可以用作其他资源的网络地址，例如<code>html</code>文件、<code>json</code>文件等，为了保证浏览器能正确的解析<code>Blob URL</code>返回的文件类型，需要在创建<code>Blob</code>对象时指定相应的<code>type</code>。</li></ul><p>Blob 转换为 object url</p><ul><li>如果介意内存，我们需要撤销（revoke）它们</li><li>直接访问 <code>Blob</code>，无需“编码&#x2F;解码”</li></ul><p>Blob 转换为 data url</p><ul><li>无需撤销（revoke）任何操作。</li><li>对大的 <code>Blob</code> 进行编码时，性能和内存会有损耗。</li></ul><p>总的来说，小图片建议用 data url，可以减少 http 请求。大图片建议用 blob url，因为 data url 过大。</p><h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><h3 id="ArrayBuffer-Blob"><a href="#ArrayBuffer-Blob" class="headerlink" title="ArrayBuffer - Blob"></a>ArrayBuffer - Blob</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer, byteOffset, length)]);<br></code></pre></td></tr></table></figure><h3 id="ArrayBuffer-base64"><a href="#ArrayBuffer-base64" class="headerlink" title="ArrayBuffer - base64"></a>ArrayBuffer - base64</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> base64 = <span class="hljs-title function_">btoa</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">fromCharCode</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(arrayBuffer)));<br></code></pre></td></tr></table></figure><h3 id="base64-blob"><a href="#base64-blob" class="headerlink" title="base64 - blob"></a>base64 - blob</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">base64toBlob</span> = (<span class="hljs-params">base64Data, contentType, sliceSize</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> byteCharacters = <span class="hljs-title function_">atob</span>(base64Data);<br>  <span class="hljs-keyword">const</span> byteArrays = [];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>; offset &lt; byteCharacters.<span class="hljs-property">length</span>; offset += sliceSize) &#123;<br>    <span class="hljs-keyword">const</span> slice = byteCharacters.<span class="hljs-title function_">slice</span>(offset, offset + sliceSize);<br><br>    <span class="hljs-keyword">const</span> byteNumbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(slice.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; slice.<span class="hljs-property">length</span>; i++) &#123;<br>      byteNumbers[i] = slice.<span class="hljs-title function_">charCodeAt</span>(i);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> byteArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(byteNumbers);<br>    byteArrays.<span class="hljs-title function_">push</span>(byteArray);<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>(byteArrays, &#123;<span class="hljs-attr">type</span>: contentType&#125;);<br>  <span class="hljs-keyword">return</span> blob;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="blob-ArrayBuffer"><a href="#blob-ArrayBuffer" class="headerlink" title="blob - ArrayBuffer"></a>blob - ArrayBuffer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">blobToArrayBuffer</span>(<span class="hljs-params">blob</span>) &#123; <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>      reader.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(reader.<span class="hljs-property">result</span>);<br>      reader.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> reject;<br>      reader.<span class="hljs-title function_">readAsArrayBuffer</span>(blob);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="blob-base64"><a href="#blob-base64" class="headerlink" title="blob - base64"></a>blob - base64</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">blobToBase64</span>(<span class="hljs-params">blob</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>    reader.<span class="hljs-property">onloadend</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(reader.<span class="hljs-property">result</span>);<br>    reader.<span class="hljs-title function_">readAsDataURL</span>(blob);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="blob-Object-URL"><a href="#blob-Object-URL" class="headerlink" title="blob - Object URL"></a>blob - Object URL</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> objectUrl = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ArrayBuffer &#x2F; TypedArray &#x2F; DataView 是二进制数据，其中 ArrayBuffer 是一段固定长度的内存空间，不能直接修改，需要通过 TypedArray 或 DataView 来改写</p><p>Blob 表示 具有类型的二进制数据，可以通过 类型+ArrayBuffer 生成</p><p>Blob 可以通过 URL.createObjectURL(blob) 直接转化成 Object URL</p><p>FileReader 是异步API，可以将 Blob 读取为不同的形式，包括 ArrayBuffer &#x2F; Base64 &#x2F; Text &#x2F; BinaryString</p><p>File 继承于 Blob，可以理解为 Blob 的子类</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa83846a988842ad8656a68331207bef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>从图中我们不难看出如何修改一个已有文件，利用 FileReader API 将 blob 转为 ArrayBuffer，利用 DataView 或 TypedArray 进行修改，再 new Blob 生成新的文件。</p><img src="/2022/11/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8A%E6%96%87%E4%BB%B6/v2-b46fd4abb0531fa97c60c693d3cd0a46_720w.webp" class="" title="img"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7148254347401363463">https://juejin.cn/post/7148254347401363463</a></p><p><a href="https://zhuanlan.zhihu.com/p/147664305">https://zhuanlan.zhihu.com/p/147664305</a></p><p><a href="https://zh.javascript.info/binary">https://zh.javascript.info/binary</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手写发布订阅模式</title>
    <link href="/2022/11/01/%E6%89%8B%E5%86%99%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/11/01/%E6%89%8B%E5%86%99%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是发布订阅模式"><a href="#什么是发布订阅模式" class="headerlink" title="什么是发布订阅模式"></a>什么是发布订阅模式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>发布-订阅模式其实是一种对象间一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知。</p><p><strong>订阅者</strong>（Subscriber）把自己想订阅的事件 <strong>注册</strong>（Subscribe）到调度中心（Event Channel）;</p><p>当<strong>发布者</strong>（Publisher）<strong>发布该事件</strong>（Publish Event）到调度中心，也就是该事件触发时，由 <strong>调度中心</strong> 统一调度（Fire Event）订阅者注册到调度中心的处理代码。</p><h3 id="典型例子"><a href="#典型例子" class="headerlink" title="典型例子"></a><strong>典型例子</strong></h3><p>公众号；各种关注（b站&#x2F;小红书&#x2F;微博）</p><p>dom 中的 addEventListener 实际上也使用了发布订阅，我们不知道用户什么时候会 click，于是订阅了 btn 的 click 事件，当用户点击了按钮，就会发布。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// 执行代码</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>vue 中的 数据响应式 以及 全局事件总线(eventBus) </p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong></p><ul><li><p>低耦合：消息的发布者和订阅者在开发的时候完全不需要事先知道对方的存在</p></li><li><p>通信简洁：不需要为每一个消息的订阅者准备专门的消息格式</p></li></ul><p><strong>缺点</strong></p><ul><li>创建订阅者需要消耗一定时间和内存</li><li>多个发布者和订阅者嵌套时，难维护跟踪</li></ul><h3 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span> &#123;<br>  events = &#123;&#125;<br><br>  <span class="hljs-comment">// 触发事件</span><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">type, ...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> listeners = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type]<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> listener <span class="hljs-keyword">of</span> listeners) &#123;<br>      <span class="hljs-title function_">listener</span>(...args)<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 绑定事件</span><br>  <span class="hljs-title function_">on</span>(<span class="hljs-params">type, listener</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type] || []<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type].<span class="hljs-title function_">push</span>(listener)<br>  &#125;<br><br>  <span class="hljs-comment">// 只触发一次</span><br>  <span class="hljs-title function_">once</span>(<span class="hljs-params">type, listener</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">callback</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(type, callback)<br>      <span class="hljs-title function_">listener</span>(...args)<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(type, callback)<br>  &#125;<br><br>  <span class="hljs-comment">// 事件解绑</span><br>  <span class="hljs-title function_">off</span>(<span class="hljs-params">type, listener</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type] || []<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      item !== listener<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7052637219084828680">https://juejin.cn/post/7052637219084828680</a></p><p><a href="https://blog.csdn.net/Shockang/article/details/115712780">https://blog.csdn.net/Shockang/article/details/115712780</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>手写代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用ui库时遇到的一些问题</title>
    <link href="/2022/11/01/%E4%BD%BF%E7%94%A8ui%E5%BA%93%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2022/11/01/%E4%BD%BF%E7%94%A8ui%E5%BA%93%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="函数有默认参数但是需要传额外的参数"><a href="#函数有默认参数但是需要传额外的参数" class="headerlink" title="函数有默认参数但是需要传额外的参数"></a>函数有默认参数但是需要传额外的参数</h2><p>实际处理函数外套一层函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a-upload</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-model:file-list</span>=<span class="hljs-string">&quot;(file) =&gt; return handleBefore(file, index)&quot;</span></span><br><span class="hljs-tag">&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a-upload</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">handleBefore</span>(<span class="hljs-params">file, index</span>) &#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ui组件库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue源码面试总结</title>
    <link href="/2022/10/27/Vue%E6%BA%90%E7%A0%81%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/27/Vue%E6%BA%90%E7%A0%81%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="new-Vue-阶段做了什么"><a href="#new-Vue-阶段做了什么" class="headerlink" title="new Vue 阶段做了什么"></a>new Vue 阶段做了什么</h2><h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><p>首先执行 vue.prototype._init，这个方法在 initMixin 中被绑定到 vue 原型上。在 _init 方法中，vue 实例首先会进行配置合并，然后进行一系列的初始化，包括 initLifeCycle，initEvents，initRender，然后执行 beforeCreate 生命周期钩子，之后再进行数据的初始化，包括 initInjections，initState，initProvide，再调用 created 钩子，这也就是为什么无法在 beforeCreate 时还没有数据响应式的原因。之后就进入挂载阶段，如果有 el ，就自动调用 $mount 进入挂载阶段，否则需要手动挂载。(见 2-Vue初始化 )</p><p>挂载时，如果是运行时的 Vue 包，会通过打包器结合 vue-loader 进行预编译，将模板编译成 render 函数，所以它是可以直接去挂载的，因为它有 render 函数。而如果是全量包，并且组件配置项上没有 render, 那么就会先进入编译阶段，编译阶段只做一件事，就是编译得到 render 函数，并将其设置到 this.$options 上。核心函数叫 baseCompile，里面调用了三个函数，parse&#x2F;optimize&#x2F;generate，parse 将 html 模板解析成 ast，optimize 对 ast 进行静态标记，主要是用来优化 patch 或者说是优化 diff 算法的，因为静态的节点不会改变，没有必要走一遍对比新旧节点。generate 通过 ast 生成渲染函数。组件的配置对象上有 render 函数了，就可以真正进入挂载阶段了，挂载阶段会调用 mountComponent 函数，这个函数实例化了渲染 watcher，定义了一个 updateComponent 函数并传给了渲染 watcher，渲染 watcher 中执行 get 触发了 updateComponent 函数，而 updateComponent 这个方法它会调用 vm._update ，而且第一个参数就会执行 _render，_render 中会执行 createElement，生成 vnode，所以 vnode 就有了，而且作为参数传给了 _update，这个函数就是用来渲染页面的，它会调用 patch 函数，实现页面的首次渲染或者页面的更新。在 patch 函数中，注意如果有子组件的话，就需要再走一边 new Vue 的流程，生成子组件。而有子节点的话，就要递归的调用 createElm 和 createChildren，去创建节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">updateComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 执行 vm._render() 函数，得到 VNode，并将 VNode 传递给 _update 方法，接下来就该到 patch 阶段了</span><br>  vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>(), hydrating)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a><strong>流程图</strong></h3><h4 id="普通-DOM-元素渲染到页面"><a href="#普通-DOM-元素渲染到页面" class="headerlink" title="普通 DOM 元素渲染到页面"></a><strong>普通 DOM 元素渲染到页面</strong></h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/460de18afa1a42a898fdc0bb66e13d30~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="patch.png"></p><h4 id="组件相比普通-DOM-元素不一样的两步"><a href="#组件相比普通-DOM-元素不一样的两步" class="headerlink" title="组件相比普通 DOM 元素不一样的两步"></a><strong>组件相比普通 DOM 元素不一样的两步</strong></h4><ol><li>执行 render，render 执行 createElement，根据传入的 tag 参数辨别，是普通 DOM 元素还是组件，调用不同的方法。</li></ol><ul><li>普通 DOM 元素：tag是html的保留标签，如<code>tag: &#39;div&#39;</code></li><li>组件：tag是以<code>vue-component</code>开头，如<code>tag: &#39;vue-component-1-App&#39;</code></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fab17ec93a14bd68ac207bbec32b45d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="组件VNode.png"></p><p>2.如果是子组件的话，需要 new 子组件，再重新走一遍整个过程</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/193dd5f84d0c4b7b8031e1091780ea97~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="patch组件.png"></p><h4 id="简单版流程图"><a href="#简单版流程图" class="headerlink" title="简单版流程图"></a><strong>简单版流程图</strong></h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da708cef420e484083aa9ff09bf27858~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="组件化简化.png"></p><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="回答-1"><a href="#回答-1" class="headerlink" title="回答"></a>回答</h3><p>在 new Vue 时，vue 初始化的时候会调用 initState，在 initState 中会依次调用，initProps、initMethods、initData、initComputed、initWatch，这个顺序是固定的，因为存在优先级，一些属性是不能重复的，后面的函数会做判断，来避免重复的情况。</p><p>在具体的 init 函数中，我主要说一下 data 吧，首先 data 会做一个判重，避免和 props 以及 methods 的属性重复。然后会调用定义好的 proxy 函数将 data 中的数据代理到 vue 实例上，以便于通过 this.key 去访问。最后调用 observe 函数，传入data，给数据设置响应式。observe 函数就是数据响应式的入口，在 observe 函数里面会 new 一个 Observer，Observer 是一个观察者类，在构造函数中，会判断传进来的是数组还是对象。</p><p>如果是对象的话，会调用 walk 函数，遍历所有键，调用 defineReactive，在 defineReactive 中，首先会做一个递归处理，因为响应式是深层的嘛，不过不是递归调用自身 （defineReactive）而是调用 observe，传入值，再 new Observer，再调用 defineReactive，可以说是三个函数的循环递归。defineReactive 递归后，通过 object.defineProperty 设置 getter 和 setter，这也是真正响应式的核心，getter 中 会通过 dep.depend 做依赖收集，dep 添加到 watcher 中，watcher 也添加到 dep 中，dep 实际上就是 object.key。setter 中首先做一些处理，判断新值和老值是不是一样，判断属性是不是只读，处理完毕才会设置新值，然后对新值调用 observe，让新值也是响应式的，然后调用 dep.notify 通知依赖更新。</p><p>如果是数组的话，首先会改写数组原型上的方法，因为这些方法都可以改变数组。然后会调用 observeArray 函数，对数组的每一项调用 observe，总归是又回到了 observe，后面的流程其实和对象差不多。对于数组原型方法的改写其实也比较简单，再执行原生的方法之后，需要判断该方法，是不是 push&#x2F;unshift&#x2F;splice，如果是的话，就代表插入了新元素，需要调用 observeArray 对新元素做响应式处理，然后notify 通知更新。</p><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><h4 id="1-三个核心对象-Observer、Dep、Watcher"><a href="#1-三个核心对象-Observer、Dep、Watcher" class="headerlink" title="1.三个核心对象 Observer、Dep、Watcher"></a>1.三个核心对象 Observer、Dep、Watcher</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44ed5229550e4bff980cf5b91f725136~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="依赖收集三大OBject.png"></p><h4 id="2-依赖收集准备阶段——Observer、Dep的实例化"><a href="#2-依赖收集准备阶段——Observer、Dep的实例化" class="headerlink" title="2.依赖收集准备阶段——Observer、Dep的实例化"></a>2.依赖收集准备阶段——Observer、Dep的实例化</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d7934355e944f7a9413946bc0092eba~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="依赖收集-新.png"></p><h4 id="依赖收集触发阶段——Wather实例化、访问数据、触发依赖收集"><a href="#依赖收集触发阶段——Wather实例化、访问数据、触发依赖收集" class="headerlink" title="依赖收集触发阶段——Wather实例化、访问数据、触发依赖收集"></a>依赖收集触发阶段——Wather实例化、访问数据、触发依赖收集</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cbc1e33d2634d9b88357aed5bda3ba8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="依赖收集触发阶段.png"></p><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb6fb861ba10489aa68c6d783b699d38~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="依赖收集宏观.png"></p><h3 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h3><p>1.对象属性修改触发set，派发更新。<code>this.msg = &#39;new val&#39;</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/574c7331004b4ffb9c97afd5428cdff0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="obj派发更新.png"></p><p>2.数组调用方法。<code>this.arr.push(4)</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4232c7cb54ed4755941311a749270cdf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="数组派发更新.png"></p><h2 id="computed-和-watcher"><a href="#computed-和-watcher" class="headerlink" title="computed 和 watcher"></a>computed 和 watcher</h2><p><a href="https://juejin.cn/post/7074422512318152718#heading-8">https://juejin.cn/post/7074422512318152718#heading-8</a></p><h2 id="nextTick-的原理"><a href="#nextTick-的原理" class="headerlink" title="nextTick 的原理"></a>nextTick 的原理</h2><p>首先讲一下流程：</p><p>1.nextTick 会将传入的函数做一个包装然后放到 callbacks 数组里，这个包装主要是针对没传入回调以及回调错误捕获。</p><p>2.如果当前没有其它 nextTick 在执行的话，就会调用 timerFunc 函数，会根据环境，做一个兼容性判断，选择某一种异步执行的方法调用 flushCallbacks 函数。优先级是 promise.then &gt; object.observe &gt; setImmediate &gt; setTimeout。（因为 timerFunc 是异步的，同时只能执行一个）</p><p>3.flushCallbacks 遍历 callbacks 执行其中每一个回调。这里注意，源码里对 callbacks 做了一个拷贝，因为执行回调的过程中，可能会触发新的 nextTick，会将新的回调 push 入 callbacks，这样可能就会一直循环下去。因此nextTick 回调中的 nextTick 应该放在下一轮执行。</p><p>然后注意，并不是只有手动调用 vm.$nextTick 时才会触发 nextTick。实际上 vue 采用的是异步更新策略，也就是说当监听到数据变化的时候不会立即更新 DOM。更新后会调用 setter 里的 dep.notify()，dep.notify() 会遍历 dep 中的 watcher，执行 watcher.update()。在 update 中，会判断 watcher.sync，如果是 true，就调用 run 函数，直接同步更新，否则走异步更新，调用 queueWatcher，将 watcher 入队，然后判断队内是否有刷新函数，如果没有的话，就是用 nextTick 将 watcher 的更新函数放入 callbacks 数组里。然后就是 nextTick 的流程了。</p><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8de98b5850214a24a461d1a7e9824ea1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="tick——pending.png"></p><h4 id="Vue-异步更新"><a href="#Vue-异步更新" class="headerlink" title="Vue 异步更新"></a>Vue 异步更新</h4><h5 id="改变一个属性值会发生什么"><a href="#改变一个属性值会发生什么" class="headerlink" title="改变一个属性值会发生什么"></a>改变一个属性值会发生什么</h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c8135411a0640a5adb5cf5844afd5f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="obj派发更新.png"></p><h5 id="异步更新流程"><a href="#异步更新流程" class="headerlink" title="异步更新流程"></a>异步更新流程</h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c214208f8d564816b36cbab7d7c02d6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="异步更新.png"></p><h2 id="patch-x2F-diff-算法"><a href="#patch-x2F-diff-算法" class="headerlink" title="patch &#x2F; diff 算法"></a>patch &#x2F; diff 算法</h2><p>diff 算法只是一种寻找差异的算法，不同框架有不同实现。</p><p>Vue2 使用的是修改版的 snabbdom 算法，</p><p>首先，patch 是在 _update 方法中被调用的，它有三个作用，首次渲染、页面更新、销毁组件。会将 新老 VNode 传给 patch，进行一些判断，如果新 VNode 不存在，老 VNode 存在，那么就销毁老节点。如果新 VNode 存在 而 老 VNode 不存在，那就是首次渲染，创建 DOM 树。如果老 VNode 存在，新 VNode 也存在，那么就进入更新阶段，执行 <strong>patchVNode</strong>，首先全量更新所有的属性，然后会进行一些判断，新 VNode 有没有 text，新 VNode 有没有孩子，老 VNode 有没有孩子，不同情况处理方式不一样，比较核心的是新老节点都有孩子的情况，要执行 <strong>updateChildren</strong>，在这个函数中基于前端一般不会完全打乱节点顺序的情况做了一些小优化，会有首尾双指针做双端比较，比较首首、尾尾、首尾、尾首是不是相同节点，通过 <strong>sameVNode</strong> 函数，在其中会进行判断，包括但不仅限于 key，还有 tag 、包括 input 标签 的 type 属性是不是一样等等。如果命中的话，就可以节省一次遍历的开销，如果没有命中，就建一个哈希表，将老孩子首指针和尾指针之间的元素的 key 和 index 存到这个哈希表里 ，然后就可以通过这个哈希表来找相同节点，找到相同节点再递归 patchVNode。</p><p>patch 或者说 diff 算法的流程就是这样，其中核心就在两点，一个就是 sameVNode 用于节点复用，一个就是 updateChildren，因为一棵组件树有大量的子元素，所以 updateChildren 这个方法是会被反复调用的，那这个双端比较的优化其实是非常关键的。此外，key 也很关键，它是判断节点是否能复用的核心标识。</p><p>Vue3 使用 inferno 算法代替了 snabbdom，我没有具体去读过源码，但是知道它是基于最长上升子序列的思想，所以它的复杂度是 O(nlogn) 的，低于 snabbdom 的 O(n)，但是它可以节省不少 DOM 移动操作，因为在算法中会去考虑怎么移动才能使操作次数最少。</p><p>inferno 的例子</p><p>abc<br>cab<br>其实我们发现新的vdom的index数组是[2,0,1],<br>我们求出递增子序列，发现我们只需要移动2这个index就行。</p><p><strong>patchVNode</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3d35dcd6ec1495181f86f039066fde3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p><strong>updateChildren</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4138a76c14fe48aabc3fddb2adea2436~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p><strong>sameVNode</strong></p><p><code>sameVnode</code> 函数中包含了两个节点属于相同类型的条件，这是节点能够复用的门槛。Vue2 将 key 作为判断的标识之一，这也是为什么我们说 v-for 一定也写上 key。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Vue2 中 sameVnode 源码</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sameVnode</span> (a, b) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    a.<span class="hljs-property">key</span> === b.<span class="hljs-property">key</span> &amp;&amp; <span class="hljs-comment">// key 值的判断</span><br>    a.<span class="hljs-property">asyncFactory</span> === b.<span class="hljs-property">asyncFactory</span> &amp;&amp; (<br>      (<br>        a.<span class="hljs-property">tag</span> === b.<span class="hljs-property">tag</span> &amp;&amp; <span class="hljs-comment">// 标签名的判断</span><br>        a.<span class="hljs-property">isComment</span> === b.<span class="hljs-property">isComment</span> &amp;&amp;<br>        <span class="hljs-title function_">isDef</span>(a.<span class="hljs-property">data</span>) === <span class="hljs-title function_">isDef</span>(b.<span class="hljs-property">data</span>) &amp;&amp;<br>        <span class="hljs-title function_">sameInputType</span>(a, b) <span class="hljs-comment">// input 标签 type 的判断</span><br>      ) || (<br>        <span class="hljs-title function_">isTrue</span>(a.<span class="hljs-property">isAsyncPlaceholder</span>) &amp;&amp;<br>        <span class="hljs-title function_">isUndef</span>(b.<span class="hljs-property">asyncFactory</span>.<span class="hljs-property">error</span>)<br>      )<br>    )<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>vue 响应式原理</p><p><a href="https://juejin.cn/post/7074422512318152718">https://juejin.cn/post/7074422512318152718</a></p><p>nextTick</p><p><a href="https://juejin.cn/post/7077181211029798942">https://juejin.cn/post/7077181211029798942</a></p><p>patch&#x2F;diff</p><p><a href="https://juejin.cn/post/7143172056211783688">https://juejin.cn/post/7143172056211783688</a></p><p>Inferno</p><p><a href="https://www.proyy.com/6960514069065531405.html">https://www.proyy.com/6960514069065531405.html</a></p><p>不同 diff 算法</p><p><a href="https://www.wangt.cc/2021/03/%E5%87%A0%E7%A7%8Ddiff%E7%AE%97%E6%B3%95/">https://www.wangt.cc/2021/03/%E5%87%A0%E7%A7%8Ddiff%E7%AE%97%E6%B3%95/</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10.patch</title>
    <link href="/2022/10/26/10-patch/"/>
    <url>/2022/10/26/10-patch/</url>
    
    <content type="html"><![CDATA[<h1 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h1><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Vue1.x 中没有 VNode 和 diff 算法，响应式数据的 key 和 watcher 一一对应，模板中每引用一次响应式数据，就会生成一个 watcher。因此，项目一旦较大，一个页面会有大量 watcher，非常耗资源。</p><p>Vue2.0 中引入VNode 和 diff 算法解决上述问题。将 watcher 的颗粒度放大，一个组件一个 watcher，也就是渲染 watcher。当响应式数据更新后，dep 通知 watcher 更新，更新谁呢，watcher 和整个组件对应，不知道修改的数据在组件哪里被使用了。因此引入了 VNode，当组件更新时，会为组件生成一个新的 VNode，通过 diff 算法比较新旧 VNode。</p><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">updateComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 执行 vm._render() 函数，得到 VNode，并将 VNode 传递给 _update 方法，接下来就该到 patch 阶段了</span><br>  vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>(), hydrating)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vm-update"><a href="#vm-update" class="headerlink" title="vm._update"></a>vm._update</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 页面首次渲染和后续更新的入口位置，也是 patch 的入口位置 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_update</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">vnode: VNode, hydrating?: boolean</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-comment">// 页面的挂载点，真实的元素</span><br>  <span class="hljs-keyword">const</span> prevEl = vm.<span class="hljs-property">$el</span><br>  <span class="hljs-comment">// 老 VNode</span><br>  <span class="hljs-keyword">const</span> prevVnode = vm.<span class="hljs-property">_vnode</span><br>  <span class="hljs-keyword">const</span> restoreActiveInstance = <span class="hljs-title function_">setActiveInstance</span>(vm)<br>  <span class="hljs-comment">// 新 VNode</span><br>  vm.<span class="hljs-property">_vnode</span> = vnode<br>  <span class="hljs-comment">// Vue.prototype.__patch__ is injected in entry points</span><br>  <span class="hljs-comment">// based on the rendering backend used.</span><br>  <span class="hljs-keyword">if</span> (!prevVnode) &#123;<br>    <span class="hljs-comment">// 老 VNode 不存在，表示首次渲染，即初始化页面时走这里</span><br>    vm.<span class="hljs-property">$el</span> = vm.<span class="hljs-title function_">__patch__</span>(vm.<span class="hljs-property">$el</span>, vnode, hydrating, <span class="hljs-literal">false</span> <span class="hljs-comment">/* removeOnly */</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 响应式数据更新时，即更新页面时走这里</span><br>    vm.<span class="hljs-property">$el</span> = vm.<span class="hljs-title function_">__patch__</span>(prevVnode, vnode)<br>  &#125;<br>  <span class="hljs-title function_">restoreActiveInstance</span>()<br>  <span class="hljs-comment">// update __vue__ reference</span><br>  <span class="hljs-keyword">if</span> (prevEl) &#123;<br>    prevEl.<span class="hljs-property">__vue__</span> = <span class="hljs-literal">null</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$el</span>) &#123;<br>    vm.<span class="hljs-property">$el</span>.<span class="hljs-property">__vue__</span> = vm<br>  &#125;<br>  <span class="hljs-comment">// if parent is an HOC, update its $el as well</span><br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$vnode</span> &amp;&amp; vm.<span class="hljs-property">$parent</span> &amp;&amp; vm.<span class="hljs-property">$vnode</span> === vm.<span class="hljs-property">$parent</span>.<span class="hljs-property">_vnode</span>) &#123;<br>    vm.<span class="hljs-property">$parent</span>.<span class="hljs-property">$el</span> = vm.<span class="hljs-property">$el</span><br>  &#125;<br>  <span class="hljs-comment">// updated hook is called by the scheduler to ensure that children are</span><br>  <span class="hljs-comment">// updated in a parent&#x27;s updated hook.</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vm-patch"><a href="#vm-patch" class="headerlink" title="vm.__patch__"></a>vm.__patch__</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在 Vue 原型链上安装 web 平台的 patch 函数</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__patch__</span> = inBrowser ? patch : noop<br></code></pre></td></tr></table></figure><h2 id="patch-1"><a href="#patch-1" class="headerlink" title="patch"></a>patch</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// patch 工厂函数，为其传入平台特有的一些操作，然后返回一个 patch 函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">patch</span>: <span class="hljs-title class_">Function</span> = <span class="hljs-title function_">createPatchFunction</span>(&#123; nodeOps, modules &#125;)<br></code></pre></td></tr></table></figure><h2 id="createPatchFunction"><a href="#createPatchFunction" class="headerlink" title="createPatchFunction"></a>createPatchFunction</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> hooks = [<span class="hljs-string">&#x27;create&#x27;</span>, <span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-string">&#x27;update&#x27;</span>, <span class="hljs-string">&#x27;remove&#x27;</span>, <span class="hljs-string">&#x27;destroy&#x27;</span>]<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 工厂函数，注入平台特有的一些功能操作，并定义一些方法，然后返回 patch 函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPatchFunction</span> (backend) &#123;<br>  <span class="hljs-keyword">let</span> i, j<br>  <span class="hljs-keyword">const</span> cbs = &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * modules: &#123; ref, directives, 平台特有的一些操纵，比如 attr、class、style 等 &#125;</span><br><span class="hljs-comment">   * nodeOps: &#123; 对元素的增删改查 API &#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> &#123; modules, nodeOps &#125; = backend<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * hooks = [&#x27;create&#x27;, &#x27;activate&#x27;, &#x27;update&#x27;, &#x27;remove&#x27;, &#x27;destroy&#x27;]</span><br><span class="hljs-comment">   * 遍历这些钩子，然后从 modules 的各个模块中找到相应的方法，比如：directives 中的 create、update、destroy 方法</span><br><span class="hljs-comment">   * 让这些方法放到 cb[hook] = [hook 方法] 中，比如: cb.create = [fn1, fn2, ...]</span><br><span class="hljs-comment">   * 然后在合适的时间调用相应的钩子方法完成对应的操作</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; hooks.<span class="hljs-property">length</span>; ++i) &#123;<br>    <span class="hljs-comment">// 比如 cbs.create = []</span><br>    cbs[hooks[i]] = []<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; modules.<span class="hljs-property">length</span>; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(modules[j][hooks[i]])) &#123;<br>        <span class="hljs-comment">// 遍历各个 modules，找出各个 module 中的 create 方法，然后添加到 cbs.create 数组中</span><br>        cbs[hooks[i]].<span class="hljs-title function_">push</span>(modules[j][hooks[i]])<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * vm.__patch__</span><br><span class="hljs-comment">   *   1、新节点不存在，老节点存在，调用 destroy，销毁老节点</span><br><span class="hljs-comment">   *   2、如果 oldVnode 是真实元素，则表示首次渲染，创建新节点，并插入 body，然后移除老节点</span><br><span class="hljs-comment">   *   3、如果 oldVnode 不是真实元素，则表示更新阶段，执行 patchVnode</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">return</span> patch<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="patch-2"><a href="#patch-2" class="headerlink" title="patch"></a>patch</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * vm.__patch__</span><br><span class="hljs-comment"> *   1、新节点不存在，老节点存在，调用 destroy，销毁老节点</span><br><span class="hljs-comment"> *   2、如果 oldVnode 是真实元素，则表示首次渲染，创建新节点，并插入 body，然后移除老节点</span><br><span class="hljs-comment"> *   3、如果 oldVnode 不是真实元素，则表示更新阶段，执行 patchVnode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVnode, vnode, hydrating, removeOnly</span>) &#123;<br>  <span class="hljs-comment">// 如果新节点不存在，老节点存在，则调用 destroy，销毁老节点</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(vnode)) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode)) <span class="hljs-title function_">invokeDestroyHook</span>(oldVnode)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-keyword">let</span> isInitialPatch = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">const</span> insertedVnodeQueue = []<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldVnode)) &#123;<br>    <span class="hljs-comment">// 新的 VNode 存在，老的 VNode 不存在，这种情况会在一个组件初次渲染的时候出现，比如：</span><br>    <span class="hljs-comment">// &lt;div id=&quot;app&quot;&gt;&lt;comp&gt;&lt;/comp&gt;&lt;/div&gt;</span><br>    <span class="hljs-comment">// 这里的 comp 组件初次渲染时就会走这儿</span><br>    <span class="hljs-comment">// empty mount (likely as component), create new root element</span><br>    isInitialPatch = <span class="hljs-literal">true</span><br>    <span class="hljs-title function_">createElm</span>(vnode, insertedVnodeQueue)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 判断 oldVnode 是否为真实元素</span><br>    <span class="hljs-keyword">const</span> isRealElement = <span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">nodeType</span>)<br>    <span class="hljs-keyword">if</span> (!isRealElement &amp;&amp; <span class="hljs-title function_">sameVnode</span>(oldVnode, vnode)) &#123;<br>      <span class="hljs-comment">// 不是真实元素，但是老节点和新节点是同一个节点，则是更新阶段，执行 patch 更新节点</span><br>      <span class="hljs-title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, removeOnly)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 是真实元素，则表示初次渲染</span><br>      <span class="hljs-keyword">if</span> (isRealElement) &#123;<br>        <span class="hljs-comment">// 挂载到真实元素以及处理服务端渲染的情况</span><br>        <span class="hljs-comment">// mounting to a real element</span><br>        <span class="hljs-comment">// check if this is server-rendered content and if we can perform</span><br>        <span class="hljs-comment">// a successful hydration.</span><br>        <span class="hljs-keyword">if</span> (oldVnode.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span> &amp;&amp; oldVnode.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-variable constant_">SSR_ATTR</span>)) &#123;<br>          oldVnode.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-variable constant_">SSR_ATTR</span>)<br>          hydrating = <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(hydrating)) &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hydrate</span>(oldVnode, vnode, insertedVnodeQueue)) &#123;<br>            <span class="hljs-title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, <span class="hljs-literal">true</span>)<br>            <span class="hljs-keyword">return</span> oldVnode<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>            <span class="hljs-title function_">warn</span>(<br>              <span class="hljs-string">&#x27;The client-side rendered virtual DOM tree is not matching &#x27;</span> +<br>              <span class="hljs-string">&#x27;server-rendered content. This is likely caused by incorrect &#x27;</span> +<br>              <span class="hljs-string">&#x27;HTML markup, for example nesting block-level elements inside &#x27;</span> +<br>              <span class="hljs-string">&#x27;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#x27;</span> +<br>              <span class="hljs-string">&#x27;full client-side render.&#x27;</span><br>            )<br>          &#125;<br>        &#125;<br>        <span class="hljs-comment">// 走到这儿说明不是服务端渲染，或者 hydration 失败，则根据 oldVnode 创建一个 vnode 节点</span><br>        <span class="hljs-comment">// either not server-rendered, or hydration failed.</span><br>        <span class="hljs-comment">// create an empty node and replace it</span><br>        oldVnode = <span class="hljs-title function_">emptyNodeAt</span>(oldVnode)<br>      &#125;<br><br>      <span class="hljs-comment">// 拿到老节点的真实元素</span><br>      <span class="hljs-keyword">const</span> oldElm = oldVnode.<span class="hljs-property">elm</span><br>      <span class="hljs-comment">// 获取老节点的父元素，即 body</span><br>      <span class="hljs-keyword">const</span> parentElm = nodeOps.<span class="hljs-title function_">parentNode</span>(oldElm)<br><br>      <span class="hljs-comment">// 基于新 vnode 创建整棵 DOM 树并插入到 body 元素下</span><br>      <span class="hljs-title function_">createElm</span>(<br>        vnode,<br>        insertedVnodeQueue,<br>        <span class="hljs-comment">// extremely rare edge case: do not insert if old element is in a</span><br>        <span class="hljs-comment">// leaving transition. Only happens when combining transition +</span><br>        <span class="hljs-comment">// keep-alive + HOCs. (#4590)</span><br>        oldElm.<span class="hljs-property">_leaveCb</span> ? <span class="hljs-literal">null</span> : parentElm,<br>        nodeOps.<span class="hljs-title function_">nextSibling</span>(oldElm)<br>      )<br><br>      <span class="hljs-comment">// 递归更新父占位符节点元素</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(vnode.<span class="hljs-property">parent</span>)) &#123;<br>        <span class="hljs-keyword">let</span> ancestor = vnode.<span class="hljs-property">parent</span><br>        <span class="hljs-keyword">const</span> patchable = <span class="hljs-title function_">isPatchable</span>(vnode)<br>        <span class="hljs-keyword">while</span> (ancestor) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">destroy</span>.<span class="hljs-property">length</span>; ++i) &#123;<br>            cbs.<span class="hljs-property">destroy</span>[i](ancestor)<br>          &#125;<br>          ancestor.<span class="hljs-property">elm</span> = vnode.<span class="hljs-property">elm</span><br>          <span class="hljs-keyword">if</span> (patchable) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">create</span>.<span class="hljs-property">length</span>; ++i) &#123;<br>              cbs.<span class="hljs-property">create</span>[i](emptyNode, ancestor)<br>            &#125;<br>            <span class="hljs-comment">// #6513</span><br>            <span class="hljs-comment">// invoke insert hooks that may have been merged by create hooks.</span><br>            <span class="hljs-comment">// e.g. for directives that uses the &quot;inserted&quot; hook.</span><br>            <span class="hljs-keyword">const</span> insert = ancestor.<span class="hljs-property">data</span>.<span class="hljs-property">hook</span>.<span class="hljs-property">insert</span><br>            <span class="hljs-keyword">if</span> (insert.<span class="hljs-property">merged</span>) &#123;<br>              <span class="hljs-comment">// start at index 1 to avoid re-invoking component mounted hook</span><br>              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; insert.<span class="hljs-property">fns</span>.<span class="hljs-property">length</span>; i++) &#123;<br>                insert.<span class="hljs-property">fns</span>[i]()<br>              &#125;<br>            &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">registerRef</span>(ancestor)<br>          &#125;<br>          ancestor = ancestor.<span class="hljs-property">parent</span><br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 移除老节点</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(parentElm)) &#123;<br>        <span class="hljs-title function_">removeVnodes</span>([oldVnode], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">tag</span>)) &#123;<br>        <span class="hljs-title function_">invokeDestroyHook</span>(oldVnode)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, isInitialPatch)<br>  <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">elm</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="patchVNode"><a href="#patchVNode" class="headerlink" title="patchVNode"></a>patchVNode</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新节点</span><br><span class="hljs-comment"> *   全量的属性更新</span><br><span class="hljs-comment"> *   如果新老节点都有孩子，则递归执行 diff</span><br><span class="hljs-comment"> *   如果新节点有孩子，老节点没孩子，则新增新节点的这些孩子节点</span><br><span class="hljs-comment"> *   如果老节点有孩子，新节点没孩子，则删除老节点的这些孩子</span><br><span class="hljs-comment"> *   更新文本节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchVnode</span>(<span class="hljs-params"></span><br><span class="hljs-params">  oldVnode,</span><br><span class="hljs-params">  vnode,</span><br><span class="hljs-params">  insertedVnodeQueue,</span><br><span class="hljs-params">  ownerArray,</span><br><span class="hljs-params">  index,</span><br><span class="hljs-params">  removeOnly</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 老节点和新节点相同，直接返回</span><br>  <span class="hljs-keyword">if</span> (oldVnode === vnode) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(vnode.<span class="hljs-property">elm</span>) &amp;&amp; <span class="hljs-title function_">isDef</span>(ownerArray)) &#123;<br>    <span class="hljs-comment">// clone reused vnode</span><br>    vnode = ownerArray[index] = <span class="hljs-title function_">cloneVNode</span>(vnode)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> elm = vnode.<span class="hljs-property">elm</span> = oldVnode.<span class="hljs-property">elm</span><br><br>  <span class="hljs-comment">// 异步占位符节点</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(oldVnode.<span class="hljs-property">isAsyncPlaceholder</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(vnode.<span class="hljs-property">asyncFactory</span>.<span class="hljs-property">resolved</span>)) &#123;<br>      <span class="hljs-title function_">hydrate</span>(oldVnode.<span class="hljs-property">elm</span>, vnode, insertedVnodeQueue)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      vnode.<span class="hljs-property">isAsyncPlaceholder</span> = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// 跳过静态节点的更新</span><br>  <span class="hljs-comment">// reuse element for static trees.</span><br>  <span class="hljs-comment">// note we only do this if the vnode is cloned -</span><br>  <span class="hljs-comment">// if the new node is not cloned it means the render functions have been</span><br>  <span class="hljs-comment">// reset by the hot-reload-api and we need to do a proper re-render.</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(vnode.<span class="hljs-property">isStatic</span>) &amp;&amp;<br>    <span class="hljs-title function_">isTrue</span>(oldVnode.<span class="hljs-property">isStatic</span>) &amp;&amp;<br>    vnode.<span class="hljs-property">key</span> === oldVnode.<span class="hljs-property">key</span> &amp;&amp;<br>    (<span class="hljs-title function_">isTrue</span>(vnode.<span class="hljs-property">isCloned</span>) || <span class="hljs-title function_">isTrue</span>(vnode.<span class="hljs-property">isOnce</span>))<br>  ) &#123;<br>    <span class="hljs-comment">// 新旧节点都是静态的而且两个节点的 key 一样，并且新节点被 clone 了 或者 新节点有 v-once指令，则重用这部分节点</span><br>    vnode.<span class="hljs-property">componentInstance</span> = oldVnode.<span class="hljs-property">componentInstance</span><br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// 执行组件的 prepatch 钩子</span><br>  <span class="hljs-keyword">let</span> i<br>  <span class="hljs-keyword">const</span> data = vnode.<span class="hljs-property">data</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(data) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = data.<span class="hljs-property">hook</span>) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = i.<span class="hljs-property">prepatch</span>)) &#123;<br>    <span class="hljs-title function_">i</span>(oldVnode, vnode)<br>  &#125;<br><br>  <span class="hljs-comment">// 老节点的孩子</span><br>  <span class="hljs-keyword">const</span> oldCh = oldVnode.<span class="hljs-property">children</span><br>  <span class="hljs-comment">// 新节点的孩子</span><br>  <span class="hljs-keyword">const</span> ch = vnode.<span class="hljs-property">children</span><br>  <span class="hljs-comment">// 全量更新新节点的属性，Vue 3.0 在这里做了很多的优化</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(data) &amp;&amp; <span class="hljs-title function_">isPatchable</span>(vnode)) &#123;<br>    <span class="hljs-comment">// 执行新节点所有的属性更新</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">update</span>.<span class="hljs-property">length</span>; ++i) cbs.<span class="hljs-property">update</span>[i](oldVnode, vnode)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(i = data.<span class="hljs-property">hook</span>) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = i.<span class="hljs-property">update</span>)) <span class="hljs-title function_">i</span>(oldVnode, vnode)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(vnode.<span class="hljs-property">text</span>)) &#123;<br>    <span class="hljs-comment">// 新节点不是文本节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isDef</span>(ch)) &#123;<br>      <span class="hljs-comment">// 如果新老节点都有孩子，则递归执行 diff 过程</span><br>      <span class="hljs-keyword">if</span> (oldCh !== ch) <span class="hljs-title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(ch)) &#123;<br>      <span class="hljs-comment">// 老孩子不存在，新孩子存在，则创建这些新孩子节点</span><br>      <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>        <span class="hljs-title function_">checkDuplicateKeys</span>(ch)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">text</span>)) nodeOps.<span class="hljs-title function_">setTextContent</span>(elm, <span class="hljs-string">&#x27;&#x27;</span>)<br>      <span class="hljs-title function_">addVnodes</span>(elm, <span class="hljs-literal">null</span>, ch, <span class="hljs-number">0</span>, ch.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, insertedVnodeQueue)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh)) &#123;<br>      <span class="hljs-comment">// 老孩子存在，新孩子不存在，则移除这些老孩子节点</span><br>      <span class="hljs-title function_">removeVnodes</span>(oldCh, <span class="hljs-number">0</span>, oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">text</span>)) &#123;<br>      <span class="hljs-comment">// 老节点是文本节点，则将文本内容置空</span><br>      nodeOps.<span class="hljs-title function_">setTextContent</span>(elm, <span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldVnode.<span class="hljs-property">text</span> !== vnode.<span class="hljs-property">text</span>) &#123;<br>    <span class="hljs-comment">// 新节点是文本节点，则更新文本节点</span><br>    nodeOps.<span class="hljs-title function_">setTextContent</span>(elm, vnode.<span class="hljs-property">text</span>)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(data)) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(i = data.<span class="hljs-property">hook</span>) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = i.<span class="hljs-property">postpatch</span>)) <span class="hljs-title function_">i</span>(oldVnode, vnode)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * diff 过程:</span><br><span class="hljs-comment"> *   diff 优化：做了四种假设，假设新老节点开头结尾有相同节点的情况，一旦命中假设，就避免了一次循环，以提高执行效率</span><br><span class="hljs-comment"> *             如果不幸没有命中假设，则执行遍历，从老节点中找到新开始节点</span><br><span class="hljs-comment"> *             找到相同节点，则执行 patchVnode，然后将老节点移动到正确的位置</span><br><span class="hljs-comment"> *   如果老节点先于新节点遍历结束，则剩余的新节点执行新增节点操作</span><br><span class="hljs-comment"> *   如果新节点先于老节点遍历结束，则剩余的老节点执行删除操作，移除这些老节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span>(<span class="hljs-params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) &#123;<br>  <span class="hljs-comment">// 老节点的开始索引</span><br>  <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 新节点的开始索引</span><br>  <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 老节点的结束索引</span><br>  <span class="hljs-keyword">let</span> oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <span class="hljs-comment">// 第一个老节点</span><br>  <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>]<br>  <span class="hljs-comment">// 最后一个老节点</span><br>  <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx]<br>  <span class="hljs-comment">// 新节点的结束索引</span><br>  <span class="hljs-keyword">let</span> newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <span class="hljs-comment">// 第一个新节点</span><br>  <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>]<br>  <span class="hljs-comment">// 最后一个新节点</span><br>  <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx]<br>  <span class="hljs-keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm<br><br>  <span class="hljs-comment">// removeOnly是一个特殊的标志，仅由 &lt;transition-group&gt; 使用，以确保被移除的元素在离开转换期间保持在正确的相对位置</span><br>  <span class="hljs-keyword">const</span> canMove = !removeOnly<br><br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 检查新节点的 key 是否重复</span><br>    <span class="hljs-title function_">checkDuplicateKeys</span>(newCh)<br>  &#125;<br><br>  <span class="hljs-comment">// 遍历新老两组节点，只要有一组遍历完（开始索引超过结束索引）则跳出循环</span><br>  <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldStartVnode)) &#123;<br>      <span class="hljs-comment">// 如果节点被移动，在当前索引上可能不存在，检测这种情况，如果节点不存在则调整索引</span><br>      oldStartVnode = oldCh[++oldStartIdx] <span class="hljs-comment">// Vnode has been moved left</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldEndVnode)) &#123;<br>      oldEndVnode = oldCh[--oldEndIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;<br>      <span class="hljs-comment">// 老开始节点和新开始节点是同一个节点，执行 patch</span><br>      <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)<br>      <span class="hljs-comment">// patch 结束后老开始和新开始的索引分别加 1</span><br>      oldStartVnode = oldCh[++oldStartIdx]<br>      newStartVnode = newCh[++newStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;<br>      <span class="hljs-comment">// 老结束和新结束是同一个节点，执行 patch</span><br>      <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)<br>      <span class="hljs-comment">// patch 结束后老结束和新结束的索引分别减 1</span><br>      oldEndVnode = oldCh[--oldEndIdx]<br>      newEndVnode = newCh[--newEndIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="hljs-comment">// Vnode moved right</span><br>      <span class="hljs-comment">// 老开始和新结束是同一个节点，执行 patch</span><br>      <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)<br>      <span class="hljs-comment">// 处理被 transtion-group 包裹的组件时使用</span><br>      canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="hljs-property">elm</span>, nodeOps.<span class="hljs-title function_">nextSibling</span>(oldEndVnode.<span class="hljs-property">elm</span>))<br>      <span class="hljs-comment">// patch 结束后老开始索引加 1，新结束索引减 1</span><br>      oldStartVnode = oldCh[++oldStartIdx]<br>      newEndVnode = newCh[--newEndIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="hljs-comment">// Vnode moved left</span><br>      <span class="hljs-comment">// 老结束和新开始是同一个节点，执行 patch</span><br>      <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)<br>      canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)<br>      <span class="hljs-comment">// patch 结束后，老结束的索引减 1，新开始的索引加 1</span><br>      oldEndVnode = oldCh[--oldEndIdx]<br>      newStartVnode = newCh[++newStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果上面的四种假设都不成立，则通过遍历找到新开始节点在老节点中的位置索引</span><br><br>      <span class="hljs-comment">// 找到老节点中每个节点 key 和 索引之间的关系映射 =&gt; oldKeyToIdx = &#123; key1: idx1, ... &#125;</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldKeyToIdx)) oldKeyToIdx = <span class="hljs-title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)<br>      <span class="hljs-comment">// 在映射中找到新开始节点在老节点中的位置索引</span><br>      idxInOld = <span class="hljs-title function_">isDef</span>(newStartVnode.<span class="hljs-property">key</span>)<br>        ? oldKeyToIdx[newStartVnode.<span class="hljs-property">key</span>]<br>        : <span class="hljs-title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx)<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(idxInOld)) &#123; <span class="hljs-comment">// New element</span><br>        <span class="hljs-comment">// 在老节点中没找到新开始节点，则说明是新创建的元素，执行创建</span><br>        <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="hljs-property">elm</span>, <span class="hljs-literal">false</span>, newCh, newStartIdx)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 在老节点中找到新开始节点了</span><br>        vnodeToMove = oldCh[idxInOld]<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;<br>          <span class="hljs-comment">// 如果这两个节点是同一个，则执行 patch</span><br>          <span class="hljs-title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)<br>          <span class="hljs-comment">// patch 结束后将该老节点置为 undefined</span><br>          oldCh[idxInOld] = <span class="hljs-literal">undefined</span><br>          canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 最后这种情况是，找到节点了，但是发现两个节点不是同一个节点，则视为新元素，执行创建</span><br>          <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="hljs-property">elm</span>, <span class="hljs-literal">false</span>, newCh, newStartIdx)<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 老节点向后移动一个</span><br>      newStartVnode = newCh[++newStartIdx]<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 走到这里，说明老姐节点或者新节点被遍历完了</span><br>  <span class="hljs-keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;<br>    <span class="hljs-comment">// 说明老节点被遍历完了，新节点有剩余，则说明这部分剩余的节点是新增的节点，然后添加这些节点</span><br>    refElm = <span class="hljs-title function_">isUndef</span>(newCh[newEndIdx + <span class="hljs-number">1</span>]) ? <span class="hljs-literal">null</span> : newCh[newEndIdx + <span class="hljs-number">1</span>].<span class="hljs-property">elm</span><br>    <span class="hljs-title function_">addVnodes</span>(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;<br>    <span class="hljs-comment">// 说明新节点被遍历完了，老节点有剩余，说明这部分的节点被删掉了，则移除这些节点</span><br>    <span class="hljs-title function_">removeVnodes</span>(oldCh, oldStartIdx, oldEndIdx)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="你能说一说-Vue-的-patch-算法吗？"><a href="#你能说一说-Vue-的-patch-算法吗？" class="headerlink" title="你能说一说 Vue 的 patch 算法吗？"></a>你能说一说 Vue 的 patch 算法吗？</h3><p>Vue 的 patch 算法有三个作用：负责首次渲染和后续更新或者销毁组件</p><ul><li><p>如果老的 VNode 是真实元素，则表示首次渲染，创建整棵 DOM 树，并插入 body，然后移除老的模版节点</p></li><li><p>如果老的 VNode 不是真实元素，并且新的 VNode 也存在，则表示更新阶段，执行 patchVnode</p><ul><li><p>首先是全量更新所有的属性</p></li><li><p>如果新老 VNode 都有孩子，则递归执行 updateChildren，进行 diff 过程</p><blockquote><p>针对前端操作 DOM 节点的特点进行如下优化：</p></blockquote><ul><li>同层比较（降低时间复杂度）深度优先（递归）</li><li>而且前端很少有完全打乱节点顺序的情况，所以做了四种假设，假设新老 VNode 的开头结尾存在相同节点，一旦命中假设，就避免了一次循环，降低了 diff 的时间复杂度，提高执行效率。如果不幸没有命中假设，则执行遍历，从老的 VNode 中找到新的 VNode 的开始节点</li><li>找到相同节点，则执行 patchVnode，然后将老节点移动到正确的位置</li><li>如果老的 VNode 先于新的 VNode 遍历结束，则剩余的新的 VNode 执行新增节点操作</li><li>如果新的 VNode 先于老的 VNode 遍历结束，则剩余的老的 VNode 执行删除操纵，移除这些老节点</li></ul></li><li><p>如果新的 VNode 有孩子，老的 VNode 没孩子，则新增这些新孩子节点</p></li><li><p>如果老的 VNode 有孩子，新的 VNode 没孩子，则删除这些老孩子节点</p></li><li><p>剩下一种就是更新文本节点</p></li></ul></li><li><p>如果新的 VNode 不存在，老的 VNode 存在，则调用 destroy，销毁老节点</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6964141635856760868">https://juejin.cn/post/6964141635856760868</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>9.【转载】render helper</title>
    <link href="/2022/10/26/9-render-helper/"/>
    <url>/2022/10/26/9-render-helper/</url>
    
    <content type="html"><![CDATA[<h1 id="render-helper"><a href="#render-helper" class="headerlink" title="render helper"></a>render helper</h1><h2 id="什么是-render-helper"><a href="#什么是-render-helper" class="headerlink" title="什么是 render helper"></a>什么是 render helper</h2><p>在 编译器 中我们说到，编译器最后会生成渲染函数。组件更新时，执行渲染函数，就可以得到组件的 vnode。</p><p>渲染函数之所以能生成 vnode 是通过其中的 <code>_c、_l、_v、_s</code> 等方法实现的，在 编译后 的代码中我们能看到很多类似函数的调用</p><ul><li>普通的节点被编译成了可执行 _c 函数</li><li>v-for 节点被编译成了可执行的 _l 函数</li><li>…</li></ul><p>作用总结：<strong>在 Vue 实例上挂载一些运行时的工具方法，这些方法用在编译器生成的渲染函数中，用于生成组件的 VNode。</strong></p><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>Vue 实例的入口文件（2-Vue初始化过程），包括 Vue 构造函数的定义、各个实例方法的初始化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Vue 的构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span> (options) &#123;<br>  <span class="hljs-comment">// 调用 Vue.prototype._init 方法，该方法是在 initMixin 中定义的</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options)<br>&#125;<br><br><span class="hljs-comment">// 定义 Vue.prototype._init 方法</span><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义：</span><br><span class="hljs-comment"> *   Vue.prototype.$data</span><br><span class="hljs-comment"> *   Vue.prototype.$props</span><br><span class="hljs-comment"> *   Vue.prototype.$set</span><br><span class="hljs-comment"> *   Vue.prototype.$delete</span><br><span class="hljs-comment"> *   Vue.prototype.$watch</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">stateMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义 事件相关的 方法：</span><br><span class="hljs-comment"> *   Vue.prototype.$on</span><br><span class="hljs-comment"> *   Vue.prototype.$once</span><br><span class="hljs-comment"> *   Vue.prototype.$off</span><br><span class="hljs-comment"> *   Vue.prototype.$emit</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">eventsMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义：</span><br><span class="hljs-comment"> *   Vue.prototype._update</span><br><span class="hljs-comment"> *   Vue.prototype.$forceUpdate</span><br><span class="hljs-comment"> *   Vue.prototype.$destroy</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行 installRenderHelpers，在 Vue.prototype 对象上安装运行时便利程序</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 定义：</span><br><span class="hljs-comment"> *   Vue.prototype.$nextTick</span><br><span class="hljs-comment"> *   Vue.prototype._render</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">renderMixin</span>(<span class="hljs-title class_">Vue</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderMixin</span> (<span class="hljs-title class_">Vue</span>: <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">Component</span>&gt;) &#123;<br>  <span class="hljs-comment">// install runtime convenience helpers</span><br>  <span class="hljs-comment">// 在组件实例上挂载一些运行时需要用到的工具方法</span><br>  <span class="hljs-title function_">installRenderHelpers</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>初始化时调用了 renderMixin，renderMixin 中调用了 Install RenderHelpers 挂载一些工具方法，也就是 _o _c 等等</p><h2 id="installRenderHelpers"><a href="#installRenderHelpers" class="headerlink" title="installRenderHelpers"></a>installRenderHelpers</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在实例上挂载简写的渲染工具函数，这些都是运行时代码</span><br><span class="hljs-comment"> * 这些工具函数在编译器生成的渲染函数中被使用到了</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; target Vue 实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">installRenderHelpers</span>(<span class="hljs-params">target: any</span>) &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * v-once 指令的运行时帮助程序，为 VNode 加上打上静态标记</span><br><span class="hljs-comment">   * 有点多余，因为含有 v-once 指令的节点都被当作静态节点处理了，所以也不会走这儿</span><br><span class="hljs-comment">   */</span><br>  target.<span class="hljs-property">_o</span> = markOnce<br>  <span class="hljs-comment">// 将值转换为数字</span><br>  target.<span class="hljs-property">_n</span> = toNumber<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 将值转换为字符串形式，普通值 =&gt; String(val)，对象 =&gt; JSON.stringify(val)</span><br><span class="hljs-comment">   */</span><br>  target.<span class="hljs-property">_s</span> = toString<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 运行时渲染 v-for 列表的帮助函数，循环遍历 val 值，依次为每一项执行 render 方法生成 VNode，最终返回一个 VNode 数组</span><br><span class="hljs-comment">   */</span><br>  target.<span class="hljs-property">_l</span> = renderList<br>  target.<span class="hljs-property">_t</span> = renderSlot<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 判断两个值是否相等</span><br><span class="hljs-comment">   */</span><br>  target.<span class="hljs-property">_q</span> = looseEqual<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 相当于 indexOf 方法</span><br><span class="hljs-comment">   */</span><br>  target.<span class="hljs-property">_i</span> = looseIndexOf<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 运行时负责生成静态树的 VNode 的帮助程序，完成了以下两件事</span><br><span class="hljs-comment">   *   1、执行 staticRenderFns 数组中指定下标的渲染函数，生成静态树的 VNode 并缓存，下次在渲染时从缓存中直接读取（isInFor 必须为 true）</span><br><span class="hljs-comment">   *   2、为静态树的 VNode 打静态标记</span><br><span class="hljs-comment">   */</span><br>  target.<span class="hljs-property">_m</span> = renderStatic<br>  target.<span class="hljs-property">_f</span> = resolveFilter<br>  target.<span class="hljs-property">_k</span> = checkKeyCodes<br>  target.<span class="hljs-property">_b</span> = bindObjectProps<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 为文本节点创建 VNode</span><br><span class="hljs-comment">   */</span><br>  target.<span class="hljs-property">_v</span> = createTextVNode<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 为空节点创建 VNode</span><br><span class="hljs-comment">   */</span><br>  target.<span class="hljs-property">_e</span> = createEmptyVNode<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="一个组件是如何变成-VNode？"><a href="#一个组件是如何变成-VNode？" class="headerlink" title="一个组件是如何变成 VNode？"></a>一个组件是如何变成 VNode？</h3><ul><li>组件实例初始化，最后执行 $mount 进入挂载阶段</li><li>如果是只包含运行时的 vue.js，则直接进入挂载阶段，因为这时候的组件已经变成了渲染函数，编译过程通过模块打包器 + vue-loader + vue-template-compiler 完成的</li><li>如果没有使用预编译，则必须使用全量的 vue.js</li><li>挂载时如果发现组件配置项上没有 render 选项，则进入编译阶段</li><li>将模版字符串编译成 AST 语法树，其实就是一个普通的 JS 对象</li><li>然后优化 AST，遍历 AST 对象，标记每一个节点是否为静态静态；然后再进一步标记出静态根节点，在组件后续更新时会跳过这些静态节点的更新，以提高性能</li><li>接下来从 AST 生成渲染函数，生成的渲染函数有两部分组成：<ul><li>负责生成动态节点 VNode 的 render 函数</li><li>还有一个 staticRenderFns 数组，里面每一个元素都是一个生成静态节点 VNode 的函数，这些函数会作为 render 函数的组成部分，负责生成静态节点的 VNode</li></ul></li><li>接下来将渲染函数放到组件的配置对象上，进入挂载阶段，即执行 mountComponent 方法</li><li>最终负责渲染组件和更新组件的是一个叫 updateComponent 方法，该方法每次执行前首先需要执行 vm._render 函数，该函数负责执行编译器生成的 render，得到组件的 VNode</li><li>将一个组件生成 VNode 的具体工作是由 render 函数中的 <code>_c、_o、_l、_m</code> 等方法完成的，这些方法都被挂载到 Vue 实例上面，负责在运行时生成组件 VNode</li></ul><blockquote><p>下面说的有点多，其实记住一句就可以了，设置组件配置信息，然后通过 <code>new VNode(组件信息)</code> 生成组件的 VNode</p></blockquote><ul><li>_c，负责生成组件或 HTML 元素的 VNode，_c 是所有 render helper 方法中最复杂，也是最核心的一个方法，其它的 _xx 都是它的组成部分<ul><li>接收标签、属性 JSON 字符串、子节点数组、节点规范化类型作为参数</li><li>如果标签是平台保留标签或者一个未知的元素，则直接 <code>new VNode(标签信息)</code> 得到 VNode</li><li>如果标签是一个组件，则执行 createComponent 方法生成 VNode<ul><li>函数式组件执行自己的 render 函数生成 VNode</li><li>普通组件则实例化一个 VNode，并且在在 data.hook 对象上设置 4 个方法，在组件的 patch 阶段会被调用，从而进入子组件的实例化、挂载阶段，然后进行编译生成渲染函数，直至完成渲染</li><li>当然生成 VNode 之前会进行一些配置处理比如：<ul><li>子组件选项合并，合并全局配置项到组件配置项上</li><li>处理自定义组件的 v-model</li><li>处理组件的 props，提取组件的 props 数据，以组件的 props 配置中的属性为 key，父组件中对应的数据为 value 生成一个 propsData 对象；当组件更新时生成新的 VNode，又会进行这一步，这就是 props 响应式的原理</li><li>处理其它数据，比如监听器</li><li>安装内置的 init、prepatch、insert、destroy 钩子到 data.hooks 对象上，组件 patch 阶段会用到这些钩子方法</li></ul></li></ul></li></ul></li><li>_l，运行时渲染 v-for 列表的帮助函数，循环遍历 val 值，依次为每一项执行 render 方法生成 VNode，最终返回一个 VNode 数组</li><li>_m，负责生成静态节点的 VNode，即执行 staticRenderFns 数组中指定下标的函数</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6963048982079602696">https://juejin.cn/post/6963048982079602696</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8.编译器</title>
    <link href="/2022/10/26/8-%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <url>/2022/10/26/8-%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>编译器源码过于复杂，其中包含过多边界处理和平台构建的代码，直接放上我看的他人解读的链接。</p><p><a href="https://juejin.cn/post/6959019076983209992">https://juejin.cn/post/6959019076983209992</a></p><p><a href="https://juejin.cn/post/6959019174215548935">https://juejin.cn/post/6959019174215548935</a></p><p><a href="https://juejin.cn/post/6960465810682806308">https://juejin.cn/post/6960465810682806308</a></p><p><a href="https://juejin.cn/post/6961545472204865572">https://juejin.cn/post/6961545472204865572</a></p><p>这篇文章主要是梳理一下脉络</p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>编译器的核心由三部分组成：</p><ul><li><strong>解析 - parse</strong>，将类 html 模版转换为 AST 对象</li><li><strong>优化 - optimize</strong>，也叫静态标记，遍历 AST 对象，标记每个节点是否为静态节点（没有响应式数据的节点），以及标记出静态根节点</li><li><strong>生成渲染函数 - generate</strong>，将 AST 对象生成渲染函数</li></ul><h2 id="图解流程"><a href="#图解流程" class="headerlink" title="图解流程"></a>图解流程</h2><p><img src="file://D:/%E5%AD%A6%E4%B9%A0/myblog/source/_posts/Mini-Vue/13429147-32832d6b08b108c4.jpg?lastModify=1666753584" alt="img"></p><h2 id="入口与流程"><a href="#入口与流程" class="headerlink" title="入口与流程"></a>入口与流程</h2><ol><li><strong>在 2-Vue初始化过程 中提到，初始化（Vue.prototype._init）的最后一步就是执行 &amp;mount 进行挂载。</strong></li></ol><p>在 Vue 全量包中，此时就会进入编译阶段。</p><p>而运行时的 Vue 包中，会通过 打包器 结合 vue-loader + vue-compiler-utils 进行预编译，将模版编译成 render 函数。</p><ol start="2"><li><strong>在 Vue.$mount 中，只做了一件事情，得到组件的渲染函数，将其设置到 this.$options 上</strong></li></ol><p>如果用户提供了 render 配置项，就跳过编译阶段，否则进入编译阶段，解析 template 和 el，转换为 render 函数。在这个过程中会调用很多函数，但是大多数对于用户来说都不重要，它们实在帮助构建平台的配置。其中有一个核心的函数叫 baseCompile.</p><ol start="3"><li><strong>baseCompile 是核心解析函数</strong></li></ol><p>其中调用了三个函数 parse &#x2F; optimize &#x2F; generate</p><p>parse - 将 html 模板解析成 ast</p><p>optimize - 对 ast 树进行静态标记</p><p>generate - 将 ast 生成渲染函数，静态渲染函数放到 code.staticRenderFns 数组中，code.render 是动态渲染函数</p><p>在将来渲染的时候执行渲染函数得到 vnode</p><p>关于 parse &#x2F; optimize &#x2F; generate 的细节还是直接看源码和面试题吧</p><h2 id="编译前编译后"><a href="#编译前编译后" class="headerlink" title="编译前编译后"></a>编译前编译后</h2><p>编译前 html 模板</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in arr&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编译后 渲染函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">with</span> (<span class="hljs-variable language_">this</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">_c</span>(<br>    <span class="hljs-string">&#x27;div&#x27;</span>,<br>    &#123;<br>      <span class="hljs-attr">attrs</span>:<br>      &#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;app&quot;</span><br>      &#125;<br>    &#125;,<br>    <span class="hljs-title function_">_l</span>(<br>      (arr),<br>      <span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">_c</span>(<br>          <span class="hljs-string">&#x27;div&#x27;</span>,<br>          &#123;<br>            <span class="hljs-attr">key</span>: item<br>          &#125;,<br>          [<span class="hljs-title function_">_v</span>(<span class="hljs-title function_">_s</span>(item))]<br>        )<br>      &#125;<br>    ),<br>    <span class="hljs-number">0</span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>with</code> 语句可以扩展作用域链，所以生成的代码中的 <code>_c、_l、_v、_s</code> 都是 this 上一些方法，也就是说在运行时执行这些方法可以生成各个节点的 vnode。</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="简单说一下-Vue-的编译器"><a href="#简单说一下-Vue-的编译器" class="headerlink" title="简单说一下 Vue 的编译器"></a>简单说一下 Vue 的编译器</h3><p>Vue 的编译器做了三件事情：</p><ul><li>将组件的 html 模版解析成 AST 对象</li><li>优化，遍历 AST，为每个节点做静态标记，标记其是否为静态节点，然后进一步标记出静态根节点，这样在后续更新的过程中就可以跳过这些静态节点了；标记静态根用于生成渲染函数阶段，生成静态根节点的渲染函数</li><li>从 AST 生成运行时的渲染函数，即大家说的 render，其实还有一个，就是 staticRenderFns 数组，里面存放了所有的静态节点的渲染函数</li></ul><h3 id="详细说一说编译器的-x3D-x3D-解析-x3D-x3D-过程，它是怎么将-html-字符串模版变成-AST-对象的？"><a href="#详细说一说编译器的-x3D-x3D-解析-x3D-x3D-过程，它是怎么将-html-字符串模版变成-AST-对象的？" class="headerlink" title="详细说一说编译器的&#x3D;&#x3D;解析&#x3D;&#x3D;过程，它是怎么将 html 字符串模版变成 AST 对象的？"></a>详细说一说编译器的&#x3D;&#x3D;解析&#x3D;&#x3D;过程，它是怎么将 html 字符串模版变成 AST 对象的？</h3><ul><li><p>遍历 HTML 模版字符串，通过正则表达式匹配 “&lt;”</p></li><li><p>跳过某些不需要处理的标签，比如：注释标签、条件注释标签、Doctype。</p><blockquote><p>备注：整个解析过程的核心是处理开始标签和结束标签</p></blockquote></li><li><p>解析开始标签</p><ul><li>得到一个对象，包括 标签名（tagName）、所有的属性（attrs）、标签在 html 模版字符串中的索引位置</li><li>进一步处理上一步得到的 attrs 属性，将其变成 [{ name: attrName, value: attrVal, start: xx, end: xx }, …] 的形式</li><li>通过标签名、属性对象和当前元素的父元素生成 AST 对象，其实就是一个 普通的 JS 对象，通过 key、value 的形式记录了该元素的一些信息</li><li>接下来进一步处理开始标签上的一些指令，比如 v-pre、v-for、v-if、v-once，并将处理结果放到 AST 对象上</li><li>处理结束将 ast 对象存放到 stack 数组</li><li>处理完成后会截断 html 字符串，将已经处理掉的字符串截掉</li></ul></li><li><p>解析闭合标签</p><ul><li>如果匹配到结束标签，就从 stack 数组中拿出最后一个元素，它和当前匹配到的结束标签是一对。</li><li>再次处理开始标签上的属性，这些属性和前面处理的不一样，比如：key、ref、scopedSlot、样式等，并将处理结果放到元素的 AST 对象上</li><li>然后将当前元素和父元素产生联系，给当前元素的 ast 对象设置 parent 属性，然后将自己放到父元素的 ast 对象的 children 数组中</li></ul></li><li><p>最后遍历完整个 html 模版字符串以后，返回 ast 对象</p></li></ul><h3 id="详细说一下静态标记（-x3D-x3D-优化-x3D-x3D-）的过程"><a href="#详细说一下静态标记（-x3D-x3D-优化-x3D-x3D-）的过程" class="headerlink" title="详细说一下静态标记（&#x3D;&#x3D;优化&#x3D;&#x3D;）的过程"></a>详细说一下静态标记（&#x3D;&#x3D;优化&#x3D;&#x3D;）的过程</h3><ul><li><p>标记静态节点</p><ul><li>通过递归的方式标记所有的元素节点</li><li>如果节点本身是静态节点，但是存在非静态的子节点，则将节点修改为非静态节点</li></ul></li><li><p>标记静态根节点，基于静态节点，进一步标记静态根节点</p><ul><li>如果节点本身是静态节点 &amp;&amp; 而且有子节点 &amp;&amp; 子节点不全是文本节点，则标记为静态根节点</li><li>如果节点本身不是静态根节点，则递归的遍历所有子节点，在子节点中标记静态根</li></ul></li></ul><h3 id="什么样的节点才可以被标记为静态节点？"><a href="#什么样的节点才可以被标记为静态节点？" class="headerlink" title="什么样的节点才可以被标记为静态节点？"></a>什么样的节点才可以被标记为静态节点？</h3><ul><li>文本节点</li><li>节点上没有 v-bind、v-for、v-if 等指令</li><li>非组件</li></ul><h3 id="为什么要静态标记"><a href="#为什么要静态标记" class="headerlink" title="为什么要静态标记"></a>为什么要静态标记</h3><p>优化 patch 函数，静态节点都是不变的，因此在 patch 时应该直接跳过。</p><p>Vue3 进一步优化，使用 patchFlags 来标记从未发生改变的节点。</p><h3 id="渲染函数的-x3D-x3D-生成-x3D-x3D-过程"><a href="#渲染函数的-x3D-x3D-生成-x3D-x3D-过程" class="headerlink" title="渲染函数的&#x3D;&#x3D;生成&#x3D;&#x3D;过程"></a>渲染函数的&#x3D;&#x3D;生成&#x3D;&#x3D;过程</h3><p>大家一说到渲染函数，基本上说的就是 render 函数，其实编译器生成的渲染有两类：</p><ul><li>第一类就是一个 render 函数，负责生成动态节点的 vnode</li><li>第二类是放在一个叫 staticRenderFns 数组中的静态渲染函数，这些函数负责生成静态节点的 vnode</li></ul><p>渲染函数生成的过程，其实就是在遍历 AST 节点，通过递归的方式，处理每个节点，最后生成形如：<code>_c(tag, attr, children, normalizationType)</code> 的结果。tag 是标签名，attr 是属性对象，children 是子节点组成的数组，其中每个元素的格式都是 <code>_c(tag, attr, children, normalizationTYpe)</code> 的形式，normalization 表示节点的规范化类型，是一个数字 0、1、2，不重要。</p><p>在处理 AST 节点过程中需要大家重点关注也是面试中常见的问题有：</p><ul><li><p>静态节点是怎么处理的</p><p>静态节点的处理分为两步：</p><ul><li>将生成静态节点 vnode 函数放到 staticRenderFns 数组中</li><li>返回一个 _m(idx) 的可执行函数，意思是执行 staticRenderFns 数组中下标为 idx 的函数，生成静态节点的 vnode</li></ul></li><li><p>v-once、v-if、v-for、组件 等都是怎么处理的</p><ul><li>单纯的 v-once 节点处理方式和静态节点一致</li><li>v-if 节点的处理结果是一个三元表达式</li><li>v-for 节点的处理结果是可执行的 _l 函数，该函数负责生成 v-for 节点的 vnode</li><li>组件的处理结果和普通元素一样，得到的是形如 <code>_c(compName)</code> 的可执行代码，生成组件的 vnode</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7.【转载】Hook Event</title>
    <link href="/2022/10/25/7-Hook-Event/"/>
    <url>/2022/10/25/7-Hook-Event/</url>
    
    <content type="html"><![CDATA[<h1 id="Hook-Event"><a href="#Hook-Event" class="headerlink" title="Hook Event"></a>Hook Event</h1><h2 id="什么是-Hook-Event"><a href="#什么是-Hook-Event" class="headerlink" title="什么是 Hook Event"></a>什么是 Hook Event</h2><p>Hook Event 是 Vue 的自定义事件结合生命周期钩子实现的一种从组件外部为组件注入额外生命周期方法的功能。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="callHook"><a href="#callHook" class="headerlink" title="callHook"></a>callHook</h3><p>Vue 的生命周期函数是通过一个叫 <code>callHook</code> 的方法来执行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * callHook(vm, &#x27;mounted&#x27;)</span><br><span class="hljs-comment"> * 执行实例指定的生命周期钩子函数</span><br><span class="hljs-comment"> * 如果实例设置有对应的 Hook Event，比如：&lt;comp <span class="hljs-doctag">@hook</span>:mounted=&quot;method&quot; /&gt;，执行完生命周期函数之后，触发该事件的执行</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; vm 组件实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; hook 生命周期钩子函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">callHook</span> (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>, <span class="hljs-attr">hook</span>: string) &#123;<br>  <span class="hljs-comment">// 在执行生命周期钩子函数期间禁止依赖收集</span><br>  <span class="hljs-title function_">pushTarget</span>()<br>  <span class="hljs-comment">// 从实例配置对象中获取指定钩子函数，比如 mounted</span><br>  <span class="hljs-keyword">const</span> handlers = vm.<span class="hljs-property">$options</span>[hook]<br>  <span class="hljs-comment">// mounted hook</span><br>  <span class="hljs-keyword">const</span> info = <span class="hljs-string">`<span class="hljs-subst">$&#123;hook&#125;</span> hook`</span><br>  <span class="hljs-keyword">if</span> (handlers) &#123;<br>    <span class="hljs-comment">// 通过 invokeWithErrorHandler 执行生命周期钩子</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = handlers.<span class="hljs-property">length</span>; i &lt; j; i++) &#123;<br>      <span class="hljs-title function_">invokeWithErrorHandling</span>(handlers[i], vm, <span class="hljs-literal">null</span>, vm, info)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// Hook Event，如果设置了 Hook Event，比如 &lt;comp @hook:mounted=&quot;method&quot; /&gt;，则通过 $emit 触发该事件</span><br>  <span class="hljs-comment">// vm._hasHookEvent 标识组件是否有 hook event，这是在 vm.$on 中处理组件自定义事件时设置的</span><br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_hasHookEvent</span>) &#123;<br>    <span class="hljs-comment">// vm.$emit(&#x27;hook:mounted&#x27;)</span><br>    vm.$emit(<span class="hljs-string">&#x27;hook:&#x27;</span> + hook)<br>  &#125;<br>  <span class="hljs-comment">// 关闭依赖收集</span><br>  <span class="hljs-title function_">popTarget</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="invokeWithErrorHandling"><a href="#invokeWithErrorHandling" class="headerlink" title="invokeWithErrorHandling"></a>invokeWithErrorHandling</h3><p>通用函数，这里用于执行生命周期钩子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通用函数，执行指定函数 handler</span><br><span class="hljs-comment"> * 传递进来的函数会被用 try catch 包裹，进行异常捕获处理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">invokeWithErrorHandling</span> (<br>  <span class="hljs-attr">handler</span>: <span class="hljs-title class_">Function</span>,<br>  <span class="hljs-attr">context</span>: any,<br>  <span class="hljs-attr">args</span>: <span class="hljs-literal">null</span> | any[],<br>  <span class="hljs-attr">vm</span>: any,<br>  <span class="hljs-attr">info</span>: string<br>) &#123;<br>  <span class="hljs-keyword">let</span> res<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 执行传递进来的函数 handler，并将执行结果返回</span><br>    res = args ? handler.<span class="hljs-title function_">apply</span>(context, args) : handler.<span class="hljs-title function_">call</span>(context)<br>    <span class="hljs-keyword">if</span> (res &amp;&amp; !res.<span class="hljs-property">_isVue</span> &amp;&amp; <span class="hljs-title function_">isPromise</span>(res) &amp;&amp; !res.<span class="hljs-property">_handled</span>) &#123;<br>      res.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-title function_">handleError</span>(e, vm, info + <span class="hljs-string">` (Promise/async)`</span>))<br>      <span class="hljs-comment">// issue #9511</span><br>      <span class="hljs-comment">// avoid catch triggering multiple times when nested calls</span><br>      res.<span class="hljs-property">_handled</span> = <span class="hljs-literal">true</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-title function_">handleError</span>(e, vm, info)<br>  &#125;<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vm-on"><a href="#vm-on" class="headerlink" title="vm.$on"></a>vm.$on</h3><p>设置 vm._hasHookEvent，表示组件是否有 hook event，如果有的话，callHook 中会在生命周期钩子执行完毕后执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 监听实例上的自定义事件，vm._event = &#123; eventName: [fn1, ...], ... &#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; event 单个的事件名称或者有多个事件名组成的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; fn 当 event 被触发时执行的回调函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$on</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event: string | <span class="hljs-built_in">Array</span>&lt;string&gt;, fn: <span class="hljs-built_in">Function</span></span>): <span class="hljs-title class_">Component</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(event)) &#123;<br>    <span class="hljs-comment">// event 是有多个事件名组成的数组，则遍历这些事件，依次递归调用 $on</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = event.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>      vm.$on(event[i], fn)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 将注册的事件和回调以键值对的形式存储到 vm._event 对象中 vm._event = &#123; eventName: [fn1, ...] &#125;</span><br>    (vm.<span class="hljs-property">_events</span>[event] || (vm.<span class="hljs-property">_events</span>[event] = [])).<span class="hljs-title function_">push</span>(fn)<br>    <span class="hljs-comment">// hookEvent，提供从外部为组件实例注入声明周期方法的机会</span><br>    <span class="hljs-comment">// 比如从组件外部为组件的 mounted 方法注入额外的逻辑</span><br>    <span class="hljs-comment">// 该能力是结合 callhook 方法实现的</span><br>    <span class="hljs-comment">// 正则判断 event 的名字是否有 hook</span><br>    <span class="hljs-keyword">if</span> (hookRE.<span class="hljs-title function_">test</span>(event)) &#123;<br>      vm.<span class="hljs-property">_hasHookEvent</span> = <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> vm<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="什么是-Hook-Event？"><a href="#什么是-Hook-Event？" class="headerlink" title="什么是 Hook Event？"></a>什么是 Hook Event？</h3><p>Hook Event 是 Vue 的自定义事件结合生命周期钩子实现的一种从组件外部为组件注入额外生命周期方法的功能。</p><hr><h3 id="Hook-Event-是如果实现的？"><a href="#Hook-Event-是如果实现的？" class="headerlink" title="Hook Event 是如果实现的？"></a>Hook Event 是如果实现的？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">comp</span> @<span class="hljs-attr">hook:lifecycleMethod</span>=<span class="hljs-string">&quot;method&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li>处理组件自定义事件的时候（vm.$on) 如果发现组件有 <code>hook:xx</code> 格式的事件（xx 为 Vue 的生命周期函数），则将 <code>vm._hasHookEvent</code> 置为 <code>true</code>，表示该组件有 Hook Event</li><li>在组件生命周期方法被触发的时候，内部会通过 <code>callHook</code> 方法来执行这些生命周期函数，在生命周期函数执行之后，如果发现 <code>vm._hasHookEvent</code> 为 true，则表示当前组件有 Hook Event，通过 <code>vm.$emit(&#39;hook:xx&#39;)</code> 触发 Hook Event 的执行</li></ul><p>这就是 Hook Event 的实现原理。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6954923081462710309">https://juejin.cn/post/6954923081462710309</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6.【转载】实例方法</title>
    <link href="/2022/10/25/6-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"/>
    <url>/2022/10/25/6-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p>&#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; initMixin, ... &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./init&#x27;</span><br><br><span class="hljs-comment">// Vue 的构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span> (options) &#123;<br>  <span class="hljs-comment">// 调用 Vue.prototype._init 方法，该方法是在 initMixin 中定义的</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options)<br>&#125;<br><br><span class="hljs-comment">// 定义 Vue.prototype._init 方法</span><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义：</span><br><span class="hljs-comment"> *   Vue.prototype.$data</span><br><span class="hljs-comment"> *   Vue.prototype.$props</span><br><span class="hljs-comment"> *   Vue.prototype.$set</span><br><span class="hljs-comment"> *   Vue.prototype.$delete</span><br><span class="hljs-comment"> *   Vue.prototype.$watch</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">stateMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义 事件相关的 方法：</span><br><span class="hljs-comment"> *   Vue.prototype.$on</span><br><span class="hljs-comment"> *   Vue.prototype.$once</span><br><span class="hljs-comment"> *   Vue.prototype.$off</span><br><span class="hljs-comment"> *   Vue.prototype.$emit</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">eventsMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义：</span><br><span class="hljs-comment"> *   Vue.prototype._update</span><br><span class="hljs-comment"> *   Vue.prototype.$forceUpdate</span><br><span class="hljs-comment"> *   Vue.prototype.$destroy</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行 installRenderHelpers，在 Vue.prototype 对象上安装运行时便利程序</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 定义：</span><br><span class="hljs-comment"> *   Vue.prototype.$nextTick</span><br><span class="hljs-comment"> *   Vue.prototype._render</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">renderMixin</span>(<span class="hljs-title class_">Vue</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Vue</span><br></code></pre></td></tr></table></figure><h2 id="vm-data-x2F-vm-props"><a href="#vm-data-x2F-vm-props" class="headerlink" title="vm.$data &#x2F; vm.$props"></a>vm.$data &#x2F; vm.$props</h2><p>src&#x2F;core&#x2F;instance&#x2F;state.js</p><p>这是两个实例属性，不是实例方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// data</span><br><span class="hljs-keyword">const</span> dataDef = &#123;&#125;<br>dataDef.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_data</span> &#125;<br><span class="hljs-comment">// props</span><br><span class="hljs-keyword">const</span> propsDef = &#123;&#125;<br>propsDef.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_props</span> &#125;<br><span class="hljs-comment">// 将 data 属性和 props 属性挂载到 Vue.prototype 对象上</span><br><span class="hljs-comment">// 这样在程序中就可以通过 this.$data 和 this.$props 来访问 data 和 props 对象了</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&#x27;$data&#x27;</span>, dataDef)<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&#x27;$props&#x27;</span>, propsDef)<br></code></pre></td></tr></table></figure><h2 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a>vm.$set</h2><p>&#x2F;src&#x2F;core&#x2F;instance&#x2F;state.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$set</span> = set<br></code></pre></td></tr></table></figure><p>这个 set 函数和 5-全局API 里的 set 是一样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 全局 API</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">set</span> = set<br><span class="hljs-comment">// 实例方法</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$set</span> = set<br></code></pre></td></tr></table></figure><h2 id="vm-delete"><a href="#vm-delete" class="headerlink" title="vm.$delete"></a>vm.$delete</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$delete</span> = del<br></code></pre></td></tr></table></figure><p>delete 也和 5-全局API 里的 delete 一致</p><h2 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a>vm.$watch</h2><p>见 4-异步更新 的 initWatch</p><h2 id="vm-on"><a href="#vm-on" class="headerlink" title="vm.$on"></a>vm.$on</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> hookRE = <span class="hljs-regexp">/^hook:/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 监听实例上的自定义事件，vm._event = &#123; eventName: [fn1, ...], ... &#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; event 单个的事件名称或者有多个事件名组成的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; fn 当 event 被触发时执行的回调函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$on</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event: string | <span class="hljs-built_in">Array</span>&lt;string&gt;, fn: <span class="hljs-built_in">Function</span></span>): <span class="hljs-title class_">Component</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(event)) &#123;<br>    <span class="hljs-comment">// event 是有多个事件名组成的数组，则遍历这些事件，依次递归调用 $on</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = event.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>      vm.$on(event[i], fn)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 将注册的事件和回调以键值对的形式存储到 vm._event 对象中 vm._event = &#123; eventName: [fn1, ...] &#125;</span><br>    (vm.<span class="hljs-property">_events</span>[event] || (vm.<span class="hljs-property">_events</span>[event] = [])).<span class="hljs-title function_">push</span>(fn)<br>    <span class="hljs-comment">// hookEvent，提供从外部为组件实例注入声明周期方法的机会</span><br>    <span class="hljs-comment">// 比如从组件外部为组件的 mounted 方法注入额外的逻辑</span><br>    <span class="hljs-comment">// 该能力是结合 callhook 方法实现的</span><br>    <span class="hljs-keyword">if</span> (hookRE.<span class="hljs-title function_">test</span>(event)) &#123;<br>      vm.<span class="hljs-property">_hasHookEvent</span> = <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> vm<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vm-emit"><a href="#vm-emit" class="headerlink" title="vm.$emit"></a>vm.$emit</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 触发实例上的指定事件，vm._event[event] =&gt; cbs =&gt; loop cbs =&gt; cb(args)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; event 事件名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$emit</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event: string</span>): <span class="hljs-title class_">Component</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 将事件名转换为小些</span><br>    <span class="hljs-keyword">const</span> lowerCaseEvent = event.<span class="hljs-title function_">toLowerCase</span>()<br>    <span class="hljs-comment">// 意思是说，HTML 属性不区分大小写，所以你不能使用 v-on 监听小驼峰形式的事件名（eventName），而应该使用连字符形式的事件名（event-name)</span><br>    <span class="hljs-keyword">if</span> (lowerCaseEvent !== event &amp;&amp; vm.<span class="hljs-property">_events</span>[lowerCaseEvent]) &#123;<br>      <span class="hljs-title function_">tip</span>(<br>        <span class="hljs-string">`Event &quot;<span class="hljs-subst">$&#123;lowerCaseEvent&#125;</span>&quot; is emitted in component `</span> +<br>        <span class="hljs-string">`<span class="hljs-subst">$&#123;formatComponentName(vm)&#125;</span> but the handler is registered for &quot;<span class="hljs-subst">$&#123;event&#125;</span>&quot;. `</span> +<br>        <span class="hljs-string">`Note that HTML attributes are case-insensitive and you cannot use `</span> +<br>        <span class="hljs-string">`v-on to listen to camelCase events when using in-DOM templates. `</span> +<br>        <span class="hljs-string">`You should probably use &quot;<span class="hljs-subst">$&#123;hyphenate(event)&#125;</span>&quot; instead of &quot;<span class="hljs-subst">$&#123;event&#125;</span>&quot;.`</span><br>      )<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 从 vm._event 对象上拿到当前事件的回调函数数组，并一次调用数组中的回调函数，并且传递提供的参数</span><br>  <span class="hljs-keyword">let</span> cbs = vm.<span class="hljs-property">_events</span>[event]<br>  <span class="hljs-keyword">if</span> (cbs) &#123;<br>    cbs = cbs.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-title function_">toArray</span>(cbs) : cbs<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-title function_">toArray</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">const</span> info = <span class="hljs-string">`event handler for &quot;<span class="hljs-subst">$&#123;event&#125;</span>&quot;`</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = cbs.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>      <span class="hljs-title function_">invokeWithErrorHandling</span>(cbs[i], vm, args, vm, info)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> vm<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vm-off"><a href="#vm-off" class="headerlink" title="vm.$off"></a>vm.$off</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 移除自定义事件监听器，即从 vm._event 对象中找到对应的事件，移除所有事件 或者 移除指定事件的回调函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; event </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; fn </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$off</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event?: string | <span class="hljs-built_in">Array</span>&lt;string&gt;, fn?: <span class="hljs-built_in">Function</span></span>): <span class="hljs-title class_">Component</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-comment">// 1.vm.$off() 移除实例上的所有监听器 =&gt; vm._events = &#123;&#125;</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>) &#123;<br>    vm.<span class="hljs-property">_events</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">return</span> vm<br>  &#125;<br>  <span class="hljs-comment">// 2.移除一些事件 event = [event1, ...]，遍历 event 数组，递归调用 vm.$off</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(event)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = event.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>      vm.$off(event[i], fn)<br>    &#125;<br>    <span class="hljs-keyword">return</span> vm<br>  &#125;<br>  <span class="hljs-comment">// 3.除了 vm.$off() 之外，最终都会走到这里，移除指定事件</span><br>  <span class="hljs-keyword">const</span> cbs = vm.<span class="hljs-property">_events</span>[event]<br>  <span class="hljs-keyword">if</span> (!cbs) &#123;<br>    <span class="hljs-comment">// 4.表示没有注册过该事件</span><br>    <span class="hljs-keyword">return</span> vm<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!fn) &#123;<br>    <span class="hljs-comment">// 5.没有提供 fn 回调函数，则移除该事件的所有回调函数，vm._event[event] = null</span><br>    vm.<span class="hljs-property">_events</span>[event] = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> vm<br>  &#125;<br>  <span class="hljs-comment">// 6.移除指定事件的指定回调函数，就是从事件的回调数组中找到该回调函数，然后删除</span><br>  <span class="hljs-keyword">let</span> cb<br>  <span class="hljs-keyword">let</span> i = cbs.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    cb = cbs[i]<br>    <span class="hljs-keyword">if</span> (cb === fn || cb.<span class="hljs-property">fn</span> === fn) &#123;<br>      cbs.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> vm<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vm-once"><a href="#vm-once" class="headerlink" title="vm.$once"></a>vm.$once</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除</span><br><span class="hljs-comment"> * vm.$on + vm.$off</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; event </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; fn </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$once</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event: string, fn: <span class="hljs-built_in">Function</span></span>): <span class="hljs-title class_">Component</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br><br>  <span class="hljs-comment">// 调用 $on，只是 $on 的回调函数被特殊处理了，触发时，执行回调函数，先移除事件监听，然后执行你设置的回调函数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">on</span>(<span class="hljs-params"></span>) &#123;<br>    vm.$off(event, on)<br>    fn.<span class="hljs-title function_">apply</span>(vm, <span class="hljs-variable language_">arguments</span>)<br>  &#125;<br>  on.<span class="hljs-property">fn</span> = fn<br>  vm.$on(event, on)<br>  <span class="hljs-keyword">return</span> vm<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vm-update"><a href="#vm-update" class="headerlink" title="vm._update"></a>vm._update</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 负责更新页面，页面首次渲染和后续更新的入口位置，也是 patch 的入口位置 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_update</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">vnode: VNode, hydrating?: boolean</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">const</span> prevEl = vm.<span class="hljs-property">$el</span><br>  <span class="hljs-keyword">const</span> prevVnode = vm.<span class="hljs-property">_vnode</span><br>  <span class="hljs-keyword">const</span> restoreActiveInstance = <span class="hljs-title function_">setActiveInstance</span>(vm)<br>  vm.<span class="hljs-property">_vnode</span> = vnode<br>  <span class="hljs-comment">// Vue.prototype.__patch__ is injected in entry points</span><br>  <span class="hljs-comment">// based on the rendering backend used.</span><br>  <span class="hljs-keyword">if</span> (!prevVnode) &#123;<br>    <span class="hljs-comment">// 首次渲染，即初始化页面时走这里</span><br>    vm.<span class="hljs-property">$el</span> = vm.<span class="hljs-title function_">__patch__</span>(vm.<span class="hljs-property">$el</span>, vnode, hydrating, <span class="hljs-literal">false</span> <span class="hljs-comment">/* removeOnly */</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 响应式数据更新时，即更新页面时走这里</span><br>    vm.<span class="hljs-property">$el</span> = vm.<span class="hljs-title function_">__patch__</span>(prevVnode, vnode)<br>  &#125;<br>  <span class="hljs-title function_">restoreActiveInstance</span>()<br>  <span class="hljs-comment">// update __vue__ reference</span><br>  <span class="hljs-keyword">if</span> (prevEl) &#123;<br>    prevEl.<span class="hljs-property">__vue__</span> = <span class="hljs-literal">null</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$el</span>) &#123;<br>    vm.<span class="hljs-property">$el</span>.<span class="hljs-property">__vue__</span> = vm<br>  &#125;<br>  <span class="hljs-comment">// if parent is an HOC, update its $el as well</span><br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$vnode</span> &amp;&amp; vm.<span class="hljs-property">$parent</span> &amp;&amp; vm.<span class="hljs-property">$vnode</span> === vm.<span class="hljs-property">$parent</span>.<span class="hljs-property">_vnode</span>) &#123;<br>    vm.<span class="hljs-property">$parent</span>.<span class="hljs-property">$el</span> = vm.<span class="hljs-property">$el</span><br>  &#125;<br>  <span class="hljs-comment">// updated hook is called by the scheduler to ensure that children are</span><br>  <span class="hljs-comment">// updated in a parent&#x27;s updated hook.</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vm-forceUpdate"><a href="#vm-forceUpdate" class="headerlink" title="vm.$forceUpdate"></a>vm.$forceUpdate</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 直接调用 watcher.update 方法，迫使组件重新渲染。</span><br><span class="hljs-comment"> * 它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$forceUpdate</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_watcher</span>) &#123;<br>    vm.<span class="hljs-property">_watcher</span>.<span class="hljs-title function_">update</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vm-destroy"><a href="#vm-destroy" class="headerlink" title="vm.$destroy"></a>vm.$destroy</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$destroy</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_isBeingDestroyed</span>) &#123;<br>    <span class="hljs-comment">// 表示实例已经销毁</span><br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 调用 beforeDestroy 钩子</span><br>  <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;beforeDestroy&#x27;</span>)<br>  <span class="hljs-comment">// 标识实例已经销毁</span><br>  vm.<span class="hljs-property">_isBeingDestroyed</span> = <span class="hljs-literal">true</span><br>  <span class="hljs-comment">// 把自己从老爹（$parent)的肚子里（$children）移除</span><br>  <span class="hljs-keyword">const</span> parent = vm.<span class="hljs-property">$parent</span><br>  <span class="hljs-keyword">if</span> (parent &amp;&amp; !parent.<span class="hljs-property">_isBeingDestroyed</span> &amp;&amp; !vm.<span class="hljs-property">$options</span>.<span class="hljs-property">abstract</span>) &#123;<br>    <span class="hljs-title function_">remove</span>(parent.<span class="hljs-property">$children</span>, vm)<br>  &#125;<br>  <span class="hljs-comment">// 移除依赖监听</span><br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_watcher</span>) &#123;<br>    vm.<span class="hljs-property">_watcher</span>.<span class="hljs-title function_">teardown</span>()<br>  &#125;<br>  <span class="hljs-keyword">let</span> i = vm.<span class="hljs-property">_watchers</span>.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    vm.<span class="hljs-property">_watchers</span>[i].<span class="hljs-title function_">teardown</span>()<br>  &#125;<br>  <span class="hljs-comment">// remove reference from data ob</span><br>  <span class="hljs-comment">// frozen object may not have observer.</span><br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_data</span>.<span class="hljs-property">__ob__</span>) &#123;<br>    vm.<span class="hljs-property">_data</span>.<span class="hljs-property">__ob__</span>.<span class="hljs-property">vmCount</span>--<br>  &#125;<br>  <span class="hljs-comment">// call the last hook...</span><br>  vm.<span class="hljs-property">_isDestroyed</span> = <span class="hljs-literal">true</span><br>  <span class="hljs-comment">// 调用 __patch__，销毁节点</span><br>  vm.<span class="hljs-title function_">__patch__</span>(vm.<span class="hljs-property">_vnode</span>, <span class="hljs-literal">null</span>)<br>  <span class="hljs-comment">// 调用 destroyed 钩子</span><br>  <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;destroyed&#x27;</span>)<br>  <span class="hljs-comment">// 关闭实例的所有事件监听</span><br>  vm.$off()<br>  <span class="hljs-comment">// remove __vue__ reference</span><br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$el</span>) &#123;<br>    vm.<span class="hljs-property">$el</span>.<span class="hljs-property">__vue__</span> = <span class="hljs-literal">null</span><br>  &#125;<br>  <span class="hljs-comment">// release circular reference (#6759)</span><br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$vnode</span>) &#123;<br>    vm.<span class="hljs-property">$vnode</span>.<span class="hljs-property">parent</span> = <span class="hljs-literal">null</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vm-nextTick"><a href="#vm-nextTick" class="headerlink" title="vm.$nextTick"></a>vm.$nextTick</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$nextTick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn: <span class="hljs-built_in">Function</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">nextTick</span>(fn, <span class="hljs-variable language_">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vm-render"><a href="#vm-render" class="headerlink" title="vm._render"></a>vm._render</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过执行 render 函数生成 VNode</span><br><span class="hljs-comment"> * 不过里面加了大量的异常处理代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_render</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>): <span class="hljs-title class_">VNode</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="hljs-property">$options</span><br><br>  <span class="hljs-keyword">if</span> (_parentVnode) &#123;<br>    vm.<span class="hljs-property">$scopedSlots</span> = <span class="hljs-title function_">normalizeScopedSlots</span>(<br>      _parentVnode.<span class="hljs-property">data</span>.<span class="hljs-property">scopedSlots</span>,<br>      vm.<span class="hljs-property">$slots</span>,<br>      vm.<span class="hljs-property">$scopedSlots</span><br>    )<br>  &#125;<br><br>  <span class="hljs-comment">// 设置父 vnode。这使得渲染函数可以访问占位符节点上的数据。</span><br>  vm.<span class="hljs-property">$vnode</span> = _parentVnode<br>  <span class="hljs-comment">// render self</span><br>  <span class="hljs-keyword">let</span> vnode<br>  <span class="hljs-keyword">try</span> &#123;<br>    currentRenderingInstance = vm<br>    <span class="hljs-comment">// 执行 render 函数，生成 vnode</span><br>    vnode = render.<span class="hljs-title function_">call</span>(vm.<span class="hljs-property">_renderProxy</span>, vm.<span class="hljs-property">$createElement</span>)<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-title function_">handleError</span>(e, vm, <span class="hljs-string">`render`</span>)<br>    <span class="hljs-comment">// 到这儿，说明执行 render 函数时出错了</span><br>    <span class="hljs-comment">// 开发环境渲染错误信息，生产环境返回之前的 vnode，以防止渲染错误导致组件空白</span><br>    <span class="hljs-comment">/* istanbul ignore else */</span><br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; vm.<span class="hljs-property">$options</span>.<span class="hljs-property">renderError</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        vnode = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">renderError</span>.<span class="hljs-title function_">call</span>(vm.<span class="hljs-property">_renderProxy</span>, vm.<span class="hljs-property">$createElement</span>, e)<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-title function_">handleError</span>(e, vm, <span class="hljs-string">`renderError`</span>)<br>        vnode = vm.<span class="hljs-property">_vnode</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      vnode = vm.<span class="hljs-property">_vnode</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    currentRenderingInstance = <span class="hljs-literal">null</span><br>  &#125;<br>  <span class="hljs-comment">// 如果返回的 vnode 是数组，并且只包含了一个元素，则直接打平</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(vnode) &amp;&amp; vnode.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>    vnode = vnode[<span class="hljs-number">0</span>]<br>  &#125;<br>  <span class="hljs-comment">// render 函数出错时，返回一个空的 vnode</span><br>  <span class="hljs-keyword">if</span> (!(vnode <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">VNode</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(vnode)) &#123;<br>      <span class="hljs-title function_">warn</span>(<br>        <span class="hljs-string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> +<br>        <span class="hljs-string">&#x27;should return a single root node.&#x27;</span>,<br>        vm<br>      )<br>    &#125;<br>    vnode = <span class="hljs-title function_">createEmptyVNode</span>()<br>  &#125;<br>  <span class="hljs-comment">// set parent</span><br>  vnode.<span class="hljs-property">parent</span> = _parentVnode<br>  <span class="hljs-keyword">return</span> vnode<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="vm-set-obj-key-val"><a href="#vm-set-obj-key-val" class="headerlink" title="vm.$set(obj, key, val)"></a>vm.$set(obj, key, val)</h3><p>vm.$set 用于向响应式对象添加一个新的 property，并确保这个新的 property 同样是响应式的，并触发视图更新。由于 Vue 无法探测对象新增属性或者通过索引为数组新增一个元素，比如：<code>this.obj.newProperty = &#39;val&#39;</code>、<code>this.arr[3] = &#39;val&#39;</code>。所以这才有了 vm.$set，它是 Vue.set 的别名。</p><ul><li>为对象添加一个新的响应式数据：调用 defineReactive 方法为对象增加响应式数据，然后执行 dep.notify 进行依赖通知，更新视图</li><li>为数组添加一个新的响应式数据：通过 splice 方法实现</li></ul><h3 id="vm-delete-obj-key"><a href="#vm-delete-obj-key" class="headerlink" title="vm.$delete(obj, key)"></a>vm.$delete(obj, key)</h3><p>vm.$delete 用于删除对象上的属性。如果对象是响应式的，且能确保能触发视图更新。该方法主要用于避开 Vue 不能检测属性被删除的情况。它是 Vue.delete 的别名。</p><ul><li>删除数组指定下标的元素，内部通过 splice 方法来完成</li><li>删除对象上的指定属性，则是先通过 delete 运算符删除该属性，然后执行 dep.notify 进行依赖通知，更新视图</li></ul><h3 id="vm-watch-expOrFn-callback-options"><a href="#vm-watch-expOrFn-callback-options" class="headerlink" title="vm.$watch(expOrFn, callback, [options])"></a>vm.$watch(expOrFn, callback, [options])</h3><p>vm.$watch 负责观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。当其发生变化时，回调函数就会被执行，并为回调函数传递两个参数，第一个为更新后的新值，第二个为老值。</p><p>这里需要 <strong>注意</strong> 一点的是：如果观察的是一个对象，比如：数组，当你用数组方法，比如 push 为数组新增一个元素时，回调函数被触发时传递的新值和老值相同，因为它们指向同一个引用，所以在观察一个对象并且在回调函数中有新老值是否相等的判断时需要注意。</p><p>vm.$watch 的第一个参数只接收简单的响应式数据的键路径，对于更复杂的表达式建议使用函数作为第一个参数。</p><p>至于 vm.$watch 的内部原理是：</p><ul><li>设置 options.user &#x3D; true，标志是一个用户 watcher</li><li>实例化一个 Watcher 实例，当检测到数据更新时，通过 watcher 去触发回调函数的执行，并传递新老值作为回调函数的参数</li><li>返回一个 unwatch 函数，用于取消观察</li></ul><h3 id="vm-on-event-callback"><a href="#vm-on-event-callback" class="headerlink" title="vm.$on(event, callback)"></a>vm.$on(event, callback)</h3><p>监听当前实例上的自定义事件，事件可由 vm.$emit 触发，回调函数会接收所有传入事件触发函数（vm.$emit）的额外参数。</p><p>vm.$on 的原理很简单，就是处理传递的 event 和 callback 两个参数，将注册的事件和回调函数以键值对的形式存储到 vm._event 对象中，vm._events &#x3D; { eventName: [cb1, cb2, …], … }。</p><h3 id="vm-emit-eventName-…args"><a href="#vm-emit-eventName-…args" class="headerlink" title="vm.$emit(eventName, […args])"></a>vm.$emit(eventName, […args])</h3><p>触发当前实例上的指定事件，附加参数都会传递给事件的回调函数。</p><p>其内部原理就是执行 <code>vm._events[eventName]</code> 中所有的回调函数。</p><h3 id="vm-off-event-callback"><a href="#vm-off-event-callback" class="headerlink" title="vm.$off([event, callback])"></a>vm.$off([event, callback])</h3><p>移除自定义事件监听器，即移除 vm._events 对象上相关数据。</p><ul><li>如果没有提供参数，则移除实例的所有事件监听</li><li>如果只提供了 event 参数，则移除实例上该事件的所有监听器</li><li>如果两个参数都提供了，则移除实例上该事件对应的监听器</li></ul><h3 id="vm-once-event-callback"><a href="#vm-once-event-callback" class="headerlink" title="vm.$once(event, callback)"></a>vm.$once(event, callback)</h3><p>监听一个自定义事件，但是该事件只会被触发一次。一旦触发以后监听器就会被移除。</p><p>其内部的实现原理是：</p><ul><li>包装用户传递的回调函数，当包装函数执行的时候，除了会执行用户回调函数之外还会执行 <code>vm.$off(event, 包装函数)</code> 移除该事件</li><li>用 <code>vm.$on(event, 包装函数)</code> 注册事件</li></ul><h3 id="vm-update-vnode-hydrating"><a href="#vm-update-vnode-hydrating" class="headerlink" title="vm._update(vnode, hydrating)"></a>vm._update(vnode, hydrating)</h3><p>官方文档没有说明该 API，这是一个用于源码内部的实例方法，负责更新页面，是页面渲染的入口，其内部根据是否存在 prevVnode 来决定是首次渲染，还是页面更新，从而在调用 <strong>patch</strong> 函数时传递不同的参数。该方法在业务开发中不会用到。</p><h3 id="vm-forceUpdate-1"><a href="#vm-forceUpdate-1" class="headerlink" title="vm.$forceUpdate()"></a>vm.$forceUpdate()</h3><p>迫使 Vue 实例重新渲染，它仅仅影响组件实例本身和插入插槽内容的子组件，而不是所有子组件。其内部原理到也简单，就是直接调用 <code>vm._watcher.update()</code>，它就是 <code>watcher.update()</code> 方法，执行该方法触发组件更新。</p><h3 id="vm-destroy-1"><a href="#vm-destroy-1" class="headerlink" title="vm.$destroy()"></a>vm.$destroy()</h3><p>负责完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令和事件监听器。在执行过程中会调用 <code>beforeDestroy</code> 和 <code>destroy</code> 两个钩子函数。在大多数业务开发场景下用不到该方法，一般都通过 v-if 指令来操作。其内部原理是：</p><ul><li>调用 beforeDestroy 钩子函数</li><li>将自己从老爹肚子里（$parent）移除，从而销毁和老爹的关系</li><li>通过 watcher.teardown() 来移除依赖监听</li><li>通过 vm.<strong>patch</strong>(vnode, null) 方法来销毁节点</li><li>调用 destroyed 钩子函数</li><li>通过 <code>vm.$off</code> 方法移除所有的事件监听</li></ul><h3 id="vm-nextTick-cb"><a href="#vm-nextTick-cb" class="headerlink" title="vm.$nextTick(cb)"></a>vm.$nextTick(cb)</h3><p>vm.$nextTick 是 Vue.nextTick 的别名，其作用是延迟回调函数 cb 的执行，一般用于 <code>this.key = newVal</code> 更改数据后，想立即获取更改过后的 DOM 数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = <span class="hljs-string">&#x27;new val&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// DOM 更新了</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>其内部的执行过程是：</p><ul><li><code>this.key = &#39;new val&#39;</code>，触发依赖通知更新，将负责更新的 watcher 放入 watcher 队列</li><li>将刷新 watcher 队列的函数放到 callbacks 数组中</li><li>在浏览器的异步任务队列中放入一个刷新 callbacks 数组的函数</li><li><strong>vm.$nextTick(cb)</strong> 来插队，直接将 cb 函数放入 callbacks 数组</li><li>待将来的某个时刻执行刷新 callbacks 数组的函数</li><li>然后执行 callbacks 数组中的众多函数，触发 watcher.run 的执行，更新 DOM</li><li>由于 cb 函数是在后面放到 callbacks 数组，所以这就保证了先完成的 DOM 更新，再执行 cb 函数</li></ul><h3 id="vm-render-1"><a href="#vm-render-1" class="headerlink" title="vm._render"></a>vm._render</h3><p>官方文档没有提供该方法，它是一个用于源码内部的实例方法，负责生成 vnode。其关键代码就一行，执行 render 函数生成 vnode。不过其中加了大量的异常处理代码。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6953503236254859294">https://juejin.cn/post/6953503236254859294</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.【转载】全局API</title>
    <link href="/2022/10/24/5-%E5%85%A8%E5%B1%80API/"/>
    <url>/2022/10/24/5-%E5%85%A8%E5%B1%80API/</url>
    
    <content type="html"><![CDATA[<h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p>&#x2F;src&#x2F;core&#x2F;global-api&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化 Vue 的众多全局 API，比如：</span><br><span class="hljs-comment"> *   默认配置：Vue.config</span><br><span class="hljs-comment"> *   工具方法：Vue.util.xx</span><br><span class="hljs-comment"> *   Vue.set、Vue.delete、Vue.nextTick、Vue.observable</span><br><span class="hljs-comment"> *   Vue.options.components、Vue.options.directives、Vue.options.filters、Vue.options._base</span><br><span class="hljs-comment"> *   Vue.use、Vue.extend、Vue.mixin、Vue.component、Vue.directive、Vue.filter</span><br><span class="hljs-comment"> *   </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initGlobalAPI</span> (<span class="hljs-title class_">Vue</span>: <span class="hljs-title class_">GlobalAPI</span>) &#123;<br>  <span class="hljs-comment">// config</span><br>  <span class="hljs-keyword">const</span> configDef = &#123;&#125;<br>  <span class="hljs-comment">// Vue 的众多默认配置项</span><br>  configDef.<span class="hljs-property">get</span> = <span class="hljs-function">() =&gt;</span> config<br><br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>    configDef.<span class="hljs-property">set</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">warn</span>(<br>        <span class="hljs-string">&#x27;Do not replace the Vue.config object, set individual fields instead.&#x27;</span><br>      )<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Vue.config</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Vue</span>, <span class="hljs-string">&#x27;config&#x27;</span>, configDef)<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 暴露一些工具方法，轻易不要使用这些工具方法，处理你很清楚这些工具方法，以及知道使用的风险</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">util</span> = &#123;<br>    <span class="hljs-comment">// 警告日志</span><br>    warn,<br>    <span class="hljs-comment">// 类似选项合并</span><br>    extend,<br>    <span class="hljs-comment">// 合并选项</span><br>    mergeOptions,<br>    <span class="hljs-comment">// 设置响应式</span><br>    defineReactive<br>  &#125;<br><br>  <span class="hljs-comment">// Vue.set / delete / nextTick</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">set</span> = set<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">delete</span> = del<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">nextTick</span> = nextTick<br><br>  <span class="hljs-comment">// 响应式方法</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">observable</span> = &lt;T&gt;(<span class="hljs-attr">obj</span>: T): <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">observe</span>(obj)<br>    <span class="hljs-keyword">return</span> obj<br>  &#125;<br><br>  <span class="hljs-comment">// Vue.options.compoents/directives/filter</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">options</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-variable constant_">ASSET_TYPES</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> &#123;<br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">options</span>[type + <span class="hljs-string">&#x27;s&#x27;</span>] = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)<br>  &#125;)<br><br>  <span class="hljs-comment">// 将 Vue 构造函数挂载到 Vue.options._base 上</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">options</span>.<span class="hljs-property">_base</span> = <span class="hljs-title class_">Vue</span><br><br>  <span class="hljs-comment">// 在 Vue.options.components 中添加内置组件，比如 keep-alive</span><br>  <span class="hljs-title function_">extend</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property">options</span>.<span class="hljs-property">components</span>, builtInComponents)<br><br>  <span class="hljs-comment">// Vue.use</span><br>  <span class="hljs-title function_">initUse</span>(<span class="hljs-title class_">Vue</span>)<br>  <span class="hljs-comment">// Vue.mixin</span><br>  <span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>)<br>  <span class="hljs-comment">// Vue.extend</span><br>  <span class="hljs-title function_">initExtend</span>(<span class="hljs-title class_">Vue</span>)<br>  <span class="hljs-comment">// Vue.component/directive/filter</span><br>  <span class="hljs-title function_">initAssetRegisters</span>(<span class="hljs-title class_">Vue</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>主要就是挂载 api</p><h2 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义 Vue.use，负责为 Vue 安装插件，做了以下两件事：</span><br><span class="hljs-comment"> *   1、判断插件是否已经被安装，如果安装则直接结束</span><br><span class="hljs-comment"> *   2、安装插件，执行插件的 install 方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; plugin install 方法 或者 包含 install 方法的对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> Vue 实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">use</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">plugin: <span class="hljs-built_in">Function</span> | <span class="hljs-built_in">Object</span></span>) &#123;<br>  <span class="hljs-comment">// 已经安装过的插件列表</span><br>  <span class="hljs-keyword">const</span> installedPlugins = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_installedPlugins</span> || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_installedPlugins</span> = []))<br>  <span class="hljs-comment">// 判断 plugin 是否已经安装，保证不重复安装</span><br>  <span class="hljs-keyword">if</span> (installedPlugins.<span class="hljs-title function_">indexOf</span>(plugin) &gt; -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>  &#125;<br><br>  <span class="hljs-comment">// 将 Vue 构造函数放到第一个参数位置，然后将这些参数传递给 install 方法</span><br>  <span class="hljs-keyword">const</span> args = <span class="hljs-title function_">toArray</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>)<br>  args.<span class="hljs-title function_">unshift</span>(<span class="hljs-variable language_">this</span>)<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin.<span class="hljs-property">install</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-comment">// plugin 是一个对象，则执行其 install 方法安装插件</span><br>    plugin.<span class="hljs-property">install</span>.<span class="hljs-title function_">apply</span>(plugin, args)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 执行直接 plugin 方法安装插件</span><br>    plugin.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args)<br>  &#125;<br>  <span class="hljs-comment">// 在 插件列表中 添加新安装的插件</span><br>  installedPlugins.<span class="hljs-title function_">push</span>(plugin)<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Vue-mixin"><a href="#Vue-mixin" class="headerlink" title="Vue.mixin"></a>Vue.mixin</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义 Vue.mixin，负责全局混入选项，影响之后所有创建的 Vue 实例，这些实例会合并全局混入的选项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; mixin Vue 配置对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 返回 Vue 实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">mixin</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">mixin: <span class="hljs-built_in">Object</span></span>) &#123;<br>  <span class="hljs-comment">// 在 Vue 的默认配置项上合并 mixin 对象</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = <span class="hljs-title function_">mergeOptions</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>, mixin)<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mergeOptions"><a href="#mergeOptions" class="headerlink" title="mergeOptions"></a>mergeOptions</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 合并两个选项，出现相同配置项时，子选项会覆盖父选项的配置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeOptions</span> (<br>  <span class="hljs-attr">parent</span>: <span class="hljs-title class_">Object</span>,<br>  <span class="hljs-attr">child</span>: <span class="hljs-title class_">Object</span>,<br>  vm?: <span class="hljs-title class_">Component</span><br>): <span class="hljs-title class_">Object</span> &#123;<br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>    <span class="hljs-title function_">checkComponents</span>(child)<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    child = child.<span class="hljs-property">options</span><br>  &#125;<br><br>  <span class="hljs-comment">// 标准化 props、inject、directive 选项，方便后续程序的处理</span><br>  <span class="hljs-title function_">normalizeProps</span>(child, vm)<br>  <span class="hljs-title function_">normalizeInject</span>(child, vm)<br>  <span class="hljs-title function_">normalizeDirectives</span>(child)<br><br>  <span class="hljs-comment">// 处理原始 child 对象上的 extends 和 mixins，分别执行 mergeOptions，将这些继承而来的选项合并到 parent</span><br>  <span class="hljs-comment">// mergeOptions 处理过的对象会含有 _base 属性</span><br>  <span class="hljs-keyword">if</span> (!child.<span class="hljs-property">_base</span>) &#123;<br>    <span class="hljs-keyword">if</span> (child.<span class="hljs-property">extends</span>) &#123;<br>      parent = <span class="hljs-title function_">mergeOptions</span>(parent, child.<span class="hljs-property">extends</span>, vm)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (child.<span class="hljs-property">mixins</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = child.<span class="hljs-property">mixins</span>.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>        parent = <span class="hljs-title function_">mergeOptions</span>(parent, child.<span class="hljs-property">mixins</span>[i], vm)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> options = &#123;&#125;<br>  <span class="hljs-keyword">let</span> key<br>  <span class="hljs-comment">// 遍历 父选项</span><br>  <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> parent) &#123;<br>    <span class="hljs-title function_">mergeField</span>(key)<br>  &#125;<br><br>  <span class="hljs-comment">// 遍历 子选项，如果父选项不存在该配置，则合并，否则跳过，因为父子拥有同一个属性的情况在上面处理父选项时已经处理过了，用的子选项的值</span><br>  <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> child) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">hasOwn</span>(parent, key)) &#123;<br>      <span class="hljs-title function_">mergeField</span>(key)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 合并选项，childVal 优先级高于 parentVal</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeField</span> (key) &#123;<br>    <span class="hljs-comment">// strat 是合并策略函数，如果 key 冲突，则 childVal 会 覆盖 parentVal</span><br>    <span class="hljs-keyword">const</span> strat = strats[key] || defaultStrat<br>    <span class="hljs-comment">// 值为如果 childVal 存在则优先使用 childVal，否则使用 parentVal</span><br>    options[key] = <span class="hljs-title function_">strat</span>(parent[key], child[key], vm, key)<br>  &#125;<br>  <span class="hljs-keyword">return</span> options<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Vue-component-x2F-filter-x2F-directive"><a href="#Vue-component-x2F-filter-x2F-directive" class="headerlink" title="Vue.component&#x2F;filter&#x2F;directive"></a>Vue.component&#x2F;filter&#x2F;directive</h2><p>这三个方法放在一起，因为用法类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 添加全局过滤器</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(....)<br><br><span class="hljs-comment">// 2. 添加全局指令</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(....)<br><br><span class="hljs-comment">// 3. 配置全局混入(合)</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(....)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ASSET_TYPES</span> = [<span class="hljs-string">&#x27;component&#x27;</span>, <span class="hljs-string">&#x27;directive&#x27;</span>, <span class="hljs-string">&#x27;filter&#x27;</span>]<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义 Vue.component、Vue.filter、Vue.directive 这三个方法</span><br><span class="hljs-comment"> * 这三个方法所做的事情是类似的，就是在 this.options.xx 上存放对应的配置</span><br><span class="hljs-comment"> * 比如 Vue.component(compName, &#123;xx&#125;) 结果是 this.options.components.compName = 组件构造函数</span><br><span class="hljs-comment"> * ASSET_TYPES = [&#x27;component&#x27;, &#x27;directive&#x27;, &#x27;filter&#x27;]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable constant_">ASSET_TYPES</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 比如：Vue.component(name, definition)</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; id name</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; definition 组件构造函数或者配置对象 </span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns</span> 返回组件构造函数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title class_">Vue</span>[type] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">    id: string,</span><br><span class="hljs-params">    definition: <span class="hljs-built_in">Function</span> | <span class="hljs-built_in">Object</span></span><br><span class="hljs-params">  </span>): <span class="hljs-title class_">Function</span> | <span class="hljs-title class_">Object</span> | <span class="hljs-keyword">void</span> &#123;<br>    <span class="hljs-keyword">if</span> (!definition) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>[type + <span class="hljs-string">&#x27;s&#x27;</span>][id]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;component&#x27;</span> &amp;&amp; <span class="hljs-title function_">isPlainObject</span>(definition)) &#123;<br>        <span class="hljs-comment">// 如果组件配置中存在 name，则使用，否则直接使用 id</span><br>        definition.<span class="hljs-property">name</span> = definition.<span class="hljs-property">name</span> || id<br>        <span class="hljs-comment">// extend 就是 Vue.extend，所以这时的 definition 就变成了 组件构造函数，使用时可直接 new Definition()</span><br>        definition = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">_base</span>.<span class="hljs-title function_">extend</span>(definition)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;directive&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> definition === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        definition = &#123; <span class="hljs-attr">bind</span>: definition, <span class="hljs-attr">update</span>: definition &#125;<br>      &#125;<br>      <span class="hljs-comment">// this.options.components[id] = definition</span><br>      <span class="hljs-comment">// 在实例化时通过 mergeOptions 将全局注册的组件合并到每个组件的配置对象的 components 中</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>[type + <span class="hljs-string">&#x27;s&#x27;</span>][id] = definition<br>      <span class="hljs-keyword">return</span> definition<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Vue-extend"><a href="#Vue-extend" class="headerlink" title="Vue.extend"></a>Vue.extend</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Each instance constructor, including Vue, has a unique</span><br><span class="hljs-comment"> * cid. This enables us to create wrapped &quot;child</span><br><span class="hljs-comment"> * constructors&quot; for prototypal inheritance and cache them.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">cid</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">let</span> cid = <span class="hljs-number">1</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于 Vue 去扩展子类，该子类同样支持进一步的扩展</span><br><span class="hljs-comment"> * 扩展时可以传递一些默认配置，就像 Vue 也会有一些默认配置</span><br><span class="hljs-comment"> * 默认配置如果和基类有冲突则会进行选项合并（mergeOptions)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">extend</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">extendOptions: <span class="hljs-built_in">Object</span></span>): <span class="hljs-title class_">Function</span> &#123;<br>  extendOptions = extendOptions || &#123;&#125;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Super</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">SuperId</span> = <span class="hljs-title class_">Super</span>.<span class="hljs-property">cid</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 利用缓存，如果存在则直接返回缓存中的构造函数</span><br><span class="hljs-comment">   * 什么情况下可以利用到这个缓存？</span><br><span class="hljs-comment">   *   如果你在多次调用 Vue.extend 时使用了同一个配置项（extendOptions），这时就会启用该缓存</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> cachedCtors = extendOptions.<span class="hljs-property">_Ctor</span> || (extendOptions.<span class="hljs-property">_Ctor</span> = &#123;&#125;)<br>  <span class="hljs-keyword">if</span> (cachedCtors[<span class="hljs-title class_">SuperId</span>]) &#123;<br>    <span class="hljs-keyword">return</span> cachedCtors[<span class="hljs-title class_">SuperId</span>]<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> name = extendOptions.<span class="hljs-property">name</span> || <span class="hljs-title class_">Super</span>.<span class="hljs-property">options</span>.<span class="hljs-property">name</span><br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; name) &#123;<br>    <span class="hljs-title function_">validateComponentName</span>(name)<br>  &#125;<br><br>  <span class="hljs-comment">// 定义 Sub 构造函数，和 Vue 构造函数一样</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Sub</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">VueComponent</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options)<br>  &#125;<br>  <span class="hljs-comment">// 通过原型继承的方式继承 Vue</span><br>  <span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br>  <span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Sub</span><br>  <span class="hljs-title class_">Sub</span>.<span class="hljs-property">cid</span> = cid++<br>  <span class="hljs-comment">// 选项合并，合并 Vue 的配置项到 自己的配置项上来</span><br>  <span class="hljs-title class_">Sub</span>.<span class="hljs-property">options</span> = <span class="hljs-title function_">mergeOptions</span>(<br>    <span class="hljs-title class_">Super</span>.<span class="hljs-property">options</span>,<br>    extendOptions<br>  )<br>  <span class="hljs-comment">// 记录自己的基类</span><br>  <span class="hljs-title class_">Sub</span>[<span class="hljs-string">&#x27;super&#x27;</span>] = <span class="hljs-title class_">Super</span><br><br>  <span class="hljs-comment">// 初始化 props，将 props 配置代理到 Sub.prototype._props 对象上</span><br>  <span class="hljs-comment">// 在组件内通过 this._props 方式可以访问</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Sub</span>.<span class="hljs-property">options</span>.<span class="hljs-property">props</span>) &#123;<br>    <span class="hljs-title function_">initProps</span>(<span class="hljs-title class_">Sub</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 初始化 computed，将 computed 配置代理到 Sub.prototype 对象上</span><br>  <span class="hljs-comment">// 在组件内可以通过 this.computedKey 的方式访问</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Sub</span>.<span class="hljs-property">options</span>.<span class="hljs-property">computed</span>) &#123;<br>    <span class="hljs-title function_">initComputed</span>(<span class="hljs-title class_">Sub</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 定义 extend、mixin、use 这三个静态方法，允许在 Sub 基础上再进一步构造子类</span><br>  <span class="hljs-title class_">Sub</span>.<span class="hljs-property">extend</span> = <span class="hljs-title class_">Super</span>.<span class="hljs-property">extend</span><br>  <span class="hljs-title class_">Sub</span>.<span class="hljs-property">mixin</span> = <span class="hljs-title class_">Super</span>.<span class="hljs-property">mixin</span><br>  <span class="hljs-title class_">Sub</span>.<span class="hljs-property">use</span> = <span class="hljs-title class_">Super</span>.<span class="hljs-property">use</span><br><br>  <span class="hljs-comment">// 定义 component、filter、directive 三个静态方法</span><br>  <span class="hljs-variable constant_">ASSET_TYPES</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) &#123;<br>    <span class="hljs-title class_">Sub</span>[type] = <span class="hljs-title class_">Super</span>[type]<br>  &#125;)<br><br>  <span class="hljs-comment">// 递归组件的原理，如果组件设置了 name 属性，则将自己注册到自己的 components 选项中</span><br>  <span class="hljs-keyword">if</span> (name) &#123;<br>    <span class="hljs-title class_">Sub</span>.<span class="hljs-property">options</span>.<span class="hljs-property">components</span>[name] = <span class="hljs-title class_">Sub</span><br>  &#125;<br><br>  <span class="hljs-comment">// 在扩展时保留对基类选项的引用。</span><br>  <span class="hljs-comment">// 稍后在实例化时，我们可以检查 Super 的选项是否具有更新</span><br>  <span class="hljs-title class_">Sub</span>.<span class="hljs-property">superOptions</span> = <span class="hljs-title class_">Super</span>.<span class="hljs-property">options</span><br>  <span class="hljs-title class_">Sub</span>.<span class="hljs-property">extendOptions</span> = extendOptions<br>  <span class="hljs-title class_">Sub</span>.<span class="hljs-property">sealedOptions</span> = <span class="hljs-title function_">extend</span>(&#123;&#125;, <span class="hljs-title class_">Sub</span>.<span class="hljs-property">options</span>)<br><br>  <span class="hljs-comment">// 缓存</span><br>  cachedCtors[<span class="hljs-title class_">SuperId</span>] = <span class="hljs-title class_">Sub</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Sub</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initProps</span> (<span class="hljs-title class_">Comp</span>) &#123;<br>  <span class="hljs-keyword">const</span> props = <span class="hljs-title class_">Comp</span>.<span class="hljs-property">options</span>.<span class="hljs-property">props</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> props) &#123;<br>    <span class="hljs-title function_">proxy</span>(<span class="hljs-title class_">Comp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">`_props`</span>, key)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initComputed</span> (<span class="hljs-title class_">Comp</span>) &#123;<br>  <span class="hljs-keyword">const</span> computed = <span class="hljs-title class_">Comp</span>.<span class="hljs-property">options</span>.<span class="hljs-property">computed</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> computed) &#123;<br>    <span class="hljs-title function_">defineComputed</span>(<span class="hljs-title class_">Comp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, key, computed[key])<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set"></a>Vue.set</h2><p>&#x2F;src&#x2F;core&#x2F;global-api&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">set</span> = set<br></code></pre></td></tr></table></figure><p>&#x2F;src&#x2F;core&#x2F;observer&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过 Vue.set 或者 this.$set 方法给 target 的指定 key 设置值 val</span><br><span class="hljs-comment"> * 如果 target 是对象，并且 key 原本不存在，则为新 key 设置响应式，然后执行依赖通知</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span> (<span class="hljs-attr">target</span>: <span class="hljs-title class_">Array</span>&lt;any&gt; | <span class="hljs-title class_">Object</span>, <span class="hljs-attr">key</span>: any, <span class="hljs-attr">val</span>: any): any &#123;<br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;<br>    (<span class="hljs-title function_">isUndef</span>(target) || <span class="hljs-title function_">isPrimitive</span>(target))<br>  ) &#123;<br>    <span class="hljs-title function_">warn</span>(<span class="hljs-string">`Cannot set reactive property on undefined, null, or primitive value: <span class="hljs-subst">$&#123;(target: any)&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-comment">// 1.更新数组指定下标的元素，Vue.set(array, idx, val)，通过 splice 方法实现响应式更新</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isValidArrayIndex</span>(key)) &#123;<br>    target.<span class="hljs-property">length</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(target.<span class="hljs-property">length</span>, key)<br>    target.<span class="hljs-title function_">splice</span>(key, <span class="hljs-number">1</span>, val)<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 2。更新对象已有属性，Vue.set(obj, key, val)，执行更新即可</span><br>  <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> target &amp;&amp; !(key <span class="hljs-keyword">in</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)) &#123;<br>    target[key] = val<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-keyword">const</span> ob = (<span class="hljs-attr">target</span>: any).<span class="hljs-property">__ob__</span><br>  <span class="hljs-comment">// 不能向 Vue 实例或者 $data 添加动态添加响应式属性，vmCount 的用处之一，</span><br>  <span class="hljs-comment">// this.$data 的 ob.vmCount = 1，表示根组件，其它子组件的 vm.vmCount 都是 0</span><br>  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">_isVue</span> || (ob &amp;&amp; ob.<span class="hljs-property">vmCount</span>)) &#123;<br>    process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>      <span class="hljs-string">&#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27;</span> +<br>      <span class="hljs-string">&#x27;at runtime - declare it upfront in the data option.&#x27;</span><br>    )<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 3.target 不是响应式对象，新属性会被设置，但是不会做响应式处理</span><br>  <span class="hljs-keyword">if</span> (!ob) &#123;<br>    target[key] = val<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 4.给对象定义新属性，通过 defineReactive 方法设置响应式，并触发依赖更新</span><br>  <span class="hljs-title function_">defineReactive</span>(ob.<span class="hljs-property">value</span>, key, val)<br>  ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>()<br>  <span class="hljs-keyword">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure><p>1.如果 target 是数组，直接通过 splice 方法响应式更新元素，因为数组方法已重写。</p><p>2.如果 target 是对象并且对象已有该属性(key)，则直接 target[key] &#x3D; val 修改即可，因为 setter 中会做响应式更新。</p><p>3.如果 target 不是响应式对象，直接 target[key] &#x3D; val，但其不是响应式的，因为 target 不是响应式对象，它的 setter 中不会去 notify。</p><p>4.如果 target 是对象且没有该属性(key)，则调用 defineReactive 设置响应式，并调用 dep.notify() 触发依赖更新。</p><h2 id="Vue-delete"><a href="#Vue-delete" class="headerlink" title="Vue.delete"></a>Vue.delete</h2><p>&#x2F;src&#x2F;core&#x2F;global-api&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">delete</span> = del<br></code></pre></td></tr></table></figure><p>&#x2F;src&#x2F;core&#x2F;observer&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过 Vue.delete 或者 vm.$delete 删除 target 对象的指定 key</span><br><span class="hljs-comment"> * 数组通过 splice 方法实现，对象则通过 delete 运算符删除指定 key，并执行依赖通知</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">del</span> (<span class="hljs-attr">target</span>: <span class="hljs-title class_">Array</span>&lt;any&gt; | <span class="hljs-title class_">Object</span>, <span class="hljs-attr">key</span>: any) &#123;<br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;<br>    (<span class="hljs-title function_">isUndef</span>(target) || <span class="hljs-title function_">isPrimitive</span>(target))<br>  ) &#123;<br>    <span class="hljs-title function_">warn</span>(<span class="hljs-string">`Cannot delete reactive property on undefined, null, or primitive value: <span class="hljs-subst">$&#123;(target: any)&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// target 为数组，则通过 splice 方法删除指定下标的元素</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isValidArrayIndex</span>(key)) &#123;<br>    target.<span class="hljs-title function_">splice</span>(key, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> ob = (<span class="hljs-attr">target</span>: any).<span class="hljs-property">__ob__</span><br><br>  <span class="hljs-comment">// 避免删除 Vue 实例的属性或者 $data 的数据</span><br>  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">_isVue</span> || (ob &amp;&amp; ob.<span class="hljs-property">vmCount</span>)) &#123;<br>    process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>      <span class="hljs-string">&#x27;Avoid deleting properties on a Vue instance or its root $data &#x27;</span> +<br>      <span class="hljs-string">&#x27;- just set it to null.&#x27;</span><br>    )<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 如果属性不存在直接结束</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">hasOwn</span>(target, key)) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 通过 delete 运算符删除对象的属性</span><br>  <span class="hljs-keyword">delete</span> target[key]<br>  <span class="hljs-keyword">if</span> (!ob) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 执行依赖通知</span><br>  ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>1.如果 target 是数组，和 vue.set() 类似，使用 splice 删除</p><p>2.key 不存在，直接 return</p><p>3.如果 target 是对象，delete target[key] 即可，然后 dep.notify() 触发依赖更新</p><h2 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a>Vue.nextTick</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> callbacks = []<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完成两件事：</span><br><span class="hljs-comment"> *   1、用 try catch 包装 flushSchedulerQueue 函数，然后将其放入 callbacks 数组</span><br><span class="hljs-comment"> *   2、如果 pending 为 false，表示现在浏览器的任务队列中没有 flushCallbacks 函数</span><br><span class="hljs-comment"> *     如果 pending 为 true，则表示浏览器的任务队列中已经被放入了 flushCallbacks 函数，</span><br><span class="hljs-comment"> *     待执行 flushCallbacks 函数时，pending 会被再次置为 false，表示下一个 flushCallbacks 函数可以进入</span><br><span class="hljs-comment"> *     浏览器的任务队列了</span><br><span class="hljs-comment"> * pending 的作用：保证在同一时刻，浏览器的任务队列中只有一个 flushCallbacks 函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; cb 接收一个回调函数 =&gt; flushSchedulerQueue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; ctx 上下文</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">nextTick</span> (cb?: <span class="hljs-title class_">Function</span>, ctx?: <span class="hljs-title class_">Object</span>) &#123;<br>  <span class="hljs-keyword">let</span> _resolve<br>  <span class="hljs-comment">// 用 callbacks 数组存储经过包装的 cb 函数</span><br>  callbacks.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (cb) &#123;<br>      <span class="hljs-comment">// 用 try catch 包装回调函数，便于错误捕获</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        cb.<span class="hljs-title function_">call</span>(ctx)<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-title function_">handleError</span>(e, ctx, <span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_resolve) &#123;<br>      <span class="hljs-title function_">_resolve</span>(ctx)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">if</span> (!pending) &#123;<br>    pending = <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// 执行 timerFunc，在浏览器的任务队列中（首选微任务队列）放入 flushCallbacks 函数</span><br>    <span class="hljs-title function_">timerFunc</span>()<br>  &#125;<br>  <span class="hljs-comment">// $flow-disable-line</span><br>  <span class="hljs-keyword">if</span> (!cb &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>      _resolve = resolve<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Vue-use-plugin-做了什么？"><a href="#Vue-use-plugin-做了什么？" class="headerlink" title="Vue.use(plugin) 做了什么？"></a>Vue.use(plugin) 做了什么？</h3><p>负责安装 plugin 插件，其实就是执行插件提供的 install 方法。</p><ul><li>首先判断该插件是否已经安装过</li><li>如果没有，则执行插件提供的 install 方法安装插件，具体做什么有插件自己决定</li></ul><h3 id="Vue-mixin-options-做了什么？"><a href="#Vue-mixin-options-做了什么？" class="headerlink" title="Vue.mixin(options) 做了什么？"></a>Vue.mixin(options) 做了什么？</h3><p>负责在 Vue 的全局配置上合并 options 配置。然后在每个组件生成 vnode 时会将全局配置合并到组件自身的配置上来。</p><ul><li>标准化 options 对象上的 props、inject、directive 选项的格式</li><li>处理 options 上的 extends 和 mixins，分别将他们合并到全局配置上</li><li>然后将 options 配置和全局配置进行合并，选项冲突时 options 配置会覆盖全局配置</li></ul><h3 id="Vue-component-compName-Comp-做了什么？"><a href="#Vue-component-compName-Comp-做了什么？" class="headerlink" title="Vue.component(compName, Comp) 做了什么？"></a>Vue.component(compName, Comp) 做了什么？</h3><p>负责注册全局组件。其实就是将组件配置注册到全局配置的 components 选项上（options.components），然后各个子组件在生成 vnode 时会将全局的 components 选项合并到局部的 components 配置项上。</p><ul><li>如果第二个参数为空，则表示获取 compName 的组件构造函数</li><li>如果 Comp 是组件配置对象，则使用 Vue.extend 方法得到组件构造函数，否则直接进行下一步</li><li>在全局配置上设置组件信息，<code>this.options.components.compName = CompConstructor</code></li></ul><h3 id="Vue-directive-‘my-directive’-xx-做了什么？"><a href="#Vue-directive-‘my-directive’-xx-做了什么？" class="headerlink" title="Vue.directive(‘my-directive’, {xx}) 做了什么？"></a>Vue.directive(‘my-directive’, {xx}) 做了什么？</h3><p>在全局注册 my-directive 指令，然后每个子组件在生成 vnode 时会将全局的 directives 选项合并到局部的 directives 选项中。原理同 Vue.component 方法：</p><ul><li>如果第二个参数为空，则获取指定指令的配置对象</li><li>如果不为空，如果第二个参数是一个函数的话，则生成配置对象 { bind: 第二个参数, update: 第二个参数 }</li><li>然后将指令配置对象设置到全局配置上，<code>this.options.directives[&#39;my-directive&#39;] = &#123;xx&#125;</code></li></ul><h3 id="Vue-filter-‘my-filter’-function-val-xx-做了什么？"><a href="#Vue-filter-‘my-filter’-function-val-xx-做了什么？" class="headerlink" title="Vue.filter(‘my-filter’, function(val) {xx}) 做了什么？"></a>Vue.filter(‘my-filter’, function(val) {xx}) 做了什么？</h3><p>负责在全局注册过滤器 my-filter，然后每个子组件在生成 vnode 时会将全局的 filters 选项合并到局部的 filters 选项中。原理是：</p><ul><li>如果没有提供第二个参数，则获取 my-filter 过滤器的回调函数</li><li>如果提供了第二个参数，则是设置 <code>this.options.filters[&#39;my-filter&#39;] = function(val) &#123;xx&#125;</code>。</li></ul><h3 id="Vue-set-target-key-val-做了什么"><a href="#Vue-set-target-key-val-做了什么" class="headerlink" title="Vue.set(target, key, val) 做了什么?"></a>Vue.set(target, key, val) 做了什么?</h3><p>由于 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty &#x3D; ‘hi’)，所以通过 Vue.set 为向响应式对象中添加一个 property，可以确保这个新 property 同样是响应式的，且触发视图更新。</p><ul><li>更新数组指定下标的元素：Vue.set(array, idx, val)，内部通过 splice 方法实现响应式更新</li><li>更新对象已有属性：Vue.set(obj, key ,val)，直接更新即可 &#x3D;&gt; <code>obj[key] = val</code></li><li>不能向 Vue 实例或者 $data 动态添加根级别的响应式数据</li><li>Vue.set(obj, key, val)，如果 obj 不是响应式对象，会执行 <code>obj[key] = val</code>，但是不会做响应式处理</li><li>Vue.set(obj, key, val)，为响应式对象 obj 增加一个新的 key，则通过 defineReactive 方法设置响应式，并触发依赖更新</li></ul><h3 id="Vue-delete-target-key-做了什么？"><a href="#Vue-delete-target-key-做了什么？" class="headerlink" title="Vue.delete(target, key) 做了什么？"></a>Vue.delete(target, key) 做了什么？</h3><p>删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。当然同样不能删除根级别的响应式属性。</p><ul><li>Vue.delete(array, idx)，删除指定下标的元素，内部是通过 splice 方法实现的</li><li>删除响应式对象上的某个属性：Vue.delete(obj, key)，内部是执行 <code>delete obj.key</code>，然后执行依赖更新即可</li></ul><h3 id="Vue-nextTick-cb-做了什么？"><a href="#Vue-nextTick-cb-做了什么？" class="headerlink" title="Vue.nextTick(cb) 做了什么？"></a>Vue.nextTick(cb) 做了什么？</h3><p>Vue.nextTick(cb) 方法的作用是延迟回调函数 cb 的执行，一般用于 <code>this.key = newVal</code> 更改数据后，想立即获取更改过后的 DOM 数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = <span class="hljs-string">&#x27;new val&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// DOM 更新了</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>其内部的执行过程是：</p><ul><li><code>this.key = &#39;new val</code>，触发依赖通知更新，将负责更新的 watcher 放入 watcher 队列</li><li>将刷新 watcher 队列的函数放到 callbacks 数组中</li><li>在浏览器的异步任务队列中放入一个刷新 callbacks 数组的函数</li><li><strong>Vue.nextTick(cb)</strong> 来插队，将 cb 函数放入 callbacks 数组</li><li>待将来的某个时刻执行刷新 callbacks 数组的函数</li><li>然后执行 callbacks 数组中的众多函数，触发 watcher.run 的执行，更新 DOM</li><li>由于 cb 函数是在后面放到 callbacks 数组，所以这就保证了先完成的 DOM 更新，再执行 cb 函数</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6952643167715852319">https://juejin.cn/post/6952643167715852319</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.异步更新</title>
    <link href="/2022/10/23/4-%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0/"/>
    <url>/2022/10/23/4-%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="dep-notify"><a href="#dep-notify" class="headerlink" title="dep.notify()"></a>dep.notify()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通知 dep 中的所有 watcher，执行 watcher.update() 方法</span><br><span class="hljs-comment"> */</span><br>notify () &#123;<br>  <span class="hljs-comment">// stabilize the subscriber list first</span><br>  <span class="hljs-keyword">const</span> subs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">slice</span>()<br>  <span class="hljs-comment">// 遍历 dep 中存储的 watcher，执行 watcher.update()</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>    subs[i].<span class="hljs-title function_">update</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="watcher-update"><a href="#watcher-update" class="headerlink" title="watcher.update()"></a>watcher.update()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据 watcher 配置项，决定接下来怎么走，一般是 queueWatcher</span><br><span class="hljs-comment"> */</span><br>update () &#123;<br>  <span class="hljs-comment">/* istanbul ignore else */</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>) &#123;<br>    <span class="hljs-comment">// 懒执行时走这里，比如 computed</span><br>    <span class="hljs-comment">// 将 dirty 置为 true，可以让 computedGetter 执行时重新计算 computed 回调函数的执行结果</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">true</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">sync</span>) &#123;<br>    <span class="hljs-comment">// 同步执行，在使用 vm.$watch 或者 watch 选项时可以传一个 sync 选项，</span><br>    <span class="hljs-comment">// 当为 true 时在数据更新时该 watcher 就不走异步更新队列，直接执行 this.run </span><br>    <span class="hljs-comment">// 方法进行更新</span><br>    <span class="hljs-comment">// 这个属性在官方文档中没有出现</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">run</span>()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 更新时一般都这里，将 watcher 放入 watcher 队列</span><br>    <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Vue-的异步更新机制是如何实现的？"><a href="#Vue-的异步更新机制是如何实现的？" class="headerlink" title="Vue 的异步更新机制是如何实现的？"></a>Vue 的异步更新机制是如何实现的？</h3><p>Vue 的异步更新机制的核心是利用了浏览器的异步任务队列来实现的，首选微任务队列，宏任务队列次之。</p><p>当响应式数据更新后，会调用 dep.notify 方法，通知 dep 中收集的 watcher 去执行 update 方法，watcher.update 将 watcher 自己放入一个 watcher 队列（全局的 queue 数组）。</p><p>然后通过 nextTick 方法将一个刷新 watcher 队列的方法（flushSchedulerQueue）放入一个全局的 callbacks 数组中。</p><p>如果此时浏览器的异步任务队列中没有一个叫 flushCallbacks 的函数，则执行 timerFunc 函数，将 flushCallbacks 函数放入异步任务队列。如果异步任务队列中已经存在 flushCallbacks 函数，等待其执行完成以后再放入下一个 flushCallbacks 函数。</p><p>flushCallbacks 函数负责执行 callbacks 数组中的所有 flushSchedulerQueue 函数。</p><p>flushSchedulerQueue 函数负责刷新 watcher 队列，即执行 queue 数组中每一个 watcher 的 run 方法，从而进入更新阶段，比如执行组件更新函数或者执行用户 watch 的回调函数。</p><h3 id="Vue-的-nextTick-API-是如何实现的？"><a href="#Vue-的-nextTick-API-是如何实现的？" class="headerlink" title="Vue 的 nextTick API 是如何实现的？"></a>Vue 的 nextTick API 是如何实现的？</h3><p>Vue.nextTick 或者 vm.$nextTick 的原理其实很简单，就做了两件事：</p><ul><li>将传递的回调函数用 <code>try catch</code> 包裹然后放入 callbacks 数组</li><li>执行 timerFunc 函数，在浏览器的异步任务队列放入一个刷新 callbacks 数组的函数</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>异步更新的入口点就是 setter 中最后调用的 dep.notify() 方法。dep.notify() 会遍历 dep 中的 watcher，并执行 watcher.update()。在 update 中，如果 watcher.lazy 是 true，那么将 dirty 也置为 true，就是控制懒执行。如果 watcher.sync 为 true，就直接调用 run 函数同步更新，否则走异步更新，调用 queueWatcher，将 watcher 放入 watcher 队列，在 queueWatcher 中会根据 id 判断 watcher 是否已经入过队了，入过了直接跳过。然后再根据 flushing 判断队列是否处于刷新状态，如果没有的话就将 watcher 就直接入队，否则需要做一定处理，根据 id 保证队列中的有序性。最后再根据 waiting 判断队列中是否有刷新函数（flushSchedulerQueue），如果没有的话，使用 nextTick 将该函数放入 callbacks 数组里。如果当前没有其它 nextTick 在执行的话，就会调用 timerFunc 函数，会根据环境，做一个兼容性判断，选择某一种异步执行的方法调用 flushCallbacks 函数。优先级是 promise.then &gt; object.observe &gt; setImmediate &gt; setTimeout。flushCallbacks 遍历 callbacks 执行其中每一个刷新函数，刷新函数实际就是在调用 watcher.run 从而执行组件更新函数（updateComponent）或者 watch 的回调函数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6951568091893465102">https://juejin.cn/post/6951568091893465102</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pnpm的优势</title>
    <link href="/2022/10/23/pnpm%E7%9A%84%E4%BC%98%E5%8A%BF/"/>
    <url>/2022/10/23/pnpm%E7%9A%84%E4%BC%98%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="npm2"><a href="#npm2" class="headerlink" title="npm2"></a>npm2</h2><p>npm2 的 node_modules 是嵌套的，包自己的依赖就在包自己的 node_modules 中。</p><p>两个问题：</p><p>1.如果多个包之间有公共依赖，那这个依赖就会复制很多次，多次占用空间。</p><p>2.windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ff1d1c0cab14b65b905fe1e74db59a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><p>所有的依赖不再一层层嵌套了，而是全部在同一层，这样也就没有<strong>依赖重复</strong>多次的问题了，也就没有<strong>路径过长</strong>的问题了。</p><p>全部铺平在了一层，展开下面的包大部分是没有二层 node_modules 的：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52e6392c33f04f7a949c07fa7d65d358~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>因为一个包是可能有多个版本的，提升只能提升一个，所以后面再遇到相同包的不同版本，依然还是用嵌套的方式。不过，可以通过 yarn.lock 来锁定依赖版本。</p><h2 id="npm3"><a href="#npm3" class="headerlink" title="npm3+"></a>npm3+</h2><p>npm3+ 和 yarn 很类似，也是铺平，也可以通过 package-lock.json 来锁定版本。</p><p>问题在于，铺平会产生<strong>幽灵依赖</strong>的问题。（当然，幽灵依赖问题不是很大，很多 ide 都会提示）</p><p>因为所有依赖都铺平在了 node_modules 里，那对一些子依赖，我们虽然没有单独安装，但也可以直接引入。但是一旦父依赖不再依赖子依赖，那代码就跑不了了，因为没有显示依赖，子依赖不会再被安装。（我的理解是 package.json 里没有子依赖，npm i 时不会安装）</p><h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p>link，也就是软硬连接，这是操作系统提供的机制，硬连接就是同一个文件的不同引用，而软链接是新建一个文件，文件内容指向另一个路径。当然，这俩链接使用起来是差不多的。</p><p>所有的依赖都是从全局 store 硬连接到了 node_modules&#x2F;.pnpm 下，然后之间通过软链接来相互依赖。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/326a2090786e4d16b2d6fce25e876680~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p><strong>优势</strong></p><p>1.只有1份全局包，其余都是链接，依赖不会多余复制，也不会有长度限制。</p><p>2.没有幽灵依赖，因为没有铺平</p><p>3.速度快，链接的方式而不是复制</p><p><strong>缺陷</strong></p><p>装一个包，所有依赖都会装到全局，如果项目删除，依赖仍在全局目录中</p><p>可以通过执行 pnpm store prune 删除不再被引用的包</p><p>原理在于 硬链接会记录被引用了几次。当没有被的引用的时候就可以删除。（有点像垃圾回收的引用计数吧）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7127295203177676837">https://juejin.cn/post/7127295203177676837</a></p>]]></content>
    
    
    <categories>
      
      <category>包管理工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.响应式原理</title>
    <link href="/2022/10/21/3-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2022/10/21/3-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>vue 在初始化时会调用 initState(vm) 使当前 vue 实例具有响应式</p><h2 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h2><p>&#x2F;src&#x2F;core&#x2F;instance&#x2F;state.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 两件事：</span><br><span class="hljs-comment"> *   数据响应式的入口：分别处理 props、methods、data、computed、watch</span><br><span class="hljs-comment"> *   优先级：props、methods、data、computed 对象中的属性不能出现重复，优先级和列出顺序一致</span><br><span class="hljs-comment"> *         其中 computed 中的 key 不能和 props、data 中的 key 重复，methods 不影响</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span> (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>) &#123;<br>  vm.<span class="hljs-property">_watchers</span> = []<br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span><br>  <span class="hljs-comment">// 处理 props updatecomponent，为 props 对象的每个属性设置响应式，并将其代理到 vm 实例上</span><br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">props</span>) <span class="hljs-title function_">initProps</span>(vm, opts.<span class="hljs-property">props</span>)<br>  <span class="hljs-comment">// 处理 methos 对象，校验每个属性的值是否为函数、和 props 属性比对进行判重处理，最后得到 vm[key] = methods[key]</span><br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">methods</span>) <span class="hljs-title function_">initMethods</span>(vm, opts.<span class="hljs-property">methods</span>)<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 做了三件事</span><br><span class="hljs-comment">   *   1、判重处理，data 对象上的属性不能和 props、methods 对象上的属性相同</span><br><span class="hljs-comment">   *   2、代理 data 对象上的属性到 vm 实例</span><br><span class="hljs-comment">   *   3、为 data 对象的上数据设置响应式 </span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">data</span>) &#123;<br>    <span class="hljs-title function_">initData</span>(vm)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">observe</span>(vm.<span class="hljs-property">_data</span> = &#123;&#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 三件事：</span><br><span class="hljs-comment">   *   1、为 computed[key] 创建 watcher 实例，默认是懒执行</span><br><span class="hljs-comment">   *   2、代理 computed[key] 到 vm 实例</span><br><span class="hljs-comment">   *   3、判重，computed 中的 key 不能和 data、props 中的属性重复</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">computed</span>) <span class="hljs-title function_">initComputed</span>(vm, opts.<span class="hljs-property">computed</span>)<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 三件事：</span><br><span class="hljs-comment">   *   1、处理 watch 对象</span><br><span class="hljs-comment">   *   2、为 每个 watch.key 创建 watcher 实例，key 和 watcher 实例可能是 一对多 的关系</span><br><span class="hljs-comment">   *   3、如果设置了 immediate，则立即执行 回调函数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">watch</span> &amp;&amp; opts.<span class="hljs-property">watch</span> !== nativeWatch) &#123;<br>    <span class="hljs-title function_">initWatch</span>(vm, opts.<span class="hljs-property">watch</span>)<br>  &#125;<br>    <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 其实到这里也能看出，computed 和 watch 在本质是没有区别的，都是通过 watcher 去实现的响应式</span><br><span class="hljs-comment">   * 非要说有区别，那也只是在使用方式上的区别，简单来说：</span><br><span class="hljs-comment">   *   1、watch：适用于当数据变化时执行异步或者开销较大的操作时使用，即需要长时间等待的操作可以放在 watch 中</span><br><span class="hljs-comment">   *   2、computed：其中可以使用异步方法，但是没有任何意义。所以 computed 更适合做一些同步计算</span><br><span class="hljs-comment">   */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 处理 props 对象，为 props 对象的每个属性设置响应式，并将其代理到 vm 实例上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initProps</span> (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>, <span class="hljs-attr">propsOptions</span>: <span class="hljs-title class_">Object</span>) &#123;<br>  <span class="hljs-keyword">const</span> propsData = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">propsData</span> || &#123;&#125;<br>  <span class="hljs-keyword">const</span> props = vm.<span class="hljs-property">_props</span> = &#123;&#125;<br>  <span class="hljs-comment">// 缓存 props 的每个 key，性能优化</span><br>  <span class="hljs-comment">// cache prop keys so that future props updates can iterate using Array</span><br>  <span class="hljs-comment">// instead of dynamic object key enumeration.</span><br>  <span class="hljs-keyword">const</span> keys = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">_propKeys</span> = []<br>  <span class="hljs-keyword">const</span> isRoot = !vm.<span class="hljs-property">$parent</span><br>  <span class="hljs-comment">// root instance props should be converted</span><br>  <span class="hljs-keyword">if</span> (!isRoot) &#123;<br>    <span class="hljs-title function_">toggleObserving</span>(<span class="hljs-literal">false</span>)<br>  &#125;<br>  <span class="hljs-comment">// 遍历 props 对象</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> propsOptions) &#123;<br>    <span class="hljs-comment">// 缓存 key</span><br>    keys.<span class="hljs-title function_">push</span>(key)<br>    <span class="hljs-comment">// 获取 props[key] 的默认值</span><br>    <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">validateProp</span>(key, propsOptions, propsData, vm)<br>    <span class="hljs-comment">// 为 props 的每个 key 是设置数据响应式</span><br>    <span class="hljs-title function_">defineReactive</span>(props, key, value)<br>    <span class="hljs-comment">// static props are already proxied on the component&#x27;s prototype</span><br>    <span class="hljs-comment">// during Vue.extend(). We only need to proxy props defined at</span><br>    <span class="hljs-comment">// instantiation here.</span><br>    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> vm)) &#123;<br>      <span class="hljs-comment">// 代理 key 到 vm 对象上</span><br>      <span class="hljs-title function_">proxy</span>(vm, <span class="hljs-string">`_props`</span>, key)<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">toggleObserving</span>(<span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置代理，将 key 代理到 target 上</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">proxy</span> (<span class="hljs-attr">target</span>: <span class="hljs-title class_">Object</span>, <span class="hljs-attr">sourceKey</span>: string, <span class="hljs-attr">key</span>: string) &#123;<br>  sharedPropertyDefinition.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">proxyGetter</span> () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[sourceKey][key]<br>  &#125;<br>  sharedPropertyDefinition.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">proxySetter</span> (val) &#123;<br>    <span class="hljs-variable language_">this</span>[sourceKey][key] = val<br>  &#125;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, sharedPropertyDefinition)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="initMethods"><a href="#initMethods" class="headerlink" title="initMethods"></a>initMethods</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 做了以下三件事，其实最关键的就是第三件事情</span><br><span class="hljs-comment"> *   1、校验 methods[key]，必须是一个函数</span><br><span class="hljs-comment"> *   2、判重</span><br><span class="hljs-comment"> *         methods 中的 key 不能和 props 中的 key 相同</span><br><span class="hljs-comment"> *         methods 中的 key 与 Vue 实例上已有的方法重叠，一般是一些内置方法，比如以 $ 和 _ 开头的方法</span><br><span class="hljs-comment"> *   3、将 methods[key] 放到 vm 实例上，得到 vm[key] = methods[key]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initMethods</span> (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>, <span class="hljs-attr">methods</span>: <span class="hljs-title class_">Object</span>) &#123;<br>  <span class="hljs-comment">// 获取 props 配置项</span><br>  <span class="hljs-keyword">const</span> props = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">props</span><br>  <span class="hljs-comment">// 遍历 methods 对象</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> methods) &#123;<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> methods[key] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-title function_">warn</span>(<br>          <span class="hljs-string">`Method &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; has type &quot;<span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> methods[key]&#125;</span>&quot; in the component definition. `</span> +<br>          <span class="hljs-string">`Did you reference the function correctly?`</span>,<br>          vm<br>        )<br>      &#125;<br>      <span class="hljs-keyword">if</span> (props &amp;&amp; <span class="hljs-title function_">hasOwn</span>(props, key)) &#123;<br>        <span class="hljs-title function_">warn</span>(<br>          <span class="hljs-string">`Method &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; has already been defined as a prop.`</span>,<br>          vm<br>        )<br>      &#125;<br>      <span class="hljs-keyword">if</span> ((key <span class="hljs-keyword">in</span> vm) &amp;&amp; <span class="hljs-title function_">isReserved</span>(key)) &#123;<br>        <span class="hljs-title function_">warn</span>(<br>          <span class="hljs-string">`Method &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; conflicts with an existing Vue instance method. `</span> +<br>          <span class="hljs-string">`Avoid defining component methods that start with _ or $.`</span><br>        )<br>      &#125;<br>    &#125;<br>    vm[key] = <span class="hljs-keyword">typeof</span> methods[key] !== <span class="hljs-string">&#x27;function&#x27;</span> ? noop : <span class="hljs-title function_">bind</span>(methods[key], vm)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 做了三件事</span><br><span class="hljs-comment"> *   1、判重处理，data 对象上的属性不能和 props、methods 对象上的属性相同</span><br><span class="hljs-comment"> *   2、代理 data 对象上的属性到 vm 实例</span><br><span class="hljs-comment"> *   3、为 data 对象的上数据设置响应式 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initData</span> (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>) &#123;<br>  <span class="hljs-comment">// 得到 data 对象</span><br>  <span class="hljs-keyword">let</span> data = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">data</span><br>  data = vm.<span class="hljs-property">_data</span> = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span><br>    ? <span class="hljs-title function_">getData</span>(data, vm)<br>    : data || &#123;&#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPlainObject</span>(data)) &#123;<br>    data = &#123;&#125;<br>    process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>      <span class="hljs-string">&#x27;data functions should return an object:\n&#x27;</span> +<br>      <span class="hljs-string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,<br>      vm<br>    )<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 两件事</span><br><span class="hljs-comment">   *   1、判重处理，data 对象上的属性不能和 props、methods 对象上的属性相同</span><br><span class="hljs-comment">   *   2、代理 data 对象上的属性到 vm 实例</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data)<br>  <span class="hljs-keyword">const</span> props = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">props</span><br>  <span class="hljs-keyword">const</span> methods = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">methods</span><br>  <span class="hljs-keyword">let</span> i = keys.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i]<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (methods &amp;&amp; <span class="hljs-title function_">hasOwn</span>(methods, key)) &#123;<br>        <span class="hljs-title function_">warn</span>(<br>          <span class="hljs-string">`Method &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,<br>          vm<br>        )<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (props &amp;&amp; <span class="hljs-title function_">hasOwn</span>(props, key)) &#123;<br>      process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>        <span class="hljs-string">`The data property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +<br>        <span class="hljs-string">`Use prop default value instead.`</span>,<br>        vm<br>      )<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isReserved</span>(key)) &#123;<br>      <span class="hljs-title function_">proxy</span>(vm, <span class="hljs-string">`_data`</span>, key)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 为 data 对象上的数据设置响应式</span><br>  <span class="hljs-title function_">observe</span>(data, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span> (<span class="hljs-attr">data</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>): any &#123;<br>  <span class="hljs-comment">// #7573 disable dep collection when invoking data getters</span><br>  <span class="hljs-title function_">pushTarget</span>()<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">call</span>(vm, vm)<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-title function_">handleError</span>(e, vm, <span class="hljs-string">`data()`</span>)<br>    <span class="hljs-keyword">return</span> &#123;&#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-title function_">popTarget</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> computedWatcherOptions = &#123; <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span> &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三件事：</span><br><span class="hljs-comment"> *   1、为 computed[key] 创建 watcher 实例，默认是懒执行</span><br><span class="hljs-comment"> *   2、代理 computed[key] 到 vm 实例</span><br><span class="hljs-comment"> *   3、判重，computed 中的 key 不能和 data、props 中的属性重复</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; computed = &#123;</span><br><span class="hljs-comment"> *   key1: function() &#123; return xx &#125;,</span><br><span class="hljs-comment"> *   key2: &#123;</span><br><span class="hljs-comment"> *     get: function() &#123; return xx &#125;,</span><br><span class="hljs-comment"> *     set: function(val) &#123;&#125;</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initComputed</span> (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>, <span class="hljs-attr">computed</span>: <span class="hljs-title class_">Object</span>) &#123;<br>  <span class="hljs-comment">// $flow-disable-line</span><br>  <span class="hljs-keyword">const</span> watchers = vm.<span class="hljs-property">_computedWatchers</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-comment">// computed properties are just getters during SSR</span><br>  <span class="hljs-keyword">const</span> isSSR = <span class="hljs-title function_">isServerRendering</span>()<br><br>  <span class="hljs-comment">// 遍历 computed 对象</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> computed) &#123;<br>    <span class="hljs-comment">// 获取 key 对应的值，即 getter 函数</span><br>    <span class="hljs-keyword">const</span> userDef = computed[key]<br>    <span class="hljs-keyword">const</span> getter = <span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&#x27;function&#x27;</span> ? userDef : userDef.<span class="hljs-property">get</span><br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; getter == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">warn</span>(<br>        <span class="hljs-string">`Getter is missing for computed property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot;.`</span>,<br>        vm<br>      )<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!isSSR) &#123;<br>      <span class="hljs-comment">// 为 computed 属性创建 watcher 实例</span><br>      watchers[key] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(<br>        vm,<br>        getter || noop,<br>        noop,<br>        <span class="hljs-comment">// 配置项，computed 默认是懒执行</span><br>        computedWatcherOptions<br>      )<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> vm)) &#123;<br>      <span class="hljs-comment">// 代理 computed 对象中的属性到 vm 实例</span><br>      <span class="hljs-comment">// 这样就可以使用 vm.computedKey 访问计算属性了</span><br>      <span class="hljs-title function_">defineComputed</span>(vm, key, userDef)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 非生产环境有一个判重处理，computed 对象中的属性不能和 data、props 中的属性相同</span><br>      <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> vm.<span class="hljs-property">$data</span>) &#123;<br>        <span class="hljs-title function_">warn</span>(<span class="hljs-string">`The computed property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; is already defined in data.`</span>, vm)<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$options</span>.<span class="hljs-property">props</span> &amp;&amp; key <span class="hljs-keyword">in</span> vm.<span class="hljs-property">$options</span>.<span class="hljs-property">props</span>) &#123;<br>        <span class="hljs-title function_">warn</span>(<span class="hljs-string">`The computed property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; is already defined as a prop.`</span>, vm)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代理 computed 对象中的 key 到 target（vm）上</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defineComputed</span> (<br>  <span class="hljs-attr">target</span>: any,<br>  <span class="hljs-attr">key</span>: string,<br>  <span class="hljs-attr">userDef</span>: <span class="hljs-title class_">Object</span> | <span class="hljs-title class_">Function</span><br>) &#123;<br>  <span class="hljs-keyword">const</span> shouldCache = !<span class="hljs-title function_">isServerRendering</span>()<br>  <span class="hljs-comment">// 构造属性描述符(get、set)</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    sharedPropertyDefinition.<span class="hljs-property">get</span> = shouldCache<br>      ? <span class="hljs-title function_">createComputedGetter</span>(key)<br>      : <span class="hljs-title function_">createGetterInvoker</span>(userDef)<br>    sharedPropertyDefinition.<span class="hljs-property">set</span> = noop<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    sharedPropertyDefinition.<span class="hljs-property">get</span> = userDef.<span class="hljs-property">get</span><br>      ? shouldCache &amp;&amp; userDef.<span class="hljs-property">cache</span> !== <span class="hljs-literal">false</span><br>        ? <span class="hljs-title function_">createComputedGetter</span>(key)<br>        : <span class="hljs-title function_">createGetterInvoker</span>(userDef.<span class="hljs-property">get</span>)<br>      : noop<br>    sharedPropertyDefinition.<span class="hljs-property">set</span> = userDef.<span class="hljs-property">set</span> || noop<br>  &#125;<br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;<br>      sharedPropertyDefinition.<span class="hljs-property">set</span> === noop) &#123;<br>    sharedPropertyDefinition.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">warn</span>(<br>        <span class="hljs-string">`Computed property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; was assigned to but it has no setter.`</span>,<br>        <span class="hljs-variable language_">this</span><br>      )<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 拦截对 target.key 的访问和设置</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, sharedPropertyDefinition)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 返回一个函数，这个函数在访问 vm.computedProperty 时会被执行，然后返回执行结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComputedGetter</span> (key) &#123;<br>  <span class="hljs-comment">// computed 属性值会缓存的原理也是在这里结合 watcher.dirty、watcher.evaluate、watcher.update 实现的</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">computedGetter</span> () &#123;<br>    <span class="hljs-comment">// 得到当前 key 对应的 watcher</span><br>    <span class="hljs-keyword">const</span> watcher = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span>[key]<br>    <span class="hljs-keyword">if</span> (watcher) &#123;<br>      <span class="hljs-comment">// 计算 key 对应的值，通过执行 computed.key 的回调函数来得到</span><br>      <span class="hljs-comment">// watcher.dirty 属性就是大家常说的 computed 计算结果会缓存的原理</span><br>      <span class="hljs-comment">// &lt;template&gt;</span><br>      <span class="hljs-comment">//   &lt;div&gt;&#123;&#123; computedProperty &#125;&#125;&lt;/div&gt;</span><br>      <span class="hljs-comment">//   &lt;div&gt;&#123;&#123; computedProperty &#125;&#125;&lt;/div&gt;</span><br>      <span class="hljs-comment">// &lt;/template&gt;</span><br>      <span class="hljs-comment">// 像这种情况下，在页面的一次渲染中，两个 dom 中的 computedProperty 只有第一个</span><br>      <span class="hljs-comment">// 会执行 computed.computedProperty 的回调函数计算实际的值，</span><br>      <span class="hljs-comment">// 即执行 watcher.evalaute，而第二个就不走计算过程了，</span><br>      <span class="hljs-comment">// 因为上一次执行 watcher.evalute 时把 watcher.dirty 置为了 false，</span><br>      <span class="hljs-comment">// 待页面更新后，wathcer.update 方法会将 watcher.dirty 重新置为 true，</span><br>      <span class="hljs-comment">// 供下次页面更新时重新计算 computed.key 的结果</span><br>      <span class="hljs-keyword">if</span> (watcher.<span class="hljs-property">dirty</span>) &#123;<br>        watcher.evaluate()<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        watcher.<span class="hljs-title function_">depend</span>()<br>      &#125;<br>      <span class="hljs-keyword">return</span> watcher.<span class="hljs-property">value</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 功能同 createComputedGetter 一样</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createGetterInvoker</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">computedGetter</span> () &#123;<br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="initWatch"><a href="#initWatch" class="headerlink" title="initWatch"></a>initWatch</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理 watch 对象的入口，做了两件事：</span><br><span class="hljs-comment"> *   1、遍历 watch 对象</span><br><span class="hljs-comment"> *   2、调用 createWatcher 函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; watch = &#123;</span><br><span class="hljs-comment"> *   &#x27;key1&#x27;: function(val, oldVal) &#123;&#125;,</span><br><span class="hljs-comment"> *   &#x27;key2&#x27;: &#x27;this.methodName&#x27;,</span><br><span class="hljs-comment"> *   &#x27;key3&#x27;: &#123;</span><br><span class="hljs-comment"> *     handler: function(val, oldVal) &#123;&#125;,</span><br><span class="hljs-comment"> *     deep: true</span><br><span class="hljs-comment"> *   &#125;,</span><br><span class="hljs-comment"> *   &#x27;key4&#x27;: [</span><br><span class="hljs-comment"> *     &#x27;this.methodNanme&#x27;,</span><br><span class="hljs-comment"> *     function handler1() &#123;&#125;,</span><br><span class="hljs-comment"> *     &#123;</span><br><span class="hljs-comment"> *       handler: function() &#123;&#125;,</span><br><span class="hljs-comment"> *       immediate: true</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> *   ],</span><br><span class="hljs-comment"> *   &#x27;key.key5&#x27; &#123; ... &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initWatch</span> (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>, <span class="hljs-attr">watch</span>: <span class="hljs-title class_">Object</span>) &#123;<br>  <span class="hljs-comment">// 遍历 watch 对象</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> watch) &#123;<br>    <span class="hljs-keyword">const</span> handler = watch[key]<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(handler)) &#123;<br>      <span class="hljs-comment">// handler 为数组，遍历数组，获取其中的每一项，然后调用 createWatcher</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; handler.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-title function_">createWatcher</span>(vm, key, handler[i])<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">createWatcher</span>(vm, key, handler)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 两件事：</span><br><span class="hljs-comment"> *   1、兼容性处理，保证 handler 肯定是一个函数</span><br><span class="hljs-comment"> *   2、调用 $watch </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWatcher</span> (<br>  <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>,<br>  <span class="hljs-attr">expOrFn</span>: string | <span class="hljs-title class_">Function</span>,<br>  <span class="hljs-attr">handler</span>: any,<br>  options?: <span class="hljs-title class_">Object</span><br>) &#123;<br>  <span class="hljs-comment">// 如果 handler 为对象，则获取其中的 handler 选项的值</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPlainObject</span>(handler)) &#123;<br>    options = handler<br>    handler = handler.<span class="hljs-property">handler</span><br>  &#125;<br>  <span class="hljs-comment">// 如果 hander 为字符串，则说明是一个 methods 方法，获取 vm[handler]</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    handler = vm[handler]<br>  &#125;<br>  <span class="hljs-keyword">return</span> vm.$watch(expOrFn, handler, options)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建 watcher，返回 unwatch，共完成如下 5 件事：</span><br><span class="hljs-comment"> *   1、兼容性处理，保证最后 new Watcher 时的 cb 为函数</span><br><span class="hljs-comment"> *   2、标示用户 watcher</span><br><span class="hljs-comment"> *   3、创建 watcher 实例</span><br><span class="hljs-comment"> *   4、如果设置了 immediate，则立即执行一次 cb</span><br><span class="hljs-comment"> *   5、返回 unwatch</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; expOrFn key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; cb 回调函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; options 配置项，用户直接调用 this.$watch 时可能会传递一个 配置项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 返回 unwatch 函数，用于取消 watch 监听</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$watch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">  expOrFn: string | <span class="hljs-built_in">Function</span>,</span><br><span class="hljs-params">  cb: any,</span><br><span class="hljs-params">  options?: <span class="hljs-built_in">Object</span></span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Function</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-comment">// 兼容性处理，因为用户调用 vm.$watch 时设置的 cb 可能是对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPlainObject</span>(cb)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createWatcher</span>(vm, expOrFn, cb, options)<br>  &#125;<br>  <span class="hljs-comment">// options.user 表示用户 watcher，还有渲染 watcher，即 updateComponent 方法中实例化的 watcher</span><br>  options = options || &#123;&#125;<br>  options.<span class="hljs-property">user</span> = <span class="hljs-literal">true</span><br>  <span class="hljs-comment">// 创建 watcher</span><br>  <span class="hljs-keyword">const</span> watcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expOrFn, cb, options)<br>  <span class="hljs-comment">// 如果用户设置了 immediate 为 true，则立即执行一次回调函数</span><br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">immediate</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      cb.<span class="hljs-title function_">call</span>(vm, watcher.<span class="hljs-property">value</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-title function_">handleError</span>(error, vm, <span class="hljs-string">`callback for immediate watcher &quot;<span class="hljs-subst">$&#123;watcher.expression&#125;</span>&quot;`</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回一个 unwatch 函数，用于解除监听</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unwatchFn</span> () &#123;<br>    watcher.<span class="hljs-title function_">teardown</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 响应式处理的真正入口</span><br><span class="hljs-comment"> * 为对象创建观察者实例，如果对象已经被观察过，则返回已有的观察者实例，否则创建新的观察者实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; value 对象 =&gt; &#123;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span> (<span class="hljs-attr">value</span>: any, <span class="hljs-attr">asRootData</span>: ?boolean): <span class="hljs-title class_">Observer</span> | <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-comment">// 非对象和 VNode 实例不做响应式处理</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(value) || value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">VNode</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">ob</span>: <span class="hljs-title class_">Observer</span> | <span class="hljs-keyword">void</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasOwn</span>(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.<span class="hljs-property">__ob__</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Observer</span>) &#123;<br>    <span class="hljs-comment">// 如果 value 对象上存在 __ob__ 属性，则表示已经做过观察了，直接返回 __ob__ 属性</span><br>    ob = value.<span class="hljs-property">__ob__</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>    shouldObserve &amp;&amp;<br>    !<span class="hljs-title function_">isServerRendering</span>() &amp;&amp;<br>    (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value) || <span class="hljs-title function_">isPlainObject</span>(value)) &amp;&amp;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isExtensible</span>(value) &amp;&amp;<br>    !value.<span class="hljs-property">_isVue</span><br>  ) &#123;<br>    <span class="hljs-comment">// 创建观察者实例</span><br>    ob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(value)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (asRootData &amp;&amp; ob) &#123;<br>    ob.<span class="hljs-property">vmCount</span>++<br>  &#125;<br>  <span class="hljs-keyword">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure><p>new Observer 进行响应式处理</p><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 观察者类，会被附加到每个被观察的对象上，value.__ob__ = this</span><br><span class="hljs-comment"> * 而对象的各个属性则会被转换成 getter/setter，并收集依赖和通知更新</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-attr">value</span>: any;<br>  <span class="hljs-attr">dep</span>: <span class="hljs-title class_">Dep</span>;<br>  <span class="hljs-attr">vmCount</span>: number; <span class="hljs-comment">// number of vms that have this object as root $data</span><br><br>  <span class="hljs-title function_">constructor</span> (<span class="hljs-attr">value</span>: any) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value<br>    <span class="hljs-comment">// 实例话一个 dep</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vmCount</span> = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 在 value 对象上设置 __ob__ 属性</span><br>    <span class="hljs-title function_">def</span>(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * value 为数组</span><br><span class="hljs-comment">       * hasProto = &#x27;__proto__&#x27; in &#123;&#125;</span><br><span class="hljs-comment">       * 用于判断对象是否存在 __proto__ 属性，通过 obj.__proto__ 可以访问对象的原型链</span><br><span class="hljs-comment">       * 但由于 __proto__ 不是标准属性，所以有些浏览器不支持，比如 IE6-10，Opera10.1</span><br><span class="hljs-comment">       * 为什么要判断，是因为一会儿要通过 __proto__ 操作数据的原型链</span><br><span class="hljs-comment">       * 覆盖数组默认的七个原型方法，以实现数组响应式</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">if</span> (hasProto) &#123;<br>        <span class="hljs-comment">// 有 __proto__</span><br>        <span class="hljs-title function_">protoAugment</span>(value, arrayMethods)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">copyAugment</span>(value, arrayMethods, arrayKeys)<br>      &#125;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observeArray</span>(value)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// value 为对象，为对象的每个属性（包括嵌套对象）设置响应式</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 遍历对象上的每个 key，为每个 key 设置响应式</span><br><span class="hljs-comment">   * 仅当值为对象时才会走这里</span><br><span class="hljs-comment">   */</span><br>  walk (<span class="hljs-attr">obj</span>: <span class="hljs-title class_">Object</span>) &#123;<br>    <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-title function_">defineReactive</span>(obj, keys[i])<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 遍历数组，为数组的每一项设置观察，处理数组元素为对象的情况</span><br><span class="hljs-comment">   */</span><br>  observeArray (<span class="hljs-attr">items</span>: <span class="hljs-title class_">Array</span>&lt;any&gt;) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = items.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>      <span class="hljs-title function_">observe</span>(items[i])<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 vue2 使用的是 Object.defineProperty 无法监听数组的改变，所以数组和对象分开处理。</p><p>对象遍历调用 defineReactive() 函数</p><p>数组遍历调用 observe() 函数</p><h2 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 拦截 obj[key] 的读取和设置操作：</span><br><span class="hljs-comment"> *   1、在第一次读取时收集依赖，比如执行 render 函数生成虚拟 DOM 时会有读取操作</span><br><span class="hljs-comment"> *   2、在更新时设置新值并通知依赖更新</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span> (<br>  <span class="hljs-attr">obj</span>: <span class="hljs-title class_">Object</span>,<br>  <span class="hljs-attr">key</span>: string,<br>  <span class="hljs-attr">val</span>: any,<br>  customSetter?: ?<span class="hljs-title class_">Function</span>,<br>  shallow?: boolean<br>) &#123;<br>  <span class="hljs-comment">// 实例化 dep，一个 key 一个 dep</span><br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()<br><br>  <span class="hljs-comment">// 获取 obj[key] 的属性描述符，发现它是不可配置对象的话直接 return</span><br>  <span class="hljs-keyword">const</span> property = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, key)<br>  <span class="hljs-keyword">if</span> (property &amp;&amp; property.<span class="hljs-property">configurable</span> === <span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// 记录 getter 和 setter，获取 val 值</span><br>  <span class="hljs-keyword">const</span> getter = property &amp;&amp; property.<span class="hljs-property">get</span><br>  <span class="hljs-keyword">const</span> setter = property &amp;&amp; property.<span class="hljs-property">set</span><br>  <span class="hljs-keyword">if</span> ((!getter || setter) &amp;&amp; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>    val = obj[key]<br>  &#125;<br><br>  <span class="hljs-comment">// 递归调用，处理 val 即 obj[key] 的值为对象的情况，保证对象中的所有 key 都被观察</span><br>  <span class="hljs-keyword">let</span> childOb = !shallow &amp;&amp; <span class="hljs-title function_">observe</span>(val)<br>  <span class="hljs-comment">// 响应式核心</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// get 拦截对 obj[key] 的读取操作</span><br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveGetter</span> () &#123;<br>      <span class="hljs-keyword">const</span> value = getter ? getter.<span class="hljs-title function_">call</span>(obj) : val<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * Dep.target 为 Dep 类的一个静态属性，值为 watcher，在实例化 Watcher 时会被设置</span><br><span class="hljs-comment">       * 实例化 Watcher 时会执行 new Watcher 时传递的回调函数（computed 除外，因为它懒执行）</span><br><span class="hljs-comment">       * 而回调函数中如果有 vm.key 的读取行为，则会触发这里的 读取 拦截，进行依赖收集</span><br><span class="hljs-comment">       * 回调函数执行完以后又会将 Dep.target 设置为 null，避免这里重复收集依赖</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        <span class="hljs-comment">// 依赖收集，在 dep 中添加 watcher，也在 watcher 中添加 dep</span><br>        dep.<span class="hljs-title function_">depend</span>()<br>        <span class="hljs-comment">// childOb 表示对象中嵌套对象的观察者对象，如果存在也对其进行依赖收集</span><br>        <span class="hljs-keyword">if</span> (childOb) &#123;<br>          <span class="hljs-comment">// 这就是 this.key.childKey 被更新时能触发响应式更新的原因</span><br>          childOb.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>()<br>          <span class="hljs-comment">// 如果是 obj[key] 是 数组，则触发数组响应式</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>            <span class="hljs-comment">// 为数组项为对象的项添加依赖</span><br>            <span class="hljs-title function_">dependArray</span>(value)<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value<br>    &#125;,<br>    <span class="hljs-comment">// set 拦截对 obj[key] 的设置操作</span><br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveSetter</span> (newVal) &#123;<br>      <span class="hljs-comment">// 旧的 obj[key]</span><br>      <span class="hljs-keyword">const</span> value = getter ? getter.<span class="hljs-title function_">call</span>(obj) : val<br>      <span class="hljs-comment">// 如果新老值一样，则直接 return，不跟新更不触发响应式更新过程</span><br>      <span class="hljs-comment">/* eslint-disable no-self-compare */</span><br>      <span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-comment">/* eslint-enable no-self-compare */</span><br>      <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;<br>        <span class="hljs-title function_">customSetter</span>()<br>      &#125;<br>      <span class="hljs-comment">// setter 不存在说明该属性是一个只读属性，直接 return</span><br>      <span class="hljs-keyword">if</span> (getter &amp;&amp; !setter) <span class="hljs-keyword">return</span><br>      <span class="hljs-comment">// 设置新值</span><br>      <span class="hljs-keyword">if</span> (setter) &#123;<br>        setter.<span class="hljs-title function_">call</span>(obj, newVal)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        val = newVal<br>      &#125;<br>      <span class="hljs-comment">// 对新值进行观察，让新值也是响应式的</span><br>      childOb = !shallow &amp;&amp; <span class="hljs-title function_">observe</span>(newVal)<br>      <span class="hljs-comment">// 依赖通知更新</span><br>      dep.<span class="hljs-title function_">notify</span>()<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>读取数据时进行依赖收集，dep.depend()，将 dep 添加到 watcher 中，也将 watcher 添加到 dep 中</p><p>修改数据时，判断新老值是否相同，判断属性是否只读，对新值做响应式处理，依赖通知更新 dep.notify()，通知收集的所有 watcher，让 watcher 执行 update 方法。</p><ul><li><p>initProps</p><ul><li>为 props 对象的每个属性设置响应式，调用 defineReactive()</li><li>代理到 vue 实例上，可以通过 this.propKey 访问，调用 proxy()</li></ul></li><li><p>initMethods</p><ul><li>检验 methods[key] 是不是函数</li><li>判重<ul><li>methods 中的 key 不能和 props 中的 key 相同</li><li>methods 中的 key 与 Vue 实例上已有的方法重叠，一般是一些内置方法，比如以 $ 和 _ 开头的方法</li></ul></li><li>代理到 vue 实例上，可以通过 this.methodKey 访问</li></ul></li><li><p>initData</p><ul><li><p>处理 data，保证是一个对象（data 正常情况下可能是函数或对象）</p></li><li><p>判重 data 中的属性不能和 props 以及 methods 重复</p><ul><li>代理到 vue 实例上，可以通过 this.key 访问，调用 proxy()</li><li>响应式处理，调用 observe()</li></ul></li></ul></li><li><p>initComputed</p><ul><li>computed 是通过 watcher 实现的，对每个 computedKey 实例化一个 watcher，默认懒执行</li><li>代理到 vue 实例上，可以通过 this.computedKey 访问，调用 defineComputed()</li><li>computed 缓存的实现原理(dirty 控制)</li></ul></li><li><p>initWatch</p><ul><li>遍历 watch对象，对每一项调用 createWatcher，在其中对 handler 做处理（因为 watch 的书写有很多种形式），处理完毕后调用 vm.$watch，实例化一个 watcher，如果 immediate 为 true 的话，立即执行一次 callback。返回一个 unwatch 函数，用于解绑。</li></ul></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Vue-响应式原理是怎么实现的？"><a href="#Vue-响应式原理是怎么实现的？" class="headerlink" title="Vue 响应式原理是怎么实现的？"></a>Vue 响应式原理是怎么实现的？</h3><p>响应式的核心是通过 <code>Object.defineProperty</code> 拦截对数据的访问和设置</p><p>响应式的数据分为两类：</p><ul><li>对象，循环遍历对象的所有属性，为每个属性设置 getter、setter，以达到拦截访问和设置的目的，如果属性值依旧为对象，则递归为属性值上的每个 key 设置 getter、setter<ul><li>访问数据时（obj.key)进行依赖收集，在 dep 中存储相关的 watcher</li><li>设置数据时由 dep 通知相关的 watcher 去更新</li></ul></li><li>数组，增强数组的那 7 个可以更改自身的原型方法，然后拦截对这些方法的操作<ul><li>添加新数据时进行响应式处理，然后由 dep 通知 watcher 去更新</li><li>删除数据时，也要由 dep 通知 watcher 去更新</li></ul></li></ul><p>对象属性经过深度遍历后，最终就是以一个基本类型的数据为单位收集依赖，但是数组仍然是一个<strong>引用类型</strong>。</p><h3 id="methods、computed-和-watch-有什么区别？"><a href="#methods、computed-和-watch-有什么区别？" class="headerlink" title="methods、computed 和 watch 有什么区别？"></a>methods、computed 和 watch 有什么区别？</h3><p>使用场景</p><ul><li>methods 一般用于封装一些较为复杂的处理逻辑（同步、异步）</li><li>computed 一般用于封装一些简单的同步逻辑，将经过处理的数据返回，然后显示在模版中，以减轻模版的重量</li><li>watch 一般用于当需要在数据变化时执行异步或开销较大的操作</li></ul><p>区别</p><ul><li><p>methods VS computed</p><blockquote><p>如果在一次渲染中，有多个地方使用了同一个 methods 或 computed 属性，methods 会被执行多次，而 computed 的回调函数则只会被执行一次。</p></blockquote><blockquote><p>通过阅读源码我们知道，在一次渲染中，多次访问 computedProperty，只会在第一次执行 computed 属性的回调函数，后续的其它访问，则直接使用第一次的执行结果（watcher.value），而这一切的实现原理则是通过对 watcher.dirty 属性的控制实现的。在第一次执行后 dirty 变为 false，等到数据变化之后，重新渲染页面时，才会重新变为 true。当 dirty 为 false 时，直接返回 watcher.value，而不执行 watcher.evaluate 重新计算。而 methods，每一次的访问则是简单的方法调用（this.xxMethods）。</p></blockquote></li><li><p>computed VS watch</p><blockquote><p>通过阅读源码我们知道，computed 和 watch 的本质是一样的，内部都是通过 Watcher 来实现的，其实没什么区别，非要说区别的化就两点：1、使用场景上的区别，2、computed 默认是懒执行的，切不可更改。</p></blockquote></li><li><p>methods VS watch</p><blockquote><p>methods 和 watch 之间其实没什么可比的，完全是两个东西，不过在使用上可以把 watch 中一些逻辑抽到 methods 中，提高代码的可读性。</p></blockquote></li></ul><h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> type <span class="hljs-title class_">Watcher</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./watcher&#x27;</span><br><span class="hljs-keyword">import</span> &#123; remove &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/index&#x27;</span><br><span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../config&#x27;</span><br><br><span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个 dep 对应一个 obj.key</span><br><span class="hljs-comment"> * 在读取响应式数据时，负责收集依赖，每个 dep（或者说 obj.key）依赖的 watcher 有哪些</span><br><span class="hljs-comment"> * 在响应式数据更新时，负责通知 dep 中那些 watcher 去执行 update 方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-attr">target</span>: ?<span class="hljs-title class_">Watcher</span>;<br>  <span class="hljs-attr">id</span>: number;<br>  <span class="hljs-attr">subs</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Watcher</span>&gt;;<br><br>  <span class="hljs-title function_">constructor</span> () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = uid++<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []<br>  &#125;<br><br>  <span class="hljs-comment">// 在 dep 中添加 watcher</span><br>  addSub (<span class="hljs-attr">sub</span>: <span class="hljs-title class_">Watcher</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(sub)<br>  &#125;<br><br>  removeSub (<span class="hljs-attr">sub</span>: <span class="hljs-title class_">Watcher</span>) &#123;<br>    <span class="hljs-title function_">remove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>, sub)<br>  &#125;<br><br>  <span class="hljs-comment">// 像 watcher 中添加 dep</span><br>  depend () &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>      <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>.<span class="hljs-title function_">addDep</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 通知 dep 中的所有 watcher，执行 watcher.update() 方法</span><br><span class="hljs-comment">   */</span><br>  notify () &#123;<br>    <span class="hljs-comment">// stabilize the subscriber list first</span><br>    <span class="hljs-keyword">const</span> subs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">slice</span>()<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; !config.<span class="hljs-property">async</span>) &#123;<br>      <span class="hljs-comment">// subs aren&#x27;t sorted in scheduler if not running async</span><br>      <span class="hljs-comment">// we need to sort them now to make sure they fire in correct</span><br>      <span class="hljs-comment">// order</span><br>      subs.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>)<br>    &#125;<br>    <span class="hljs-comment">// 遍历 dep 中存储的 watcher，执行 watcher.update()</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>      subs[i].<span class="hljs-title function_">update</span>()<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前正在执行的 watcher，同一时间只会有一个 watcher 在执行</span><br><span class="hljs-comment"> * Dep.target = 当前正在执行的 watcher</span><br><span class="hljs-comment"> * 通过调用 pushTarget 方法完成赋值，调用 popTarget 方法完成重置（null)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span><br><span class="hljs-keyword">const</span> targetStack = []<br><br><span class="hljs-comment">// 在需要进行依赖收集的时候调用，设置 Dep.target = watcher</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span> (<span class="hljs-attr">target</span>: ?<span class="hljs-title class_">Watcher</span>) &#123;<br>  targetStack.<span class="hljs-title function_">push</span>(target)<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = target<br>&#125;<br><br><span class="hljs-comment">// 依赖收集结束调用，设置 Dep.target = null</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span> () &#123;<br>  targetStack.<span class="hljs-title function_">pop</span>()<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = targetStack[targetStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个组件一个 watcher（渲染 watcher）或者一个表达式一个 watcher（用户watcher）</span><br><span class="hljs-comment"> * 当数据更新时 watcher 会被触发，访问 this.computedProperty 时也会触发 watcher</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>;<br>  <span class="hljs-attr">expression</span>: string;<br>  <span class="hljs-attr">cb</span>: <span class="hljs-title class_">Function</span>;<br>  <span class="hljs-attr">id</span>: number;<br>  <span class="hljs-attr">deep</span>: boolean;<br>  <span class="hljs-attr">user</span>: boolean;<br>  <span class="hljs-attr">lazy</span>: boolean;<br>  <span class="hljs-attr">sync</span>: boolean;<br>  <span class="hljs-attr">dirty</span>: boolean;<br>  <span class="hljs-attr">active</span>: boolean;<br>  <span class="hljs-attr">deps</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Dep</span>&gt;;<br>  <span class="hljs-attr">newDeps</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Dep</span>&gt;;<br>  <span class="hljs-attr">depIds</span>: <span class="hljs-title class_">SimpleSet</span>;<br>  <span class="hljs-attr">newDepIds</span>: <span class="hljs-title class_">SimpleSet</span>;<br>  <span class="hljs-attr">before</span>: ?<span class="hljs-title class_">Function</span>;<br>  <span class="hljs-attr">getter</span>: <span class="hljs-title class_">Function</span>;<br>  <span class="hljs-attr">value</span>: any;<br><br>  <span class="hljs-title function_">constructor</span> (<br>    <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>,<br>    <span class="hljs-attr">expOrFn</span>: string | <span class="hljs-title class_">Function</span>,<br>    <span class="hljs-attr">cb</span>: <span class="hljs-title class_">Function</span>,<br>    options?: ?<span class="hljs-title class_">Object</span>,<br>    isRenderWatcher?: boolean<br>  ) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm<br>    <span class="hljs-keyword">if</span> (isRenderWatcher) &#123;<br>      vm.<span class="hljs-property">_watcher</span> = <span class="hljs-variable language_">this</span><br>    &#125;<br>    vm.<span class="hljs-property">_watchers</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-comment">// options</span><br>    <span class="hljs-keyword">if</span> (options) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span> = !!options.<span class="hljs-property">deep</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = !!options.<span class="hljs-property">user</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> = !!options.<span class="hljs-property">lazy</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">sync</span> = !!options.<span class="hljs-property">sync</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">before</span> = options.<span class="hljs-property">before</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">sync</span> = <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = ++uid <span class="hljs-comment">// uid for batching</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span> = <span class="hljs-literal">true</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> <span class="hljs-comment">// for lazy watchers</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = []<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span> = []<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">expression</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span><br>      ? expOrFn.<span class="hljs-title function_">toString</span>()<br>      : <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment">// parse expression for getter</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> expOrFn === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = expOrFn<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// this.getter = function() &#123; return this.xx &#125;</span><br>      <span class="hljs-comment">// 在 this.get 中执行 this.getter 时会触发依赖收集</span><br>      <span class="hljs-comment">// 待后续 this.xx 更新时就会触发响应式</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = <span class="hljs-title function_">parsePath</span>(expOrFn)<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = noop<br>        process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>          <span class="hljs-string">`Failed watching path: &quot;<span class="hljs-subst">$&#123;expOrFn&#125;</span>&quot; `</span> +<br>          <span class="hljs-string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +<br>          <span class="hljs-string">&#x27;For full control, use a function instead.&#x27;</span>,<br>          vm<br>        )<br>      &#125;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span><br>      ? <span class="hljs-literal">undefined</span><br>      : <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 执行 this.getter，并重新收集依赖</span><br><span class="hljs-comment">   * this.getter 是实例化 watcher 时传递的第二个参数，一个函数或者字符串，比如：updateComponent 或者 parsePath 返回的读取 this.xx 属性值的函数</span><br><span class="hljs-comment">   * 为什么要重新收集依赖？</span><br><span class="hljs-comment">   *   因为触发更新说明有响应式数据被更新了，但是被更新的数据虽然已经经过 observe 观察了，但是却没有进行依赖收集，</span><br><span class="hljs-comment">   *   所以，在更新页面时，会重新执行一次 render 函数，执行期间会触发读取操作，这时候进行依赖收集</span><br><span class="hljs-comment">   */</span><br>  get () &#123;<br>    <span class="hljs-comment">// 打开 Dep.target，Dep.target = this</span><br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-comment">// value 为回调函数执行的结果</span><br>    <span class="hljs-keyword">let</span> value<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 执行回调函数，比如 updateComponent，进入 patch 阶段</span><br>      value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(vm, vm)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;<br>        <span class="hljs-title function_">handleError</span>(e, vm, <span class="hljs-string">`getter for watcher &quot;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.expression&#125;</span>&quot;`</span>)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> e<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// &quot;touch&quot; every property so they are all tracked as</span><br>      <span class="hljs-comment">// dependencies for deep watching</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span>) &#123;<br>        <span class="hljs-title function_">traverse</span>(value)<br>      &#125;<br>      <span class="hljs-comment">// 关闭 Dep.target，Dep.target = null</span><br>      <span class="hljs-title function_">popTarget</span>()<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanupDeps</span>()<br>    &#125;<br>    <span class="hljs-keyword">return</span> value<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Add a dependency to this directive.</span><br><span class="hljs-comment">   * 两件事：</span><br><span class="hljs-comment">   *   1、添加 dep 给自己（watcher）</span><br><span class="hljs-comment">   *   2、添加自己（watcher）到 dep</span><br><span class="hljs-comment">   */</span><br>  addDep (<span class="hljs-attr">dep</span>: <span class="hljs-title class_">Dep</span>) &#123;<br>    <span class="hljs-comment">// 判重，如果 dep 已经存在则不重复添加</span><br>    <span class="hljs-keyword">const</span> id = dep.<span class="hljs-property">id</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">has</span>(id)) &#123;<br>      <span class="hljs-comment">// 缓存 dep.id，用于判重</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">add</span>(id)<br>      <span class="hljs-comment">// 添加 dep</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span>.<span class="hljs-title function_">push</span>(dep)<br>      <span class="hljs-comment">// 避免在 dep 中重复添加 watcher，this.depIds 的设置在 cleanupDeps 方法中</span><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span>.<span class="hljs-title function_">has</span>(id)) &#123;<br>        <span class="hljs-comment">// 添加 watcher 自己到 dep</span><br>        dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">this</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Clean up for dependency collection.</span><br><span class="hljs-comment">   */</span><br>  cleanupDeps () &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i]<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">has</span>(dep.<span class="hljs-property">id</span>)) &#123;<br>        dep.<span class="hljs-title function_">removeSub</span>(<span class="hljs-variable language_">this</span>)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> tmp = <span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span> = tmp<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">clear</span>()<br>    tmp = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span> = tmp<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 根据 watcher 配置项，决定接下来怎么走，一般是 queueWatcher</span><br><span class="hljs-comment">   */</span><br>  update () &#123;<br>    <span class="hljs-comment">/* istanbul ignore else */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>) &#123;<br>      <span class="hljs-comment">// 懒执行时走这里，比如 computed</span><br><br>      <span class="hljs-comment">// 将 dirty 置为 true，可以让 computedGetter 执行时重新计算 computed 回调函数的执行结果</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">sync</span>) &#123;<br>      <span class="hljs-comment">// 同步执行，在使用 vm.$watch 或者 watch 选项时可以传一个 sync 选项，</span><br>      <span class="hljs-comment">// 当为 true 时在数据更新时该 watcher 就不走异步更新队列，直接执行 this.run </span><br>      <span class="hljs-comment">// 方法进行更新</span><br>      <span class="hljs-comment">// 这个属性在官方文档中没有出现</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">run</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 更新时一般都这里，将 watcher 放入 watcher 队列</span><br>      <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 由 刷新队列函数 flushSchedulerQueue 调用，完成如下几件事：</span><br><span class="hljs-comment">   *   1、执行实例化 watcher 传递的第二个参数，updateComponent 或者 获取 this.xx 的一个函数(parsePath 返回的函数)</span><br><span class="hljs-comment">   *   2、更新旧值为新值</span><br><span class="hljs-comment">   *   3、执行实例化 watcher 时传递的第三个参数，比如用户 watcher 的回调函数</span><br><span class="hljs-comment">   */</span><br>  run () &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) &#123;<br>      <span class="hljs-comment">// 调用 this.get 方法</span><br>      <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()<br>      <span class="hljs-keyword">if</span> (<br>        value !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> ||<br>        <span class="hljs-comment">// Deep watchers and watchers on Object/Arrays should fire even</span><br>        <span class="hljs-comment">// when the value is the same, because the value may</span><br>        <span class="hljs-comment">// have mutated.</span><br>        <span class="hljs-title function_">isObject</span>(value) ||<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span><br>      ) &#123;<br>        <span class="hljs-comment">// 更新旧值为新值</span><br>        <span class="hljs-keyword">const</span> oldValue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;<br>          <span class="hljs-comment">// 如果是用户 watcher，则执行用户传递的第三个参数 —— 回调函数，参数为 val 和 oldVal</span><br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, value, oldValue)<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-title function_">handleError</span>(e, <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, <span class="hljs-string">`callback for watcher &quot;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.expression&#125;</span>&quot;`</span>)<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 渲染 watcher，this.cb = noop，一个空函数</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, value, oldValue)<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 懒执行的 watcher 会调用该方法</span><br><span class="hljs-comment">   *   比如：computed，在获取 vm.computedProperty 的值时会调用该方法</span><br><span class="hljs-comment">   * 然后执行 this.get，即 watcher 的回调函数，得到返回值</span><br><span class="hljs-comment">   * this.dirty 被置为 false，作用是页面在本次渲染中只会一次 computed.key 的回调函数，</span><br><span class="hljs-comment">   *   这也是大家常说的 computed 和 methods 区别之一是 computed 有缓存的原理所在</span><br><span class="hljs-comment">   * 而页面更新后会 this.dirty 会被重新置为 true，这一步是在 this.update 方法中完成的</span><br><span class="hljs-comment">   */</span><br>  evaluate () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">false</span><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Depend on all deps collected by this watcher.</span><br><span class="hljs-comment">   */</span><br>  depend () &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i].<span class="hljs-title function_">depend</span>()<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Remove self from all dependencies&#x27; subscriber list.</span><br><span class="hljs-comment">   */</span><br>  teardown () &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) &#123;<br>      <span class="hljs-comment">// remove self from vm&#x27;s watcher list</span><br>      <span class="hljs-comment">// this is a somewhat expensive operation so we skip it</span><br>      <span class="hljs-comment">// if the vm is being destroyed.</span><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>.<span class="hljs-property">_isBeingDestroyed</span>) &#123;<br>        <span class="hljs-title function_">remove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>.<span class="hljs-property">_watchers</span>, <span class="hljs-variable language_">this</span>)<br>      &#125;<br>      <span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span><br>      <span class="hljs-keyword">while</span> (i--) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i].<span class="hljs-title function_">removeSub</span>(<span class="hljs-variable language_">this</span>)<br>      &#125;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span> = <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 new Vue 时，vue 初始化的时候会调用 initState，在 initState 中会依次调用，initProps、initMethods、initData、initComputed、initWatch，这个顺序是固定的，因为存在优先级，一些属性是不能重复的，后面的函数会做判断，来避免重复的情况。</p><p>在具体的 init 函数中，我主要说一下 data 吧，首先 data 会做一个判重，避免和 props 以及 methods 的属性重复。然后会调用定义好的 proxy 函数将 data 中的数据代理到 vue 实例上，以便于通过 this.key 去访问。最后调用 observe 函数，传入data，给数据设置响应式。observe 函数就是数据响应式的入口，在 observe 函数里面会 new 一个 Observer，Observer 是一个观察者类，在构造函数中，会判断传进来的是数组还是对象。</p><p>如果是对象的话，会调用 walk 函数，遍历所有键，调用 defineReactive，在 defineReactive 中，首先会做一个递归处理，因为响应式是深层的嘛，不过不是递归调用自身 （defineReactive）而是调用 observe，传入值，再 new Observer，再调用 defineReactive，可以说是三个函数的循环递归。defineReactive 递归后，通过 object.defineProperty 设置 getter 和 setter，这也是真正响应式的核心，getter 中 会通过 dep.depend 做依赖收集，dep 添加到 watcher 中，watcher 也添加到 dep 中，dep 实际上就是 object.key。setter 中首先做一些处理，判断新值和老值是不是一样，判断属性是不是只读，处理完毕才会设置新值，然后对新值调用 observe，让新值也是响应式的，然后调用 dep.notify 通知依赖更新。</p><p>如果是数组的话，首先会改写数组原型上的方法，因为这些方法都可以改变数组。然后会调用 observeArray 函数，对数组的每一项调用 observe，总归是又回到了 observe，后面的流程其实和对象差不多。对于数组原型方法的改写其实也比较简单，再执行原生的方法之后，需要判断该方法，是不是 push&#x2F;unshift&#x2F;splice，如果是的话，就代表插入了新元素，需要调用 observeArray 对新元素做响应式处理，然后notify 通知更新。</p><p>然后像 initProps 的话，就是比较简单的遍历 props，defineReactive 设置响应式，再 proxy 代理到 vue 实例上。</p><p>initMethods，首先判断是否为函数，然后判重，最后绑定到 vue 实例上。</p><p>initComputed，也有判重和绑定到 vue 实例的步骤，主要是调用 createWatcher 创建一个懒执行的 watcher，调用 $watch，$watch里会对配置对象做一些处理，比如说 immediate 为 true，$watch 里就会理解调用一次函数，最后会返回一个 unwatch 函数用来解除监听。</p><p>initWatch 其实是差不多的。所以可以说 computed 和 watch 的本质是一样的，都是通过 Watcher 实现的，只是使用场景上有些区别，然后 computed 是懒执行的。computed 的缓存性是通过 watcher 的 dirty 属性 以及 evaluate 和 update 方法实现的，dirty 为 true 时，才会 watcher.evaluate 来计算新的结果并把 dirty 置为 false，否则就用缓存的结果。直到页面更新后，watcher.update 调用后才会将 dirty 置为 true。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6950826293923414047">https://juejin.cn/post/6950826293923414047</a></p><p><a href="https://juejin.cn/post/7074422512318152718">https://juejin.cn/post/7074422512318152718</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.Vue初始化过程</title>
    <link href="/2022/10/21/2-Vue%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/10/21/2-Vue%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>&#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; initMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./init&#x27;</span><br><br><span class="hljs-comment">// Vue 构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span> (options) &#123;<br>  <span class="hljs-comment">// 调用 Vue.prototype._init 方法，该方法是在 initMixin 中定义的</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options)<br>&#125;<br><br><span class="hljs-comment">// 定义 Vue.prototype._init 方法</span><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Vue</span><br></code></pre></td></tr></table></figure><p>vue 初始化时调用了 initMixin，为其绑定了 vue.prototype._init</p><p>在 new Vue(options) 时，会调用 Vue.prototype._init(options)</p><h2 id="Vue-prototype-init"><a href="#Vue-prototype-init" class="headerlink" title="Vue.prototype._init"></a>Vue.prototype._init</h2><p>&#x2F;src&#x2F;core&#x2F;instance&#x2F;init.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义 Vue.prototype._init 方法 </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; Vue Vue 构造函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initMixin</span> (<span class="hljs-title class_">Vue</span>: <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">Component</span>&gt;) &#123;<br>  <span class="hljs-comment">// 负责 Vue 的初始化过程</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_init</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options?: <span class="hljs-built_in">Object</span></span>) &#123;<br>    <span class="hljs-comment">// vue 实例</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>    <span class="hljs-comment">// 每个 vue 实例都有一个 _uid，并且是依次递增的</span><br>    vm.<span class="hljs-property">_uid</span> = uid++<br><br>    <span class="hljs-comment">// a flag to avoid this being observed</span><br>    vm.<span class="hljs-property">_isVue</span> = <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// 处理组件配置项</span><br>    <span class="hljs-keyword">if</span> (options &amp;&amp; options.<span class="hljs-property">_isComponent</span>) &#123;<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 每个子组件初始化时走这里，这里只做了一些性能优化</span><br><span class="hljs-comment">       * 将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-title function_">initInternalComponent</span>(vm, options)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 初始化根组件时走这里，合并 Vue 的全局配置到根组件的局部配置，比如 Vue.component 注册的全局组件会合并到 根实例的 components 选项中</span><br><span class="hljs-comment">       * 至于每个子组件的选项合并则发生在两个地方：</span><br><span class="hljs-comment">       *   1、Vue.component 方法注册的全局组件在注册时做了选项合并</span><br><span class="hljs-comment">       *   2、&#123; components: &#123; xx &#125; &#125; 方式注册的局部组件在执行编译器生成的 render 函数时做了选项合并，包括根组件中的 components 配置</span><br><span class="hljs-comment">       */</span><br>      vm.<span class="hljs-property">$options</span> = <span class="hljs-title function_">mergeOptions</span>(<br>        <span class="hljs-title function_">resolveConstructorOptions</span>(vm.<span class="hljs-property">constructor</span>),<br>        options || &#123;&#125;,<br>        vm<br>      )<br>    &#125;<br>    <span class="hljs-comment">/* istanbul ignore else */</span><br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 设置代理，将 vm 实例上的属性代理到 vm._renderProxy</span><br>      <span class="hljs-title function_">initProxy</span>(vm)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      vm.<span class="hljs-property">_renderProxy</span> = vm<br>    &#125;<br>    <span class="hljs-comment">// expose real self</span><br>    vm.<span class="hljs-property">_self</span> = vm<br>    <span class="hljs-comment">// 初始化组件实例关系属性，比如 $parent、$children、$root、$refs 等</span><br>    <span class="hljs-title function_">initLifecycle</span>(vm)<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化自定义事件，这里需要注意一点，所以我们在 &lt;comp <span class="hljs-doctag">@click</span>=&quot;handleClick&quot; /&gt; 上注册的事件，监听者不是父组件，</span><br><span class="hljs-comment">     * 而是子组件本身，也就是说事件的派发和监听者都是子组件本身，和父组件无关</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">initEvents</span>(vm)<br>    <span class="hljs-comment">// 解析组件的插槽信息，得到 vm.$slot，处理渲染函数，得到 vm.$createElement 方法，即 h 函数</span><br>    <span class="hljs-title function_">initRender</span>(vm)<br>    <span class="hljs-comment">// 调用 beforeCreate 钩子函数</span><br>    <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;beforeCreate&#x27;</span>)<br>    <span class="hljs-comment">// 初始化组件的 inject 配置项，得到 result[key] = val 形式的配置对象，然后对结果数据进行响应式处理，并代理每个 key 到 vm 实例</span><br>    <span class="hljs-title function_">initInjections</span>(vm) <span class="hljs-comment">// resolve injections before data/props</span><br>    <span class="hljs-comment">// 数据响应式的重点，处理 props、methods、data、computed、watch</span><br>    <span class="hljs-title function_">initState</span>(vm)<br>    <span class="hljs-comment">// 解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上</span><br>    <span class="hljs-title function_">initProvide</span>(vm) <span class="hljs-comment">// resolve provide after data/props</span><br>    <span class="hljs-comment">// 调用 created 钩子函数</span><br>    <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;created&#x27;</span>)<br><br>    <span class="hljs-comment">// 如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount，反之，没有 el 则必须手动调用 $mount</span><br>    <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>) &#123;<br>      <span class="hljs-comment">// 调用 $mount 方法，进入挂载阶段</span><br>      vm.$mount(vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化过程做了什么"><a href="#初始化过程做了什么" class="headerlink" title="初始化过程做了什么"></a>初始化过程做了什么</h2><ul><li><strong>处理组件配置项</strong><ul><li>初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上<ul><li>mergeOptions</li><li>resolveConstructorOptions</li></ul></li><li>初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率<ul><li>initInternalComponent</li></ul></li></ul></li><li><strong>初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等</strong></li><li>initLifecycle</li><li><strong>处理自定义事件</strong></li><li>initEvents</li><li><strong>调用 beforeCreate 钩子函数</strong></li><li>callHook(vm, ‘beforeCreate’)</li><li><strong>初始化组件的 inject 配置项</strong>，得到 <code>ret[key] = val</code> 形式的配置对象，然后对该配置对象进行浅层的响应式处理（只处理了对象第一层数据），并代理每个 key 到 vm 实例上<ul><li>initInjections(vm)</li></ul></li><li><strong>数据响应式，处理 props、methods、data、computed、watch 等选项</strong><ul><li>initState(vm)</li></ul></li><li><strong>解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上</strong><ul><li>initProvide(vm)</li></ul></li><li><strong>调用 created 钩子函数</strong><ul><li>callHook(vm, ‘created’)</li></ul></li><li><strong>如果发现配置项上有 el 选项，则自动调用 $mount 方法</strong>，也就是说有了 el 选项，就不需要再手动调用 ​$mount 方法，反之，没提供 el 选项则必须调用 $mount</li><li>接下来则进入挂载阶段</li></ul><h2 id="源码层面解释面试题"><a href="#源码层面解释面试题" class="headerlink" title="源码层面解释面试题"></a>源码层面解释面试题</h2><ol><li>beforeCreate 时有数据响应式吗？</li></ol><p>从源码上来看，在 vue 初始化时，会首先调用已经在 initMixin 时绑定在 vue 原型上的 _init 方法，在 _init 函数中，会按顺序执行很多个初始化函数以及生命周期调用函数，而 initState 是写在 callHook(vm, ‘beforeCreate’) 后面的，所以 beforeCreate 时还没有数据响应式。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6950084496515399717">https://juejin.cn/post/6950084496515399717</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.如何调试源码</title>
    <link href="/2022/10/20/1-%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81/"/>
    <url>/2022/10/20/1-%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="记录一下步骤"><a href="#记录一下步骤" class="headerlink" title="记录一下步骤"></a>记录一下步骤</h2><ol><li>下载源码</li></ol><p><a href="https://github.com/vuejs/vue/tree/dev">https://github.com/vuejs/vue/tree/dev</a></p><ol start="2"><li>安装依赖</li></ol><p>使用 npm 会报错，使用 yarn 不会</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm i -g yarn<br>yarn <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><ol start="3"><li>添加 sourcemap</li></ol><p>package.json 中添加 –sourcemap</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>启动开发环境</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> dev<br></code></pre></td></tr></table></figure><p>如果报类似错误，就 yarn add 装一下包</p><p>Cannot find module ‘@vue&#x2F;consolidate&#x2F;package.json’</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">yarn <span class="hljs-built_in">add</span> consolidate<br></code></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs smali">├── benchmarks                  性能、基准测试<br>├── dist                        构建打包的输出目录<br>├── examples                    案例目录<br>├── flow                        flow 语法的类型声明<br>├── packages                    一些额外的包，比如：负责服务端渲染的包 vue-server-renderer、配合 vue-loader 使用的的 vue-template-compiler，还有 weex 相关的<br>│   ├── vue-server-renderer<br>│   ├── vue-template-compiler<br>│   ├── weex-template-compiler<br>│   └── weex-vue-framework<br>├── scripts                     所有的配置文件的存放位置，比如 rollup 的配置文件<br>├── src                         vue 源码目录<br>│   ├── compiler                编译器<br>│   ├── core                    运行时的核心包<br>│   │   ├── components          全局组件，比如 keep-alive<br>│   │   ├── config.js           一些默认配置项<br>│   │   ├── global-api          全局 API，比如熟悉的：Vue.use()、Vue.component() 等<br>│   │   ├──<span class="hljs-built_in"> instance </span>           Vue 实例相关的，比如 Vue 构造函数就在这个目录下<br>│   │   ├── observer            响应式原理<br>│   │   ├── util                工具方法<br>│   │   └── vdom                虚拟 DOM 相关，比如熟悉的 patch 算法就在这儿<br>│   ├── platforms               平台相关的编译器代码<br>│   │   ├── web<br>│   │   └── weex<br>│   ├── server                  服务端渲染相关<br>├── test                        测试目录<br>├── types                       TS 类型声明<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/user/1028798616461326/posts">https://juejin.cn/user/1028798616461326/posts</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nextTick</title>
    <link href="/2022/10/19/nextTick/"/>
    <url>/2022/10/19/nextTick/</url>
    
    <content type="html"><![CDATA[<h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>nextTick 接收一个回调函数作为参数，并将这个回调函数延迟到DOM更新后才执行；</p><p><strong>使用场景</strong>：想要<strong>操作 基于最新数据生成的DOM 时</strong>，就将这个操作放在 nextTick 的回调中；</p><h2 id="为什么需要nextTick"><a href="#为什么需要nextTick" class="headerlink" title="为什么需要nextTick"></a>为什么需要nextTick</h2><p>因为 vue 采用的<strong>异步更新策略</strong>，当监听到数据发生变化的时候不会立即去更新DOM，而是开启一个任务队列，并缓存在同一事件循环中发生的所有数据变更。</p><p>这种做法带来的好处就是可以将多次数据更新合并成一次，<strong>减少操作DOM的次数</strong>，如果不采用这种方法，假设数据改变100次就要去更新100次DOM，而频繁的DOM更新是很耗性能的。举个例子，如果同一个 <code>Watcher</code> 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</p><p>然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p><h2 id="nextTick-实现原理"><a href="#nextTick-实现原理" class="headerlink" title="nextTick 实现原理"></a>nextTick 实现原理</h2><p><strong>将传入的回调函数包装成异步任务</strong>，异步任务又分微任务和宏任务，<strong>为了尽快执行所以优先选择微任务</strong>；</p><p>nextTick 提供了四种异步方法 Promise.then、MutationObserver、setImmediate、setTimeout(fn,0)</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p><strong>vue3 源码位置:</strong> CORE&#x2F;packages&#x2F;runtime-core&#x2F;src&#x2F;scheduler.ts</p><p><strong>vue2 源码位置:</strong> src&#x2F;core&#x2F;util&#x2F;next-tick.js</p><h3 id="nextTick-1"><a href="#nextTick-1" class="headerlink" title="nextTick"></a>nextTick</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以 vue2 源码为例</span><br><span class="hljs-keyword">import</span> &#123; noop &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;shared/util&#x27;</span><br><span class="hljs-keyword">import</span> &#123; handleError &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./error&#x27;</span><br><span class="hljs-keyword">import</span> &#123; isIE, isIOS, isNative &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./env&#x27;</span><br><br><span class="hljs-comment">//  上面三行与核心代码关系不大，了解即可</span><br><span class="hljs-comment">//  noop 表示一个无操作空函数，用作函数默认值，防止传入 undefined 导致报错</span><br><span class="hljs-comment">//  handleError 错误处理函数</span><br><span class="hljs-comment">//  isIE, isIOS, isNative 环境判断函数，</span><br><span class="hljs-comment">//  isNative 判断是否原生支持，如果通过第三方实现支持也会返回 false</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> isUsingMicroTask = <span class="hljs-literal">false</span>     <span class="hljs-comment">// nextTick 最终是否以微任务执行</span><br><br><span class="hljs-keyword">const</span> callbacks = []     <span class="hljs-comment">// 存放调用 nextTick 时传入的回调函数</span><br><span class="hljs-keyword">let</span> pending = <span class="hljs-literal">false</span>     <span class="hljs-comment">// 标识当前是否有 nextTick 在执行，同一时间只能有一个执行</span><br><br><span class="hljs-comment">// 声明 nextTick 函数，接收一个回调函数和一个执行上下文作为参数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">nextTick</span>(<span class="hljs-params">cb?: <span class="hljs-built_in">Function</span>, ctx?: <span class="hljs-built_in">Object</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> _resolve<br>    <span class="hljs-comment">// 将传入的回调函数存放到数组中，后面会遍历执行其中的回调</span><br>    callbacks.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (cb) &#123;   <span class="hljs-comment">// 对传入的回调进行 try catch 错误捕获</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                cb.<span class="hljs-title function_">call</span>(ctx)<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                <span class="hljs-title function_">handleError</span>(e, ctx, <span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_resolve) &#123;<br>            <span class="hljs-title function_">_resolve</span>(ctx)<br>        &#125;<br>    &#125;)<br>    <br>    <span class="hljs-comment">// 如果当前没有在 pending 的回调，就执行 timeFunc 函数选择当前环境优先支持的异步方法</span><br>    <span class="hljs-keyword">if</span> (!pending) &#123;<br>        pending = <span class="hljs-literal">true</span><br>        <span class="hljs-title function_">timerFunc</span>()<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果没有传入回调，并且当前环境支持 promise，就返回一个 promise</span><br>    <span class="hljs-keyword">if</span> (!cb &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>            _resolve = resolve<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="timerFunc"><a href="#timerFunc" class="headerlink" title="timerFunc"></a>timerFunc</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断当前环境优先支持的异步方法，优先选择微任务</span><br><span class="hljs-comment">// 优先级：Promise---&gt; MutationObserver---&gt; setImmediate---&gt; setTimeout</span><br><span class="hljs-comment">// setTimeOut 最小延迟也要4ms，而 setImmediate 会在主线程执行完后立刻执行</span><br><span class="hljs-comment">// setImmediate 在 IE10 和 node 中支持</span><br><br><span class="hljs-comment">// 多次调用 nextTick 时 ,timerFunc 只会执行一次</span><br><br><span class="hljs-keyword">let</span> timerFunc   <br><span class="hljs-comment">// 1.判断当前环境是否支持 promise</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">Promise</span>)) &#123;  <span class="hljs-comment">// 支持 promise</span><br>    <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>    timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 用 promise.then 把 flushCallbacks 函数包裹成一个异步微任务</span><br>        p.<span class="hljs-title function_">then</span>(flushCallbacks)<br>        <span class="hljs-keyword">if</span> (isIOS) <span class="hljs-built_in">setTimeout</span>(noop)<br>    &#125;<br>    <span class="hljs-comment">// 标记当前 nextTick 使用的微任务</span><br>    isUsingMicroTask = <span class="hljs-literal">true</span><br>    <br>    <span class="hljs-comment">// 2.如果不支持 promise，就判断是否支持 MutationObserver</span><br>    <span class="hljs-comment">// 不是IE环境，并且原生支持 MutationObserver，那也是一个微任务</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MutationObserver</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; (<br>    <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">MutationObserver</span>) ||<br>    <span class="hljs-title class_">MutationObserver</span>.<span class="hljs-title function_">toString</span>() === <span class="hljs-string">&#x27;[object MutationObserverConstructor]&#x27;</span><br>)) &#123;<br>    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span><br>    <span class="hljs-comment">// new 一个 MutationObserver 类</span><br>    <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(flushCallbacks) <br>    <span class="hljs-comment">// 创建一个文本节点</span><br>    <span class="hljs-keyword">const</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-title class_">String</span>(counter))   <br>    <span class="hljs-comment">// 监听这个文本节点，当数据发生变化就执行 flushCallbacks </span><br>    observer.<span class="hljs-title function_">observe</span>(textNode, &#123; <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span> &#125;)<br>    timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>        counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span><br>        textNode.<span class="hljs-property">data</span> = <span class="hljs-title class_">String</span>(counter)  <span class="hljs-comment">// 数据更新</span><br>    &#125;<br>    isUsingMicroTask = <span class="hljs-literal">true</span>    <span class="hljs-comment">// 标记当前 nextTick 使用的微任务</span><br>    <br>    <span class="hljs-comment">// 3.判断当前环境是否原生支持 setImmediate</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(setImmediate)) &#123;<br>    timerFunc = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-title function_">setImmediate</span>(flushCallbacks)  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 4.以上三种都不支持就选择 setTimeout</span><br>    timerFunc = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>timerFunc</code> 函数就是用各种异步执行的方法调用 <code>flushCallbacks</code> 函数。</p><h3 id="flushCallbacks"><a href="#flushCallbacks" class="headerlink" title="flushCallbacks"></a>flushCallbacks</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 如果多次调用 nextTick，会依次执行上面的方法，将 nextTick 的回调放在 callbacks 数组中</span><br><span class="hljs-comment">// 最后通过 flushCallbacks 函数遍历 callbacks 数组的拷贝并执行其中的回调</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushCallbacks</span>(<span class="hljs-params"></span>) &#123;<br>    pending = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> copies = callbacks.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>)    <span class="hljs-comment">// 拷贝一份</span><br>    callbacks.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>    <span class="hljs-comment">// 清空 callbacks</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; copies.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-comment">// 遍历执行传入的回调</span><br>        copies[i]()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 为什么要拷贝一份 callbacks</span><br><br><span class="hljs-comment">// callbacks.slice(0) 将 callbacks 拷贝出来一份，</span><br><span class="hljs-comment">// 是因为考虑到 nextTick 回调中可能还会调用 nextTick 的情况,</span><br><span class="hljs-comment">// 如果 nextTick 回调中又调用了一次 nextTick，则又会向 callbacks 中添加回调，</span><br><span class="hljs-comment">// nextTick 回调中的 nextTick 应该放在下一轮执行，</span><br><span class="hljs-comment">// 如果不将 callbacks 复制一份就可能一直循环</span><br></code></pre></td></tr></table></figure><h2 id="x3D-x3D-流程总结-x3D-x3D"><a href="#x3D-x3D-流程总结-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;流程总结&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;流程总结&#x3D;&#x3D;</strong></h2><p>1.nextTick 会将传入的函数做一个包装然后放到 callbacks 数组里，这个包装主要是针对没传入回调以及回调错误捕获。</p><p>2.如果当前没有其它 nextTick 在执行的话，就会调用 timerFunc 函数，会根据环境，做一个兼容性判断，选择某一种异步执行的方法调用 flushCallbacks 函数。优先级是 promise.then &gt; object.observe &gt; setImmediate &gt; setTimeout。（因为 timerFunc 是异步的，同时只能执行一个）</p><p>3.flushCallbacks 遍历 callbacks 执行其中每一个回调。这里注意，源码里对 callbacks 做了一个拷贝，因为执行回调的过程中，可能会触发新的 nextTick，会将新的回调 push 入 callbacks，这样可能就会一直循环下去。因此nextTick 回调中的 nextTick 应该放在下一轮执行。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7102750403418128391">https://juejin.cn/post/7102750403418128391</a></p><p><a href="https://juejin.cn/post/7087866362785169416">https://juejin.cn/post/7087866362785169416</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DOM事件级别</title>
    <link href="/2022/10/16/DOM%E4%BA%8B%E4%BB%B6%E7%BA%A7%E5%88%AB/"/>
    <url>/2022/10/16/DOM%E4%BA%8B%E4%BB%B6%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="DOM-事件级别"><a href="#DOM-事件级别" class="headerlink" title="DOM 事件级别"></a>DOM 事件级别</h3><p>DOM 级别：0 1 2 3</p><p>DOM 事件级别：0 2 3</p><p>DOM1 标准并没有定义事件相关的内容</p><h4 id="DOM0"><a href="#DOM0" class="headerlink" title="DOM0"></a>DOM0</h4><p><strong>绑定事件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button type=&quot;button&quot; onclick=&quot;showFn()&quot;&gt;&lt;/button&gt;<br>function showFn() &#123;<br>    alert(&#x27;Hello World&#x27;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;/button&gt;<br>var btn = document.getElementById(&#x27;btn&#x27;);<br>btn.onclick = function() &#123;<br>    console.log(&#x27;Hello World&#x27;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解绑</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-property">onclick</span> = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>不需要操作DOM来绑定事件</li></ul><p><strong>缺点</strong></p><ul><li><p>HTML和JS耦合太强</p></li><li><p>一个元素无法同时绑定多个处理函数</p></li></ul><h4 id="DOM2"><a href="#DOM2" class="headerlink" title="DOM2"></a>DOM2</h4><p><strong>绑定事件</strong></p><p>DOM2级事件定义了addEventListener 和 removeEventListener两个方法，分别用来绑定和解绑事件。</p><p>方法中包含三个参数，分别是绑定的事件处理的属性名称（没有on） 、处理函数和是否在捕获时候执行事件处理函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span> type=<span class="hljs-string">&quot;button&quot;</span>&gt;&lt;/button&gt;<br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);    <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showFn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;    <br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, showFn, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p><strong>解绑</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, showFn, <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>同时绑定几个事件（相同或不同），然后顺序执行，不会覆盖。</li></ul><p><strong>缺点</strong></p><ul><li>不具有跨浏览器优势。</li></ul><p><strong>注意</strong></p><p>dom0和dom2可以共存，不互相覆盖，但是dom0之间依然会覆盖。</p><h4 id="DOM3"><a href="#DOM3" class="headerlink" title="DOM3"></a>DOM3</h4><p><strong>DOM3级事件是在DOM2级事件的基础上添加很多事件类型。</strong></p><ul><li>UI事件，当用户与页面上的元素交互时触发，如：load、scroll</li><li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li><li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</li><li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li><li>文本事件，当在文档中输入文本时触发，如：textInput</li><li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li><li>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</li><li>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</li><li>同时DOM3级事件也允许使用者自定义一些事件。</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/1b2248f01338">https://www.jianshu.com/p/1b2248f01338</a></p><p><a href="https://blog.csdn.net/qq_44381873/article/details/106722394">https://blog.csdn.net/qq_44381873/article/details/106722394</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>DOM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何用js创建声音</title>
    <link href="/2022/10/14/%E5%A6%82%E4%BD%95%E7%94%A8js%E5%88%9B%E5%BB%BA%E5%A3%B0%E9%9F%B3/"/>
    <url>/2022/10/14/%E5%A6%82%E4%BD%95%E7%94%A8js%E5%88%9B%E5%BB%BA%E5%A3%B0%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>实习时的项目有一个节拍器的需求（根据谱子打节拍）</p><p>考虑了两种方式，当然可以使用一个简短的音频文件，在每个拍子到来时播放。抱着不增加额外资源的原则，我便提出了这样一个问题：JS 能不能创造声音？</p><h2 id="查阅资料"><a href="#查阅资料" class="headerlink" title="查阅资料"></a>查阅资料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API">HTML5 Web Audio API</a> 是一个非常强大的 API，但因为在实习之前极少接触音频文件，所以我对其并不了解。</p><p>我们需要利用其中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext">AudioContext</a></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">tick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 兼容 webkit</span><br>    <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">AudioContext</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkitAudioContext</span>)();<br>    <span class="hljs-comment">// 创建一个振荡器(声音源于震动)</span><br>    <span class="hljs-keyword">const</span> osc = context.<span class="hljs-title function_">createOscillator</span>();<br>    <span class="hljs-comment">// 指定波形 sine/square/triangle/sawtooth </span><br>    osc.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;square&#x27;</span>;<br>    <span class="hljs-comment">// 指定 频率(与音调/音高有关)</span><br>    osc.<span class="hljs-property">frequency</span>.<span class="hljs-property">value</span> = <span class="hljs-number">500</span>; <span class="hljs-comment">// Hz</span><br>    <span class="hljs-comment">// 和音频设备关联(通常为扬声器)</span><br>    osc.<span class="hljs-title function_">connect</span>(context.<span class="hljs-property">destination</span>);<br>    <span class="hljs-comment">// 播放声音</span><br>    osc.<span class="hljs-title function_">start</span>();<br>    <span class="hljs-comment">// 声音停止(在0.1s后)</span><br>    osc.<span class="hljs-title function_">stop</span>(context.<span class="hljs-property">currentTime</span> + <span class="hljs-number">0.1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.不能创建一个声音然后反复的播放这个声音。播放完毕后会自动销毁，再播放需要重新创建。针对于我的需求，很浪费性能，因为我需要短时间内播放很多次。</p><p>2.经过测试，短时间好像只能创建50个，但实际要打的拍子很可能不止50个。（短时间创建限制50个是我的推测，每次都打到一半不出声了，我看好像是停在了50个拍子）</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>只创建一个音频，只在必要时 osc.connect()，连接扬声器</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhangxinxu.com/wordpress/2017/06/html5-web-audio-api-js-ux-voice/">https://www.zhangxinxu.com/wordpress/2017/06/html5-web-audio-api-js-ux-voice/</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>可能不太重要的知识点</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>svg</title>
    <link href="/2022/09/29/svg/"/>
    <url>/2022/09/29/svg/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-svg"><a href="#什么是-svg" class="headerlink" title="什么是 svg"></a>什么是 svg</h2><p>svg 是矢量图的一种格式。用 xml 来描述图形。</p><ul><li>位图：放大会失真图像边缘有锯齿；是由像素点组成； <code>Canvas</code> 就是位图效果。</li><li>矢量图：放大不会失真；使用 <code>XML</code> 描述图形。</li></ul><img src="/2022/09/29/svg/image-20220929170313597.png" class="" title="image-20220929170313597"><h2 id="和-html-的关系"><a href="#和-html-的关系" class="headerlink" title="和 html 的关系"></a>和 html 的关系</h2><p>使用时可以将其理解为 html 的新标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在不给 <code>&lt;svg&gt;</code> 设置宽高时，它的默认宽度是 <code>300px</code> ，默认高度是 <code>150px</code> 。和 canvas 一致</p><p><code>HTML</code> 的元素大多数默认都是矩形，<code>SVG</code> 在形状上更加丰富。</p><h2 id="基础图形"><a href="#基础图形" class="headerlink" title="基础图形"></a>基础图形</h2><h3 id="矩形-rect"><a href="#矩形-rect" class="headerlink" title="矩形 rect"></a>矩形 rect</h3><p>矩形使用 <code>&lt;rect&gt;</code> 标签，默认填充色是黑色，当只设置宽高时，渲染出来的矩形就是黑色的矩形。</p><p>稍后还会说明如何设置样式（比如边框、填充色等），这里只列出矩形基础属性：</p><ul><li><code>x</code>: 左上角x轴坐标</li><li><code>y</code>: 左上角y轴坐标</li><li><code>width</code>: 宽度</li><li><code>height</code>: 高度</li><li><code>rx</code>: 圆角，x轴的半径</li><li><code>ry</code>: 圆角，y轴的半径</li></ul><h3 id="圆形-circle"><a href="#圆形-circle" class="headerlink" title="圆形 circle"></a>圆形 circle</h3><p>圆形使用 <code>&lt;circle&gt;</code> 标签，基础属性有：</p><ul><li><code>cx</code>: 圆心在x轴的坐标</li><li><code>cy</code>: 圆心在y轴的坐标</li><li><code>r</code>: 半径</li></ul><h3 id="椭圆-ellipse"><a href="#椭圆-ellipse" class="headerlink" title="椭圆 ellipse"></a>椭圆 ellipse</h3><p>椭圆使用 <code>&lt;ellipse&gt;</code> 标签，基础属性有：</p><ul><li><code>cx</code>: 圆心在x轴的坐标</li><li><code>cy</code>: 圆心在y轴的坐标</li><li><code>rx</code>: x轴的半径</li><li><code>ry</code>: y轴的半径</li></ul><p><code>&lt;ellipse&gt;</code> 和 <code>&lt;circle&gt;</code> 差不多，只是将半径拆成x轴和y轴的。</p><h3 id="直线-line"><a href="#直线-line" class="headerlink" title="直线 line"></a>直线 line</h3><p>直线使用 <code>&lt;line&gt;</code> 标签，基础属性有：</p><ul><li><code>x1</code>: 起始点x坐标</li><li><code>y1</code>: 起始点y坐标</li><li><code>x2</code>: 结束点x坐标</li><li><code>y2</code>: 结束点y坐标</li><li><code>stroke</code>: 描边颜色</li></ul><h3 id="折线-polyline"><a href="#折线-polyline" class="headerlink" title="折线 polyline"></a>折线 polyline</h3><p>使用 <code>&lt;polyline&gt;</code> 可以绘制折线，基础属性有：</p><ul><li><code>points</code>: 一串点集，点集是两两一组表示一个坐标。</li><li><code>stroke</code>: 描边颜色</li><li><code>fill</code>: 填充颜色</li></ul><h3 id="多边形-polygon"><a href="#多边形-polygon" class="headerlink" title="多边形 polygon"></a>多边形 polygon</h3><p>多边形使用 <code>&lt;polygon&gt;</code> 标签，基础属性和 <code>&lt;polyline&gt;</code> 差不多：</p><ul><li><code>points</code>: 点集</li><li><code>stroke</code>: 描边颜色</li><li><code>fill</code>: 填充颜色</li></ul><p><code>&lt;polygon&gt;</code> 会自动闭合（自动将起始点和结束点链接起来）。</p><h3 id="直线路径-path"><a href="#直线路径-path" class="headerlink" title="直线路径 path"></a>直线路径 path</h3><p>其实在 <code>SVG</code> 里，所有基本图形都是 <code>&lt;path&gt;</code> 的简写。所有描述轮廓的数据都放在 <code>d</code> 属性里，<code>d</code> 是 <code>data</code> 的简写。</p><p><code>d</code> 属性又包括以下主要的关键字（注意大小写！）：</p><ul><li>M: 起始点坐标，<code>moveto</code> 的意思。每个路径都必须以 <code>M</code> 开始。<code>M</code> 传入 <code>x</code> 和 <code>y</code> 坐标，用逗号或者空格隔开。</li><li><code>L</code>: 轮廓坐标，<code>lineto</code> 的意思。<code>L</code> 是跟在 <code>M</code> 后面的。它也是可以传入一个或多个坐标。大写的 <code>L</code> 是一个<strong>绝对位置</strong>。</li><li>l: 这是小写 <code>L</code>，和 <code>L</code> 的作用差不多，但 <code>l</code> 是一个<strong>相对位置</strong>。</li><li><code>H</code>: 和上一个点的Y坐标相等，是 <code>horizontal lineto</code> 的意思。它是一个<strong>绝对位置</strong>。</li><li><code>h</code>: 和 <code>H</code> 差不多，但 <code>h</code> 使用的是<strong>相对定位</strong>。</li><li><code>V</code>: 和上一个点的X坐标相等，是<code>vertical lineto</code> 的意思。它是一个<strong>绝对位置</strong>。</li><li><code>v</code>: 这是一个小写的 <code>v</code> ，和大写 <code>V</code> 的差不多，但小写 <code>v</code> 是一个相对定位。</li><li><code>Z</code>: 关闭当前路径，<code>closepath</code> 的意思。它会绘制一条直线回到当前子路径的起点。</li></ul><p>概念说了一堆，还是用写 <code>demo</code> 的方式来展示会更加直观。</p><h3 id="曲线-椭圆弧路径-path"><a href="#曲线-椭圆弧路径-path" class="headerlink" title="曲线 - 椭圆弧路径 path"></a>曲线 - 椭圆弧路径 path</h3><p>如果只用两个点，可以产生无数条曲线。所以需要添加更多的参数来确定如何绘制一条曲线。而在种种方法中， <strong>椭圆弧曲线</strong> 是最简单的。</p><p>在 <code>SVG</code> 中可以使用 <code>path</code> 配合 <code>A属性</code> 绘制椭圆弧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">A</span>(rx, ry, xr, laf, sf, x, y)<br></code></pre></td></tr></table></figure><ul><li><code>rx</code>: 椭圆X轴半径</li><li><code>ry</code>: 椭圆Y轴半径</li><li><code>xr</code>: 椭圆旋转角度</li><li><code>laf</code>: 是否选择弧长较长的那一段。0: 短边（小于180度）; 1: 长边（大于等于180度）</li><li><code>sf</code>: 是否顺时针绘制。0: 逆时针; 1: 顺时针</li><li><code>x</code>: 终点X轴坐标</li><li><code>y</code>: 终点Y轴坐标</li></ul><p>上面的公式中并没有开始点，<strong>开始点是由 <code>M</code> 决定的</strong>。</p><p>也就是说，<strong>M和x, y确定2个点，再由rx,ry,xr确定两个椭圆</strong>。两个椭圆被切割为4条曲线段，通过 las 和 sf 确定要的是哪条。</p><img src="/2022/09/29/svg/image-20221004143318141.png" class="" title="image-20221004143318141"><p>绘制弧线是比较抽象的，可以使用 <strong>Illustrator</strong> 绘制，然后生成 <code>SVG</code> 来使用。</p><h2 id="常用样式"><a href="#常用样式" class="headerlink" title="常用样式"></a>常用样式</h2><h3 id="填充-fill"><a href="#填充-fill" class="headerlink" title="填充 fill"></a>填充 fill</h3><p>填充图案颜色，<code>fill</code> 默认是 <code>#000000</code>  黑色。</p><p>也可以使用 <code>none</code> 或者 <code>transparent</code> 将填充色设置成透明。</p><h3 id="填充色的不透明度-fill-opacity"><a href="#填充色的不透明度-fill-opacity" class="headerlink" title="填充色的不透明度 fill-opacity"></a>填充色的不透明度 fill-opacity</h3><p>和 css 的 opacity 一样</p><h3 id="描边颜色-stroke"><a href="#描边颜色-stroke" class="headerlink" title="描边颜色 stroke"></a>描边颜色 stroke</h3><p>可以通过 <code>stroke</code> 属性设置描边的颜色。如果不设置 <code>stroke</code> ，图形默认是没有描边颜色的。</p><h3 id="描边颜色的不透明度-stroke-opacity"><a href="#描边颜色的不透明度-stroke-opacity" class="headerlink" title="描边颜色的不透明度 stroke-opacity"></a>描边颜色的不透明度 stroke-opacity</h3><p>和 <code>fill-opacity</code> 差不多，只不过 <code>stroke-opacity</code> 是设置描边的不透明度</p><h3 id="描边宽度-stroke-width"><a href="#描边宽度-stroke-width" class="headerlink" title="描边宽度 stroke-width"></a>描边宽度 stroke-width</h3><p>如果需要调整描边的宽度，可以使用 <code>stroke-width</code>，它接收一个数值</p><h3 id="虚线描边-stroke-dasharray"><a href="#虚线描边-stroke-dasharray" class="headerlink" title="虚线描边 stroke-dasharray"></a>虚线描边 stroke-dasharray</h3><p><code>stroke-dasharray</code> 接收一串数字，这串数字可以用来代表 <strong>线的长度和空隙的长度</strong>，数字之间用逗号或者空格分隔。</p><p>建议传入偶数个数字。但如果你传入了奇数个数字，<code>SVG</code> 会将这串数字重复一遍，使它的数量变成 <strong>偶数个</strong> 。</p><img src="/2022/09/29/svg/image-20221004150911891.png" class="" title="image-20221004150911891"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid red;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span></span><br><span class="hljs-tag">    <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;30&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;30&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;300&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;30&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;blue&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><br>  <span class="hljs-comment">&lt;!--  线长20 空隙长10  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span></span><br><span class="hljs-tag">    <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;30&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;70&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;300&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;70&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;blue&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">stroke-dasharray</span>=<span class="hljs-string">&quot;20 10&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><br>  <span class="hljs-comment">&lt;!--  线长20 空隙长10 线长30 空隙长20 线长10 空隙长30  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span></span><br><span class="hljs-tag">    <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;30&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;110&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;300&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;110&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;blue&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">stroke-dasharray</span>=<span class="hljs-string">&quot;20 10 30&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="虚线偏移量-stroke-dashoffset"><a href="#虚线偏移量-stroke-dashoffset" class="headerlink" title="虚线偏移量 stroke-dashoffset"></a>虚线偏移量 stroke-dashoffset</h3><p>虚线还可以通过 <code>stroke-dashoffset</code> 属性设置偏移量，它接收一个数值类型的值。</p><img src="/2022/09/29/svg/image-20221004151324300.png" class="" title="image-20221004151324300"><figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs svg">stroke-dashoffset=&quot;10&quot;<br></code></pre></td></tr></table></figure><h3 id="线帽-stroke-linecap"><a href="#线帽-stroke-linecap" class="headerlink" title="线帽 stroke-linecap"></a>线帽 stroke-linecap</h3><p>线帽就是线的起始点和结束点的位置，用 <code>stroke-linecap</code> 属性可以设置线帽样式。</p><p>线帽有3个值：</p><ul><li><code>butt</code>: 平头（默认值）</li><li><code>round</code>: 圆头</li><li><code>square</code>: 方头</li></ul><img src="/2022/09/29/svg/image-20221004151434115.png" class="" title="image-20221004151434115"><h3 id="拐角-stroke-linejoin"><a href="#拐角-stroke-linejoin" class="headerlink" title="拐角 stroke-linejoin"></a>拐角 stroke-linejoin</h3><p>拐角就是折线的交接点，可以使用 <code>stroke-linejoin</code> 设置，它接收以下属性：</p><ul><li><code>miter</code>: 尖角（默认）</li><li><code>round</code>: 圆角</li><li><code>bevel</code>: 平角</li></ul><img src="/2022/09/29/svg/image-20221004151525017.png" class="" title="image-20221004151525017"><h3 id="消除锯齿-shape-rendering"><a href="#消除锯齿-shape-rendering" class="headerlink" title="消除锯齿 shape-rendering"></a>消除锯齿 shape-rendering</h3><p>如果 <code>SVG</code> 在浏览器显示出来的图像有点模糊，那可能是开启了 <strong>反锯齿</strong> 功能，可以通过 <code>CSS</code> 属性关闭该功能。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">// 开启反锯齿<br>shape-rendering: geometricPrecision<br>// 关闭反锯齿<br>shape-rendering: crispEdges<br></code></pre></td></tr></table></figure><p>将该属性设置到对应的 <code>svg</code> 元素上，就会关闭反锯齿功能，突显看起来就会清晰很对，但在某些情况关闭了该功能会让图像看起来有点毛躁的感觉。</p><h2 id="文本元素"><a href="#文本元素" class="headerlink" title="文本元素"></a>文本元素</h2><p><code>SVG</code> 可以使用 <code>&lt;text&gt;</code> 标签渲染文本。</p><h3 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h3><p>和 <code>Canvas</code> 一样，<code>SVG</code> 的文本对齐方式是以第一个字基线的左下角为基准。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid red;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>雷猴啊<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p>所以如果不设置 text 的位置，那么 text 会跑到左上角，第一个字基线的左下角和 svg 顶部对齐。</p><img src="/2022/09/29/svg/image-20221004152141491.png" class="" title="image-20221004152141491"><p>假设字体为 16px 大小，可以设置 text 向下移16px，这样就能完整看到了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid red;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;16&quot;</span>&gt;</span>雷猴啊<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2022/09/29/svg/image-20221004152225332.png" class="" title="image-20221004152225332"><h3 id="设置字号-font-size"><a href="#设置字号-font-size" class="headerlink" title="设置字号 font-size"></a>设置字号 font-size</h3><h3 id="粗体-font-weight"><a href="#粗体-font-weight" class="headerlink" title="粗体 font-weight"></a>粗体 font-weight</h3><p>使用 <code>font-weight</code> 可以将文本设置成粗体。</p><ul><li><code>normal</code>: 默认（非粗体）</li><li><code>bold</code>: 粗体</li></ul><h3 id="装饰线-text-decoration"><a href="#装饰线-text-decoration" class="headerlink" title="装饰线 text-decoration"></a>装饰线 text-decoration</h3><p>和 <code>CSS</code> 一样，可以使用 <code>text-decoration</code> 设置装饰线</p><ul><li><code>none</code>：默认</li><li><code>underline</code>: 下划线</li><li><code>overline</code>: 上划线</li><li><code>line-through</code>: 删除线</li></ul><h3 id="水平对齐方式-text-anchor"><a href="#水平对齐方式-text-anchor" class="headerlink" title="水平对齐方式 text-anchor"></a>水平对齐方式 text-anchor</h3><p>可以通过 <code>text-anchor</code> 属性设置文本水平对齐方式。</p><p>如果文本是从左向右书写，那这几个参数的意思就是：</p><ul><li><code>start</code>: 左对齐</li><li><code>middle</code>: 居中对齐</li><li><code>end</code>: 右对齐</li></ul><p>text 会有坐标 x y，左对齐指文本最左侧和坐标重叠，右对齐指文本最右侧和坐标重叠。</p><img src="/2022/09/29/svg/image-20221004153240544.png" class="" title="image-20221004153240544"><p>从上到下依次是，左对齐、居中对齐、右对齐</p><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><p>多行文可以使用 <code>&lt;tspan&gt;</code> 标签辅助实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid red;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tspan</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">tspan</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tspan</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;60&quot;</span>&gt;</span>222<span class="hljs-tag">&lt;/<span class="hljs-name">tspan</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tspan</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;90&quot;</span>&gt;</span>333<span class="hljs-tag">&lt;/<span class="hljs-name">tspan</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tspan</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;120&quot;</span>&gt;</span>444<span class="hljs-tag">&lt;/<span class="hljs-name">tspan</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;tspan&gt;</code> 要放在 <code>&lt;text&gt;</code> 里，而且会继承 <code>&lt;text&gt;</code> 设置的样式。</p><h3 id="垂直对齐方式-dominant-baseline"><a href="#垂直对齐方式-dominant-baseline" class="headerlink" title="垂直对齐方式 dominant-baseline"></a>垂直对齐方式 dominant-baseline</h3><p>可以通过 <code>dominant-baseline</code> 属性设置文本垂直对齐方式</p><ul><li><code>auto</code>: 默认的对齐方式，保持与父元素相同的配置。</li><li><code>text-after-edge</code>: 在基线上方</li><li><code>middle</code>: 居中基线</li><li><code>text-before-edge</code>: 在基线下方</li></ul><img src="/2022/09/29/svg/image-20221004153539272.png" class="" title="image-20221004153539272"><h3 id="纵向文字-writing-mode"><a href="#纵向文字-writing-mode" class="headerlink" title="纵向文字 writing-mode"></a>纵向文字 writing-mode</h3><p>将 <code>writing-mode</code> 设置成 <code>tb</code> 就可以让文字纵向排列。</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid red;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;https://juejin.cn/post/7116784455561248775&quot;</span> <span class="hljs-attr">xlink:title</span>=<span class="hljs-string">&quot;canvas&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span>也学学Canvas吧<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p>超链接也是 a 标签</p><p>xlink:href链接 </p><p>xlink:title鼠标放到链接上的提示信息</p><p>target&#x3D;&quot;_blank&quot;需要在新窗口打开链接</p><p><a> 标签里除了可以包裹文本外，还可以包裹各种图形和图片等元素。</p><h2 id="图片-image"><a href="#图片-image" class="headerlink" title="图片 image"></a>图片 image</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid red;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;./img.jpg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h2><h3 id="分组-g"><a href="#分组-g" class="headerlink" title="分组 g"></a>分组 g</h3><p>它能把多个元素放在一组里，对<g>标记实施的样式和渲染会作用到这个分组内的所有元素上。组内的所有元素都会继承<g>标记上的所有属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;-10 -10 220 220&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;9&quot;</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;translate(100,100)&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M 0,-100 A 100,100 0 0,1 86.6,-50&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl1)&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M 86.6,-50 A 100,100 0 0,1 86.6,50&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl2)&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M 86.6,50 A 100,100 0 0,1 0,100&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl3)&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M 0,100 A 100,100 0 0,1 -86.6,50&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl4)&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M -86.6,50 A 100,100 0 0,1 -86.6,-50&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl5)&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M -86.6,-50 A 100,100 0 0,1 0,-100&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl6)&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="defs-定义可重用部分"><a href="#defs-定义可重用部分" class="headerlink" title="defs 定义可重用部分"></a>defs 定义可重用部分</h3><p>defs 用于嵌入可在 SVG 映像内重用的定义。</p><p>使用 defs 元素, 可以将 SVG 形状组合在一起, 并将其作为单个形状重复使用。（mixin?）</p><p>通过 use 元素引用 defs 元素中定义的形状时, 将显示该形状。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <br><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">defs</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;shape&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;40&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;40&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">defs</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#shape&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;40&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#shape&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;160&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;40&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h2><h3 id="viewBox-视区盒子"><a href="#viewBox-视区盒子" class="headerlink" title="viewBox 视区盒子"></a>viewBox 视区盒子</h3><figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs svg">viewBox=&quot;x, y, width, height&quot;  // x:左上角横坐标，y:左上角纵坐标，width:宽度，height:高度<br></code></pre></td></tr></table></figure><p>svg 的宽高也许很大，但设定了 viewBox，就只显示 viewBox 这一块区域。</p><p>下图为 不设置 viewBox 到设置 <code>viewBox=&quot;0,0,40,30&quot;</code></p><img src="/2022/09/29/svg/2014-08-27_105046-viewbox.gif" class="" title="gif演示区域面积扩大"><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>渐变色(gradient)是指从一种颜色平滑的过渡到另外一种颜色。而且，我们可以将多种渐变色应用到同一个网页元素上。</p><p>在SVG里，有两种主要的渐变色类型：</p><ul><li>线性渐变色 Linear</li><li>辐射式(放射式)渐变色 Radial</li></ul><h3 id="SVG线性渐变色-–-linearGradient"><a href="#SVG线性渐变色-–-linearGradient" class="headerlink" title="SVG线性渐变色 – linearGradient"></a>SVG线性渐变色 – linearGradient</h3><p>linearGradient 标记就是用来定义渐变色的。</p><p>linearGradient 标记必须放在 defs 标记内。defs 标记就是“definitions”单词的简写，用来容纳其它各种 SVG 标记。</p><p>线性渐变色可以定义成水平渐变色，垂直渐变色和斜向渐变色：</p><ul><li>当<code>y1</code>和<code>y2</code>相等，而<code>x1</code>和<code>x2</code>不等时，就形成了水平渐变色</li><li>当<code>y1</code>和<code>y2</code>不等，而<code>x1</code>和<code>x2</code>相等时，就形成了垂直渐变色</li><li>当<code>y1</code>和<code>y2</code>不等，而<code>x1</code>和<code>x2</code>也不等时，就形成了斜向渐变色</li></ul><img src="/2022/09/29/svg/image-20221004170313319.png" class="" title="image-20221004170313319"><p><strong>示例：</strong></p><figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs svg"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">defs</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">linearGradient</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;grad1&quot;</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;0%&quot;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;0%&quot;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;0%&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&quot;0%&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;stop-color:rgb(255,255,0);stop-opacity:1&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;stop-color:rgb(255,0,0);stop-opacity:1&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">linearGradient</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">defs</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;70&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;85&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;55&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;url(#grad1)&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>linearGradient 标记的<code>id</code>属性定义了这个渐变色的唯一标志</li><li>linearGradient 标记的<code>x1, x2, y1,y2</code>四个属性定义了渐变色的起始位置和终止位置</li><li>渐变色的颜色组成可以是2个或2个以上的颜色。每种颜色都使用一个 stop 标记定义。<code>offset</code>属性用来定义渐变色的开始和结束位置。</li><li><code>fill</code>属性定义了需要引用的渐变色的ID</li></ul><h2 id="在线-svg-绘制网站"><a href="#在线-svg-绘制网站" class="headerlink" title="在线 svg 绘制网站"></a>在线 svg 绘制网站</h2><p><a href="https://www.jq22.com/code2254">https://www.jq22.com/code2254</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7118985770408345630">https://juejin.cn/post/7118985770408345630</a> 本篇内容主要来源于这篇文章</p><p><a href="http://know.webhek.com/svg/svg-home.html">http://know.webhek.com/svg/svg-home.html</a></p><p><a href="https://www.srcmini.com/37390.html">https://www.srcmini.com/37390.html</a></p>]]></content>
    
    
    <categories>
      
      <category>可视化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>svg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mini Vue</title>
    <link href="/2022/09/28/Mini-Vue/"/>
    <url>/2022/09/28/Mini-Vue/</url>
    
    <content type="html"><![CDATA[<h2 id="vue-整体流程"><a href="#vue-整体流程" class="headerlink" title="vue 整体流程"></a>vue 整体流程</h2><img src="/2022/09/28/Mini-Vue/13429147-32832d6b08b108c4.jpg" class="" title="img"><h2 id="vue-的三个-core"><a href="#vue-的三个-core" class="headerlink" title="vue 的三个 core"></a>vue 的三个 core</h2><h3 id="Reactivity-Module"><a href="#Reactivity-Module" class="headerlink" title="Reactivity Module"></a>Reactivity Module</h3><p>创建 JS 响应对象，并观察其变化，当使用这些对象的代码运行时，他们会被跟踪，当响应式对象变化时，代码会运行。</p><h3 id="Compiler-Module"><a href="#Compiler-Module" class="headerlink" title="Compiler Module"></a>Compiler Module</h3><p>将 HTML 模板编译成渲染函数</p><h3 id="Render-Module"><a href="#Render-Module" class="headerlink" title="Render Module"></a>Render Module</h3><p>三个阶段</p><ol><li>Render Phase</li></ol><p>渲染阶段，调用 render 函数，返回一个虚拟DOM节点</p><ol start="2"><li>Mount Phase</li></ol><p>挂载阶段，使用 虚拟DOM节点并调用 DOM API 来创建网页</p><ol start="3"><li>Patch Phase</li></ol><p>补丁阶段，新旧虚拟节点对比，并更新网页变化部分</p><h3 id="总的流程"><a href="#总的流程" class="headerlink" title="总的流程"></a>总的流程</h3><p>我们拥有 html template 和 设定的响应式对象</p><ol><li><p>Compiler Module 会将 template 转换为一个 render 函数</p></li><li><p>Reactivity Module 初始化响应式对象</p></li><li><p>Renderer Module （渲染）会调用 render 函数（而 render 函数引用了响应式对象），观察响应式对象的变化，render 函数返回一个虚拟 DOM 节点</p></li><li><p>Renderer Module（挂载）调用 mount 函数，使用 虚拟 DOM 创建页面</p></li><li><p>如果响应式对象发生任何变化，render 会再次调用 render 函数，创建一个新的虚拟 DOM，新旧虚拟节点传入 Patch 函数，新旧虚拟节点对比，根据需要更新网页</p></li></ol><h2 id="compiler-和-render"><a href="#compiler-和-render" class="headerlink" title="compiler 和 render"></a>compiler 和 render</h2><h3 id="在-js-中使用-render"><a href="#在-js-中使用-render" class="headerlink" title="在 js 中使用 render"></a>在 js 中使用 render</h3><p>在 js 中使用 render 创建元素</p><p>h 函数会调用 vnode函数 从而创建 vnode 对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123;h&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;foo&#x27;</span></span><br><span class="language-javascript">            <span class="hljs-attr">onClick</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">onClick</span></span><br><span class="language-javascript">        &#125;, <span class="hljs-string">&#x27;hello&#x27;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="从-template-到-页面实例"><a href="#从-template-到-页面实例" class="headerlink" title="从 template 到 页面实例"></a>从 template 到 页面实例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>vue 在内部做的是：</p><ol><li>compiler 将 template 转为 render 函数，renderer 调用 render 函数，返回一个虚拟 DOM</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; h &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;, [<br>        <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;span&#x27;</span>, <span class="hljs-literal">null</span>, [<span class="hljs-string">&#x27;hello&#x27;</span>])<br>    ])<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>虚拟 DOM 转为真实 DOM 并挂载到容器(父组件)上</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue3">mount(vdom, document.getElementById(&#x27;app&#x27;))<br></code></pre></td></tr></table></figure><h2 id="写一个简单的-mount"><a href="#写一个简单的-mount" class="headerlink" title="写一个简单的 mount"></a>写一个简单的 mount</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mount</span>(<span class="hljs-params">vnode, container</span>) &#123;<br>    <span class="hljs-comment">// 根据 虚拟DOM 创建 真实DOM</span><br>    <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">tag</span>)<br>    <span class="hljs-comment">// props</span><br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">props</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> vnode.<span class="hljs-property">props</span>) &#123;<br>            <span class="hljs-keyword">const</span> value = vnode.<span class="hljs-property">props</span>[key]<br>            el.<span class="hljs-title function_">setAttribute</span>(key, value)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// children (假设要么是 字符串 要么是 vnode 的数组；实际在 vue 中是 字符串和 vnode 的混合数组)</span><br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">children</span>) &#123;<br>        vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>                el.<span class="hljs-property">textContent</span> = vnode.<span class="hljs-property">children</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>                    <span class="hljs-title function_">mount</span>(child, el)<br>                &#125;)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    container.<span class="hljs-title function_">appendChild</span>(el)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写一个简单的-patch"><a href="#写一个简单的-patch" class="headerlink" title="写一个简单的 patch"></a>写一个简单的 patch</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">n1, n2</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n1.<span class="hljs-property">tag</span> === n2.<span class="hljs-property">tag</span>) &#123;<br>        <span class="hljs-keyword">const</span> el = n2.<span class="hljs-property">el</span> = n1.<span class="hljs-property">el</span><br>        <span class="hljs-comment">// props</span><br>        <span class="hljs-keyword">const</span> oldProps = n1.<span class="hljs-property">props</span> || &#123;&#125;<br>        <span class="hljs-keyword">const</span> newProps = n2.<span class="hljs-property">props</span> || &#123;&#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> newProps) &#123;<br>            <span class="hljs-keyword">const</span> oldValue = oldProps[key]<br>            <span class="hljs-keyword">const</span> newValue = newProps[key]<br>            <span class="hljs-keyword">if</span> (newValue !== oldValue) &#123;<br>                el.<span class="hljs-title function_">setAttribute</span>(key, newValue)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> oldProps) &#123;<br>            <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> newProps)) &#123;<br>                el.<span class="hljs-title function_">removeAttribute</span>(key)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// children</span><br>        <span class="hljs-keyword">const</span> oldChildren = n1.<span class="hljs-property">children</span><br>        <span class="hljs-keyword">const</span> newChildren = n2.<span class="hljs-property">children</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChildren === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldChildren === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (newChildren !== oldChildren) &#123;<br>                    el.<span class="hljs-property">textcontent</span> = newChildren<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                el.<span class="hljs-property">textContent</span> = newChildren<br>                <span class="hljs-comment">// oldChildren 的孩子怎么办？ 不用删掉吗？</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldChildren === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>                el.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&#x27;</span><br>                newChildren.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>                    <span class="hljs-title function_">mount</span>(child, el)<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 这里写的是没有 key 的简单的 diff 算法; 带 key 的 diff 算法看源码</span><br>                <span class="hljs-keyword">const</span> commonLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(newChildren.<span class="hljs-property">length</span>, oldChildren.<span class="hljs-property">length</span>)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; commonLength; i++) &#123;<br>                    <span class="hljs-title function_">patch</span>(oldChildren[i], newChildren[i])<br>                &#125;<br>                <span class="hljs-keyword">if</span> (newChildren.<span class="hljs-property">length</span> &gt; oldChildren.<span class="hljs-property">length</span>) &#123;<br>                    newChildren.<span class="hljs-title function_">slice</span>(oldChildren.<span class="hljs-property">length</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>                        <span class="hljs-title function_">mount</span>(el, child)<br>                    &#125;)<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newChildren.<span class="hljs-property">length</span> &lt; oldChildren.<span class="hljs-property">length</span>) &#123;<br>                    oldChildren.<span class="hljs-title function_">slice</span>(newChildren.<span class="hljs-property">length</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>                        el.<span class="hljs-title function_">removeChild</span>(child)<br>                    &#125;)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写一个简单的-Dep"><a href="#写一个简单的-Dep" class="headerlink" title="写一个简单的 Dep"></a>写一个简单的 Dep</h2><p>有点像 ref 的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 记录当前将要被订阅的副作用函数</span><br><span class="hljs-keyword">let</span> activeEffect<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">depend</span>()<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span><br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newValue</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = newValue<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">notify</span>()<br>  &#125;<br>  <span class="hljs-comment">// 订阅</span><br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (activeEffect) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">add</span>(activeEffect)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 发布(触发副作用函数)</span><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">effect</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 监视副作用函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchEffect</span>(<span class="hljs-params">effect</span>) &#123;<br>  activeEffect = effect<br>  <span class="hljs-title function_">effect</span>()<br>  activeEffect = <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实例化 dep</span><br><span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><br><span class="hljs-comment">// 监听副作用函数并订阅</span><br><span class="hljs-comment">// 调用 watchEffect(effect)，activeEffect = effect，调用 effect，effect中的 dep.value 触发了 dep 的 get 事件，触发 depend 订阅，并返回 value，打印结果 ‘hello’</span><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dep.<span class="hljs-property">value</span>)<br>&#125;)<br><br><span class="hljs-comment">// 修改值，触发 dep 的 set 函数修改 value，并通知发布，触发所有订阅者的 effect 事件</span><br>dep.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;changed&#x27;</span><br><br><span class="hljs-comment">// hello changed</span><br></code></pre></td></tr></table></figure><p><strong>很多问题中的一个：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ok = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">const</span> msg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (ok.<span class="hljs-property">value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-property">value</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;false branch&#x27;</span>)<br>  &#125;<br>&#125;)<br><br>ok.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>msg.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;changed&#x27;</span><br><span class="hljs-comment">// false branch</span><br></code></pre></td></tr></table></figure><p>理论上是什么都不会打印，因为 ok 已经被修改为 false 了，副作用函数 console.log(msg.value) 不应该存在了，可以理解为下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;false branch&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>所以当修改 msg 时，不应该触发这个副作用函数，但实际还是触发了。</p><h2 id="写一个简单的-reactive"><a href="#写一个简单的-reactive" class="headerlink" title="写一个简单的 reactive"></a>写一个简单的 reactive</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> activeEffect<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  subscribers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (activeEffect) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">add</span>(activeEffect)<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">effect</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchEffect</span>(<span class="hljs-params">effect</span>) &#123;<br>  activeEffect = effect<br>  <span class="hljs-title function_">effect</span>()<br>  activeEffect = <span class="hljs-literal">null</span><br>&#125;<br><br><span class="hljs-comment">/* 有多个对象(target)，每个对象有多个 key，因此 depsMap 关联 key 和 dep，而 targetMap 关联 对象 和 depsMap */</span><br><span class="hljs-comment">// 简单的说: targetMap在很多对象里找对象，depsMap在一个对象的很多key里找key</span><br><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDep</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (!depsMap) &#123;<br>    depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    targetMap.<span class="hljs-title function_">set</span>(target, depsMap)<br>  &#125;<br>  <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!dep) &#123;<br>    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()<br>    depsMap.<span class="hljs-title function_">set</span>(key, dep)<br>  &#125;<br>  <span class="hljs-keyword">return</span> dep<br>&#125;<br><br><span class="hljs-comment">// proxy 的配置项</span><br><span class="hljs-keyword">const</span> reactiveHandlers = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDep</span>(target, key)<br>    dep.<span class="hljs-title function_">depend</span>()<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>    <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDep</span>(target, key)<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)<br>    dep.<span class="hljs-title function_">notify</span>()<br>    <span class="hljs-keyword">return</span> result<br>  &#125;,<br>  <span class="hljs-title function_">has</span>(<span class="hljs-params"></span>)&#123;<br>      <br>  &#125;,<br>  <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params"></span>) &#123;<br>      <br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 响应式化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">raw</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(raw, reactiveHandlers)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 将这个对象转为响应式, 调用 proxy 对这个对象做代理, 配置了 get 和 set 等 trap, 分别会调用 depend 和 notify</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>&#125;)<br><br><span class="hljs-comment">// 监听副作用函数并订阅</span><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>)<br>&#125;)<br><br><span class="hljs-comment">// 修改值</span><br>state.<span class="hljs-property">count</span> += <span class="hljs-number">1</span><br><span class="hljs-comment">// 0 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>grid布局</title>
    <link href="/2022/09/27/grid%E5%B8%83%E5%B1%80/"/>
    <url>/2022/09/27/grid%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Grid 布局将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。</p><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/20210126105810167.png" class="" title="img"><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="行数行宽-x2F-列数列宽"><a href="#行数行宽-x2F-列数列宽" class="headerlink" title="行数行宽&#x2F;列数列宽"></a>行数行宽&#x2F;列数列宽</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>grid-template-columns 定义每一列列宽</p><p>grid-template-rows 定义每一行行宽</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927170918911.png" class="" title="image-20220927170918911"><p>值可以是绝对单位&#x2F;百分比，也有一些额外的属性和方法来简化代码</p><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><h5 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h5><p>用于简化重复的值&#x2F;模式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-comment">/* 6列 */</span><br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100px</span> <span class="hljs-number">20px</span> <span class="hljs-number">80px</span>);<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="auto-fill"><a href="#auto-fill" class="headerlink" title="auto-fill"></a>auto-fill</h5><p>自动填充，每一行（或每一列）容纳尽可能多的单元格。</p><p>一般用于单元格大小固定，但容器大小不确定时。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-comment">/* 每列宽度 100px 自动填充 */</span><br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">100px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927171621426.png" class="" title="image-20220927171621426"><h5 id="fr"><a href="#fr" class="headerlink" title="fr"></a>fr</h5><p>fraction 的缩写，意为”片段”</p><p>不给具体数值，但给定比例。可以和绝对单位混用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">150px</span> <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927171812596.png" class="" title="image-20220927171812596"><h5 id="minmax"><a href="#minmax" class="headerlink" title="minmax()"></a>minmax()</h5><p>minmax() 函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">1</span>fr);<br></code></pre></td></tr></table></figure></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>两栏式布局非常简单</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">70%</span> <span class="hljs-number">30%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="间距-gap"><a href="#间距-gap" class="headerlink" title="间距 gap"></a>间距 gap</h3><p><strong>row-gap 属性设置行间距</strong></p><p><strong>column-gap 属性设置列间距</strong></p><p><strong>gap 是两者的简写形式，</strong>如果 gap 省略了第二个值，浏览器认为第二个值等于第一个值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span> <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927173417160.png" class="" title="image-20220927173417160"><h3 id="区域-area"><a href="#区域-area" class="headerlink" title="区域 area"></a>区域 area</h3><p><strong>grid-template-areas 属性用于定义区域</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&quot;header header header&quot;</span><br>                     <span class="hljs-string">&quot;main main sidebar&quot;</span><br>                     <span class="hljs-string">&quot;footer footer footer&quot;</span>;<br></code></pre></td></tr></table></figure><p>顶部是页眉区域 header，底部是页脚区域 footer，中间部分则为 main 和 sidebar。</p><p>如果某些区域不需要利用，则使用 . 表示</p><p>区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><h3 id="控制单元格排列方式"><a href="#控制单元格排列方式" class="headerlink" title="控制单元格排列方式"></a>控制单元格排列方式</h3><p><strong>grid-auto-flow 控制子元素排列方式，默认为 row</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">grid-auto-flow</span>: column;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927174250065.png" class="" title="image-20220927174250065"><p><strong>dense 关键字用于让元素排列更加紧密</strong></p><p>不加 dense</p><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927174425864.png" class="" title="image-20220927174425864"><p>加 dense</p><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927174512952.png" class="" title="image-20220927174512952"><h3 id="控制内容在单元格中的位置"><a href="#控制内容在单元格中的位置" class="headerlink" title="控制内容在单元格中的位置"></a>控制内容在单元格中的位置</h3><p><strong>justify-items 属性设置单元格内容的水平位置（左中右）</strong></p><p><strong>align-items 属性设置单元格内容的垂直位置（上中下）</strong></p><p><strong>place-items 属性是 align-items 属性和 justify-items 属性的合并简写形式</strong>，如果省略第二个值，则浏览器认为与第一个值相等。</p><p>可选值：</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  justify-items: start;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927175053534.png" class="" title="image-20220927175053534"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">align-items</span>: start;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927175150874.png" class="" title="image-20220927175150874"><h3 id="控制整个内容区在容器中的位置"><a href="#控制整个内容区在容器中的位置" class="headerlink" title="控制整个内容区在容器中的位置"></a>控制整个内容区在容器中的位置</h3><p><strong>justify-content 属性是整个内容区域在容器里面的水平位置（左中右）</strong></p><p><strong>align-content 属性是整个内容区域的垂直位置（上中下）</strong></p><p><strong>place-content 属性是 align-content 属性和 justify-content 属性的合并简写形式。</strong>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p><p>可选值：</p><ul><li><p>start - 对齐容器的起始边框</p></li><li><p>end - 对齐容器的结束边框</p></li><li><p>center - 容器内部居中</p></li><li><p>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</p></li><li><p>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</p></li><li><p>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</p></li><li><p>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">justify-content</span>: space-around;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927175720883.png" class="" title="image-20220927175720883"><h3 id="控制网格外部项目的宽高"><a href="#控制网格外部项目的宽高" class="headerlink" title="控制网格外部项目的宽高"></a>控制网格外部项目的宽高</h3><p>grid-auto-columns 属性和 grid-auto-rows 属性用来设置，浏览器自动创建的多余网格的列宽和行高。</p><p>如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。 */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927223440294.png" class="" title="image-20220927223440294"><h3 id="合并属性-grid-template"><a href="#合并属性-grid-template" class="headerlink" title="合并属性 grid-template"></a>合并属性 grid-template</h3><p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p><p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="指定项目位置"><a href="#指定项目位置" class="headerlink" title="指定项目位置"></a>指定项目位置</h3><ul><li>grid-column-start 属性：左边框所在的垂直网格线</li><li>grid-column-end 属性：右边框所在的垂直网格线</li><li>grid-row-start 属性：上边框所在的水平网格线</li><li>grid-row-end 属性：下边框所在的水平网格线</li></ul><p>值可以是 数字 左右边框的名字 span关键字(表示左右边框&#x2F;上下边框跨越了多少个网格)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927223748443.png" class="" title="image-20220927223748443"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-start</span>: header-start;<br>  <span class="hljs-attribute">grid-column-end</span>: header-end;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-start</span>: span <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式</p><p><code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 中间有个 / */</span><br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: &lt;start-line&gt; / &lt;end-line&gt;;<br>  <span class="hljs-attribute">grid-row</span>: &lt;start-line&gt; / &lt;end-line&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="指定项目放在哪个区域"><a href="#指定项目放在哪个区域" class="headerlink" title="指定项目放在哪个区域"></a>指定项目放在哪个区域</h3><p>grid-area 可以直接指定区域，也可以用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: e;<br>&#125;<br><br><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">1</span> / <span class="hljs-number">1</span> / <span class="hljs-number">3</span> / <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置单个项目的在单元格中的位置"><a href="#设置单个项目的在单元格中的位置" class="headerlink" title="设置单个项目的在单元格中的位置"></a>设置单个项目的在单元格中的位置</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><p>可选值：</p><blockquote><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span>  &#123;<br>  justify-self: start;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/27/grid%E5%B8%83%E5%B1%80/image-20220927224801964.png" class="" title="image-20220927224801964"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></p><p><a href="https://www.cnblogs.com/starof/p/15627296.html">https://www.cnblogs.com/starof/p/15627296.html</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm run xxx</title>
    <link href="/2022/09/24/npm-run-xxx/"/>
    <url>/2022/09/24/npm-run-xxx/</url>
    
    <content type="html"><![CDATA[<h2 id="npm-run-xxx后发生了什么"><a href="#npm-run-xxx后发生了什么" class="headerlink" title="npm run xxx后发生了什么"></a>npm run xxx后发生了什么</h2><p><strong>去 package.json 的 scripts 里找对应的 xxx，然后执行 xxx</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;private&quot;</span>: ,<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;vite&quot;</span>,<br>    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;vue-tsc --noEmit &amp;&amp; vite build&quot;</span>,<br>    <span class="hljs-string">&quot;preview&quot;</span>: <span class="hljs-string">&quot;vite preview&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>  &#125;,<br>  <span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以 npm run dev 时，实际会执行 vite</p><p><strong>为什么不直接执行 vite，而要执行 npm run dev？</strong></p><p>因为 vite 指令不存在操作系统里</p><p><strong>为什么执行 npm run dev 就能成功？</strong></p><p>因为npm 会去找同名可执行文件</p><p>我们在 npm i vite 安装依赖时，就会在 node_modules&#x2F;.bin&#x2F; 目录中创建 好 vite 为名的几个可执行文件，这些文件都是软链接。</p><img src="/2022/09/24/npm-run-xxx/image-20220924104924956.png" class="" title="image-20220924104924956"><p>vite - shell脚本</p><p>vite.cmd - cmd脚本</p><p>vite.ps1 - shell 脚本</p><p>以 vite.cmd 为例</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cmd">@<span class="hljs-built_in">ECHO</span> off<br><span class="hljs-keyword">GOTO</span> <span class="hljs-built_in">start</span><br>:find_dp0<br><span class="hljs-built_in">SET</span> dp0=%~dp0<br><span class="hljs-keyword">EXIT</span> /b<br>:<span class="hljs-built_in">start</span><br><span class="hljs-built_in">SETLOCAL</span><br><span class="hljs-keyword">CALL</span> :find_dp0<br><br><span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXIST</span> &quot;<span class="hljs-variable">%dp0%</span>\node.exe&quot; (<br>  <span class="hljs-built_in">SET</span> &quot;_prog=<span class="hljs-variable">%dp0%</span>\node.exe&quot;<br>) <span class="hljs-keyword">ELSE</span> (<br>  <span class="hljs-built_in">SET</span> &quot;_prog=node&quot;<br>  <span class="hljs-built_in">SET</span> PATHEXT=<span class="hljs-variable">%PATHEXT:;.JS;=;%</span><br>)<br><br><span class="hljs-built_in">endLocal</span> &amp; <span class="hljs-keyword">goto</span> #_undefined_# <span class="hljs-number">2</span>&gt;<span class="hljs-built_in">NUL</span> || <span class="hljs-built_in">title</span> <span class="hljs-variable">%COMSPEC%</span> &amp; &quot;<span class="hljs-variable">%_prog%</span>&quot;  &quot;<span class="hljs-variable">%dp0%</span>\..\vite\bin\vite.js&quot; %*<br></code></pre></td></tr></table></figure><p>主要就是在判断环境、拼接路径，然后指向运行 路径下的 &#x2F;vite&#x2F;bin&#x2F;vite.js 脚本</p><p>实际脚本位置就在 node_modules&#x2F;vite&#x2F;bin&#x2F;vite.js</p><img src="/2022/09/24/npm-run-xxx/image-20220924112057516.png" class="" title="image-20220924112057516"><p>之后会用 node 去执行这个 js 脚本</p><p><strong>软连接是在哪形成的？</strong></p><p>包中源代码的 package.json 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// node_modules/vite/package.json</span><br>&#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;3.1.0&quot;</span>,<br><span class="hljs-string">&quot;bin&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;vite&quot;</span>: <span class="hljs-string">&quot;bin/vite.js&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 npm install 时，npm 读到该配置(bin)后，就将 bin&#x2F;vite.js 文件软链接到 .&#x2F;node_modules&#x2F;.bin 目录下</p><p>而 npm 还会自动把 node_modules&#x2F;.bin 加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.npm run xxx 时，会到 package.json 的 scripts 里找映射，执行对应的指令</p><p>2.指令实际是无法执行的，但 npm 会从全局的 node_modules&#x2F;.bin 中查找指令同名的可执行文件，他们都是软链接。</p><p>3.软链接是写在 包的源代码的 package.json 中的，在 npm install 时会配置好，一般软链接的指向我们可以在 node_modules 下找到包，bin 里面有一个 js 文件，最后将在 node 中执行这个 js 文件。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DocumentFragment</title>
    <link href="/2022/09/23/DocumentFragment/"/>
    <url>/2022/09/23/DocumentFragment/</url>
    
    <content type="html"><![CDATA[<h1 id="文档碎片"><a href="#文档碎片" class="headerlink" title="文档碎片"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">文档碎片</a></h1><h2 id="什么是文档碎片"><a href="#什么是文档碎片" class="headerlink" title="什么是文档碎片"></a>什么是文档碎片</h2><p>它被作为一个轻量版的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document"><code>Document</code></a> 使用，就像标准的 document 一样，存储由节点（nodes）组成的文档结构。与 document 相比，最大的区别是<strong>它不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染（重绘重排），且不会对性能产生影响。</strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>最常用的方法是使用 <code>DocumentFragment</code> 创建并组成一个 DOM 子树，然后使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node"><code>Node</code></a> 接口方法（如：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild"><code>appendChild()</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore"><code>insertBefore()</code></a>）将其插入到 DOM 中。这种情况下<strong>会插入片段的所有子节点，并留下一个空的 DocumentFragment</strong>。因为<strong>所有的节点会被一次插入到文档中，所以仅会发生一个重渲染的操作，而不是每个节点分别被插入到文档中从而发生多次重渲染的操作</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#list&#x27;</span>)<br><span class="hljs-keyword">const</span> fruits = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Orange&#x27;</span>, <span class="hljs-string">&#x27;Banana&#x27;</span>, <span class="hljs-string">&#x27;Melon&#x27;</span>]<br><br><span class="hljs-keyword">const</span> fragment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DocumentFragment</span>()<br><br>fruits.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fruit</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>)<br>  li.<span class="hljs-property">textContent</span> = fruit<br>  fragment.<span class="hljs-title function_">appendChild</span>(li)<br>&#125;)<br><br>list.<span class="hljs-title function_">appendChild</span>(fragment)<br></code></pre></td></tr></table></figure><img src="/2022/09/23/DocumentFragment/image-20220923172037861.png" class="" title="image-20220923172037861"><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>文档片段节点的三个node属性——nodeType、nodeName、nodeValue分别是11、’#document-fragment’和null，文档片段节点没有父节点parentNode</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> frag = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(frag.<span class="hljs-property">nodeType</span>);<span class="hljs-comment">//11</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(frag.<span class="hljs-property">nodeValue</span>);<span class="hljs-comment">//null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(frag.<span class="hljs-property">nodeName</span>);<span class="hljs-comment">//&#x27;#document-fragment&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(frag.<span class="hljs-property">parentNode</span>);<span class="hljs-comment">//null</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>服务端渲染 客户端渲染 预渲染</title>
    <link href="/2022/09/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%20%E9%A2%84%E6%B8%B2%E6%9F%93/"/>
    <url>/2022/09/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%20%E9%A2%84%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="三种渲染方式"><a href="#三种渲染方式" class="headerlink" title="三种渲染方式"></a>三种渲染方式</h1><p><strong>客户端渲染</strong>：用户访问 url，请求 html 文件，前端根据路由动态渲染页面内容。关键链路较长，有一定的白屏时间；</p><p><strong>服务端渲染</strong>：用户访问 url，服务端根据访问路径请求所需数据，拼接成 html 字符串，返回给前端。前端接收到 html 时已有部分内容；</p><p><strong>预渲染</strong>：<strong>构建阶段</strong>生成匹配预渲染路径的 html 文件（注意：<strong>每个需要预渲染的路由都有一个对应的 html</strong>）。构建出来的 html 文件已有部分内容。</p><h1 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h1><h2 id="什么是客户端渲染"><a href="#什么是客户端渲染" class="headerlink" title="什么是客户端渲染"></a>什么是客户端渲染</h2><ol><li><p>http发起请求</p></li><li><p>服务端接受请求，响应一个页面<code>index.html</code>给客户端，也可以说是一个页面字符串。</p></li><li><p>客户端拿到页面，然后进行解析渲染，解析到静态页面会渲染显示在浏览器上，解析到script动态脚本<code>&lt;script src=&#39;user.js&#39;&gt;&lt;/script&gt;</code>，则浏览器会再次向浏览器发起请求</p></li><li><p>服务端再次处理服务端的请求，然后响应数据</p></li><li><p>客户端拿到服务器返回的数据，然后利用模板引擎进行渲染，最终将数据也显示在页面上</p></li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>与服务端渲染相反</p><h1 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h1><h2 id="什么是服务端渲染"><a href="#什么是服务端渲染" class="headerlink" title="什么是服务端渲染"></a>什么是服务端渲染</h2><p>服务器端的渲染，指的是客户端只需要发起一次http请求，服务器就会一次性将渲染好的页面进行返回，客户端不需要再次发起请求去服务器端拿数据。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><strong>首屏时间短</strong></li></ul><p>服务端在内网进行请求数据，响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大。</p><p>服务器性能好，渲染更快。</p><ul><li><strong>利于 SEO</strong></li></ul><p>因为后端会返回完整的 html 页面</p><ul><li><strong>占用客户端资源少</strong></li></ul><p>移动端省电</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>不利于前后端分离</li></ul><p>后端在生成前端的页面</p><ul><li>占用服务器端资源</li></ul><p>如果请求较多，会对服务器造成一定的访问压力</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>vue框架的项目，使用nuxt就很方便了，我们<strong>只需要按照nuxt的脚手架创建好项目结构</strong>，然后就可以按照vue的开发方式进行开发了。<br>nuxt支持SSR服务端渲染模式和SSG静态生成模式，如果说我们的页面需要提前动态获取数据并进行拼接，我们就需要使用服务端渲染模式；如果说我们的页面静态的东西比较多，动态数据不需要考虑SEO，那么我们可以选择静态生成模式，相当于使用预渲染，不需要node服务器也能够提升SEO。</p><h1 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h1><h2 id="什么是预渲染"><a href="#什么是预渲染" class="headerlink" title="什么是预渲染"></a>什么是预渲染</h2><p><strong>SSG</strong>（static side generate），无需服务器实时动态编译，<strong>在构建时针对特定路由简单的生成静态HTML文件</strong>。</p><h3 id="预渲染的作用"><a href="#预渲染的作用" class="headerlink" title="预渲染的作用"></a>预渲染的作用</h3><p>针对单页应用，服务端渲染和预渲染共同解决的问题：</p><ol><li><strong>SEO</strong>：单页应用的网站内容是根据当前路径动态渲染的，html 文件中往往没有内容，网络爬虫不会等到页面脚本执行完再抓取；</li><li><strong>弱网环境</strong>：当用户在一个弱环境中访问你的站点时，你会想要尽可能快的将内容呈现给他们。甚至是在 js 脚本被加载和解析前；</li><li><strong>低版本浏览器</strong>：用户的浏览器可能不支持你使用的 js 特性，预渲染或服务端渲染能够让用户至少能够看到首屏的内容，而不是一个空白的网页。</li></ol><p>预渲染能与服务端渲染一样提高 SEO 优化，但前者比后者需要更少的配置，实现成本低。弱网环境下，预渲染能更快地呈现页面内容，减少页面可见时间。</p><h3 id="不适合的场景"><a href="#不适合的场景" class="headerlink" title="不适合的场景"></a>不适合的场景</h3><p><strong>1.个性化内容</strong>：对于路由是 &#x2F;my-profile 的页面来说，预渲染就失效了。因为页面内容依据看它的人而显得不同；</p><p><strong>2.经常变化的内容</strong>：如果你预渲染一个游戏排行榜，这个排行榜会随着新的玩家记录而更新，预渲染会让你的页面显示不正确直到脚本加载完成并替换成新的数据。这是一个不好的用户体验；</p><p><strong>3.成千上万的路由</strong>：不建议预渲染非常多的路由，因为这会严重拖慢你的构建进程。</p><h2 id="使用预渲染"><a href="#使用预渲染" class="headerlink" title="使用预渲染"></a>使用预渲染</h2><h3 id="prerender-spa-plugin"><a href="#prerender-spa-plugin" class="headerlink" title="prerender-spa-plugin"></a>prerender-spa-plugin</h3><p><a href="https://link.juejin.cn/?target=https://github.com/chrisvfritz/prerender-spa-plugin"><strong>prerender-spa-plugin</strong></a> 是一个 webpack 插件用于在单页应用中预渲染静态 html 内容。它是框架无关的。</p><p>预渲染的单页应用<strong>路由需要使用 History 模式</strong>而不是 Hash 模式。原因很简单，Hash 不会带到服务器，路由信息会丢失。</p><h3 id="配置预渲染前"><a href="#配置预渲染前" class="headerlink" title="配置预渲染前"></a>配置预渲染前</h3><p>没有配置预渲染的话，一般来说，根据 nginx 的配置，无论访问哪个路由都会返回首页 dist&#x2F;index.html。具体情况视配置而见</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">location / &#123;<br>  try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span><span class="hljs-regexp">/ /i</span>ndex.html;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置预渲染"><a href="#配置预渲染" class="headerlink" title="配置预渲染"></a>配置预渲染</h3><p>安装包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> prerender-spa-plugin<br></code></pre></td></tr></table></figure><p>配置 webpack</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">PrerenderSpaPlugin</span> = <span class="hljs-title function_">require</span>(<span class="hljs-params"><span class="hljs-string">&#x27;prerender-spa-plugin&#x27;</span></span>)<br><br>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrerenderSpaPlugin</span>(<br>      <span class="hljs-comment">// 输出目录的绝对路径</span><br>      path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;../dist&#x27;</span>),<br>      <span class="hljs-comment">// 预渲染的路由</span><br>      [ <span class="hljs-string">&#x27;/new&#x27;</span>, <span class="hljs-string">&#x27;/hot&#x27;</span> ]<br>    )<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="预渲染效果"><a href="#预渲染效果" class="headerlink" title="预渲染效果"></a>预渲染效果</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs axapta">dist<br>│  <span class="hljs-keyword">index</span>.html<br>│  <br>├─hot<br>│      <span class="hljs-keyword">index</span>.html<br>│      <br>├─<span class="hljs-keyword">new</span><br>│      <span class="hljs-keyword">index</span>.html<br>│      <br>└─<span class="hljs-keyword">static</span><br></code></pre></td></tr></table></figure><p>对比 dist 目录，可以发现预渲染的目录多了两个文件 <code>new/index.html</code>, <code>hot/index.html</code></p><p>其中，**&#x2F;new** 和 <strong>&#x2F;hot</strong> 路由返回的 html 包含了对应路由的内容，从而实现预渲染。进入这两个路由时，直接发请求获取预渲染的 html。</p><p>没有配置预渲染的路由跟原来一样，还是访问 &#x2F;index.html，请求脚本，动态渲染。</p><p>预渲染达到了类似服务端渲染的效果。区别在于预渲染发生在<strong>构建时</strong>，服务端渲染发生在服务器<strong>处理请求时</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单的说就是在 build 时会在 dist 文件夹里多生成几个 html 文件，数量根据需要预渲染的路由个数而变（webpack中配置）。进入路由时，会直接返回对应的已经预渲染好的 html，而不用再在客户端动态渲染或是服务端渲染 。</p><p>实际上是一种空间换时间的方法，会增大打包后的体积，提升预渲染路由页面的渲染时间。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903503362523143">https://juejin.cn/post/6844903503362523143</a></p>]]></content>
    
    
    <categories>
      
      <category>优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pokemon项目</title>
    <link href="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要做这个项目"><a href="#为什么要做这个项目" class="headerlink" title="为什么要做这个项目"></a>为什么要做这个项目</h1><p>1.练习 vue3+ts，学习一些 css 技巧（布局&#x2F;动画效果）</p><p>2.网页版的宝可梦图鉴很少，大都是app。并且宝可梦图鉴大都很丑，让人没有使用的欲望。</p><p>3.其实更想做篮球和足球的数据图鉴，但是没找到免费的开源接口</p><h1 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h1><p>getPokemonApi(id: number)</p><p>base_experience：击败这只宝可梦获得的经验</p><p>abilities: 能力&#x2F;被动 为神奇宝贝在战斗或主世界中提供被动效果。神奇宝贝有多种可能的能力，但一次只能有一种能力</p><p>forms：种族？暂时没啥用</p><p>game_indices:  游戏不同代</p><p>height: 身高 dm</p><p>held_items：当遭遇到这只宝可梦时，它可能携带的物品</p><p>location_area_encounters：可能遭遇的地点</p><p>moves：技能</p><p>name：名字</p><p>order：仅用于排序</p><p>past_types：该宝可梦在前几代拥有的类型的详细信息</p><p>species：一些图片</p><p>status：统计数据(hp attack)。每个神奇宝贝的每个属性都有一个值，随着他们的等级增加而增长，并且可以通过战斗中的效果暂时改变。effort（EV）努力点</p><p>types：类别（注意类别克制）<a href="https://pokeapi.co/api/v2/type/%7Bid">https://pokeapi.co/api/v2/type/{id</a> or name}&#x2F;</p><p>weight：体重</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="保证请求的顺序"><a href="#保证请求的顺序" class="headerlink" title="保证请求的顺序"></a>保证请求的顺序</h2><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220906222915890.png" class="" title="image-20220906222915890"><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h3><p>没有获取所有宝可梦数据的请求，一次只能获取一个宝可梦的数据。而我们需要保证获取的顺序。</p><p>也就是说，有很多个请求需要依次发送，待上一个请求完成之后再发送下一个请求，发生异常时也要能够继续后面的请求。</p><p><strong>如果直接循环发请求，会乱序。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getPokemon</span> = (<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<br>    <span class="hljs-title function_">getPokemonApi</span>(id).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123; data &#125; = res<br>        pokemons.<span class="hljs-title function_">push</span>(data)<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">21</span>; i++) &#123;<br>        <span class="hljs-title function_">getPokemon</span>(i)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220906223103579.png" class="" title="image-20220906223103579"><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><a href="http://t.zoukankan.com/jyughynj-p-14429662.html">解决方案</a></h3><p><strong>1.使用生成器</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 生成器 用来保证请求的顺序</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">21</span>; i++) &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-title function_">getPokemonApi</span>(i)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理请求结果并发送下一次请求</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">res: <span class="hljs-built_in">any</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">done</span>) &#123;<br>        res.<span class="hljs-property">value</span><br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)<br>            pokemons.<span class="hljs-title function_">push</span>(response.<span class="hljs-property">data</span>)<br>            <span class="hljs-title function_">run</span>(gen.<span class="hljs-title function_">next</span>())<br>        &#125;)<br>            .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123; <span class="hljs-comment">// 处理一下异常</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(err)<br>            <span class="hljs-title function_">run</span>(gen.<span class="hljs-title function_">next</span>())<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 开始执行</span><br><span class="hljs-keyword">let</span> gen = <span class="hljs-title function_">generator</span>()<br><span class="hljs-title function_">run</span>(gen.<span class="hljs-title function_">next</span>())<br></code></pre></td></tr></table></figure><p>一个请求完成之后再发送下一个请求，关键在于发送一个之后先停下来等待该请求完成，处理之后再继续下一个请求。生成器generator里面的yield语句可以分割代码，程序遇到yield会停住，通过next语句可以一次执行一个yield分割的语句，本文尝试使用生成器完成依次发送多个请求的功能。</p><p><strong>2.await</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPokemon</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">101</span>; i++) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">getPokemonApi</span>(i)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>            pokemons.<span class="hljs-title function_">push</span>(response.<span class="hljs-property">data</span>)<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">getPokemon</span>()<br></code></pre></td></tr></table></figure><p>await会强制其他代码等待，直到后面的promise执行完毕</p><h2 id="背景色渐变"><a href="#背景色渐变" class="headerlink" title="背景色渐变"></a>背景色渐变</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.body</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to top, <span class="hljs-number">#f3e7e9</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#e3eeff</span> <span class="hljs-number">99%</span>, <span class="hljs-number">#e3eeff</span> <span class="hljs-number">100%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。</p><h2 id="card-模糊效果"><a href="#card-模糊效果" class="headerlink" title="card 模糊效果"></a>card 模糊效果</h2><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220916140510192.png" class="" title="image-20220916140510192"><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">h4</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">10px</span> <span class="hljs-number">5px</span> <span class="hljs-number">10px</span>;<br>    <span class="hljs-comment">// 阴影</span><br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0.3px</span> <span class="hljs-number">0.7px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.126</span>),<br>        <span class="hljs-number">0</span> <span class="hljs-number">0.9px</span> <span class="hljs-number">1.7px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.179</span>), <span class="hljs-number">0</span> <span class="hljs-number">1.8px</span> <span class="hljs-number">3.5px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.224</span>),<br>        <span class="hljs-number">0</span> <span class="hljs-number">3.7px</span> <span class="hljs-number">7.3px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.277</span>), <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">20px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>);<br>    <span class="hljs-comment">// 模糊</span><br>    backdrop-<span class="hljs-attribute">filter</span>: blur(<span class="hljs-number">20px</span>);<br>    <span class="hljs-attribute">transition</span>: <span class="hljs-number">0.5s</span> ease;<br><br>    <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0.7px</span> <span class="hljs-number">1px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.157</span>),<br>            <span class="hljs-number">0</span> <span class="hljs-number">1.7px</span> <span class="hljs-number">2.6px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.224</span>), <span class="hljs-number">0</span> <span class="hljs-number">3.5px</span> <span class="hljs-number">5.3px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.28</span>),<br>            <span class="hljs-number">0</span> <span class="hljs-number">7.3px</span> <span class="hljs-number">11px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.346</span>), <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">30px</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>backdrop-filter 和 filter 的区别：</p><p>backdrop-filter 只使背景模糊，不影响内容</p><p>filter 会使整部分都模糊</p><h2 id="shadow-扩散效果"><a href="#shadow-扩散效果" class="headerlink" title="shadow 扩散效果"></a>shadow 扩散效果</h2><p>hover&#x2F;focus 时，触发动画，边框从0向外扩散（红色），到0.7vw为止（透明）。</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20221111205310301.png" class="" title="image-20221111205310301"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&amp;<span class="hljs-selector-pseudo">:hover</span>, &amp;<span class="hljs-selector-pseudo">:focus</span> &#123;<br>    <span class="hljs-attribute">animation</span>: pulse <span class="hljs-number">1s</span>;<br>    // x 偏移量 | y 偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0.7vw</span> transparent;<br>&#125;<br><br><span class="hljs-keyword">@keyframes</span> pulse &#123;<br>    <span class="hljs-number">0%</span> &#123;<br>        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-built_in">var</span>(--color);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="head-动画效果"><a href="#head-动画效果" class="headerlink" title="head 动画效果"></a>head 动画效果</h2><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220916204520003.png" class="" title="image-20220916204520003"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/back.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Pokemon<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: Biko;<br>    <span class="hljs-attribute">src</span>: url(<span class="hljs-string">&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/4273/biko-black.woff&quot;</span>);<br>&#125;<br><span class="hljs-selector-class">.head</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-comment">// app.vue 中给 Head 组件设了高度, 因此这里才能 100%</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">align-items</span>: center;<br>    <span class="hljs-comment">// gif 可能过大, 所以溢出隐藏掉 </span><br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-selector-tag">img</span>,<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>        <span class="hljs-attribute">position</span>: absolute;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-selector-tag">img</span> &#123;<br>        <span class="hljs-comment">// object-fit 属性指定元素的内容应该如何去适应指定容器的高度与宽度。</span><br>        <span class="hljs-comment">// cover: 保持原有尺寸比例。但部分内容可能被剪切。</span><br>        <span class="hljs-attribute">object-fit</span>: cover;<br>    &#125;<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10vw</span>;<br>        <span class="hljs-attribute">font-family</span>: Biko, sans-serif;<br>        <span class="hljs-attribute">font-weight</span>: bold;<br>        <span class="hljs-attribute">text-transform</span>: uppercase;<br>        <span class="hljs-attribute">text-align</span>: center;<br>        <span class="hljs-attribute">background</span>: white;<br>        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.7</span>;<br>        <span class="hljs-comment">// 滤色模式</span><br>        <span class="hljs-attribute">mix-blend-mode</span>: screen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心是 mix-blend-mode: screen  滤色模式</strong></p><p><strong>当使用滤色模式,图层中纯黑部分变成完全透明,纯白部分则完全不透明,其他颜色则根据灰度产生各种级别的不透明</strong></p><p>如果不加 opacity 和 mix-blend-mode，则如下所示</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220916210837353.png" class="" title="image-20220916210837353"><p>加上 mix-blend-mode后，白色遮挡，黑色穿透</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220916210928338.png" class="" title="image-20220916210928338"><p>再加上 opacity:0.7</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220916211113363.png" class="" title="image-20220916211113363"><h2 id="card-显示形式"><a href="#card-显示形式" class="headerlink" title="card 显示形式"></a>card 显示形式</h2><p>两种形式</p><ol><li><p>不改变 url，点击 more details 弹出 card，点击其它位置关闭</p></li><li><p>&#x3D;&#x3D;路由&#x3D;&#x3D;，点击 more details 直接跳转路由</p></li></ol><p>最后选择路由，因为想将组件拆小，并且逻辑更清晰些</p><p><a href="https://lol.qq.com/tft/#/champion">云顶官网</a>也是这样做的</p><p>点卡片跳转路由 哈希模式，路由传参 params (传id)，显示在路径上</p><h2 id="多图绕中心旋转"><a href="#多图绕中心旋转" class="headerlink" title="多图绕中心旋转"></a>多图绕中心旋转</h2><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220925194954595.png" class="" title="image-20220925194954595"><p>灵感来源：<a href="https://codepen.io/sparshgupta007/pen/gOeypaj">https://codepen.io/sparshgupta007/pen/gOeypaj</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info-imgs&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info-imgs-box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, , index) in pokemonImgs&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;`--i:$&#123;index&#125;`&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;typeof value === &#x27;string&#x27; &amp;&amp; value&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-keyword">@keyframes</span> rotate&#123;<br>    <span class="hljs-selector-tag">from</span>&#123;<br>        <span class="hljs-comment">// perspective 设定物体到屏幕的距离</span><br>        <span class="hljs-attribute">transform</span>:perspective(<span class="hljs-number">1200px</span>) rotateY(<span class="hljs-number">0deg</span>);<br>    &#125;<br>    <span class="hljs-selector-tag">to</span>&#123;<br>        <span class="hljs-attribute">transform</span>:perspective(<span class="hljs-number">1200px</span>) rotateY(<span class="hljs-number">360deg</span>);<br>    &#125;<br>&#125;<br><span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">-imgs</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">align-items</span>: center;<br>    <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">-box</span> &#123;<br>        <span class="hljs-attribute">position</span>: relative;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">10vw</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br>        <span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d;<br>        <span class="hljs-attribute">animation</span>: rotate <span class="hljs-number">20s</span> linear infinite;<br>        <span class="hljs-selector-tag">span</span> &#123;<br>            <span class="hljs-attribute">position</span>: absolute;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>            <span class="hljs-comment">// 设置元素的子元素是位于 3D 空间中还是平面中。</span><br>            <span class="hljs-attribute">transform-style</span>:preserve-<span class="hljs-number">3</span>d;<br>            <span class="hljs-comment">// 让每张图片 y 方向上旋转一些角度; z 方向上移动一些距离(不然会叠在一起) </span><br>            <span class="hljs-attribute">transform</span>:rotateY(calc(var(--i) * <span class="hljs-number">45deg</span>)) translateZ(<span class="hljs-number">10vw</span>);<br>            <span class="hljs-selector-tag">img</span> &#123;<br>                <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<br>                <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;<br>                <span class="hljs-attribute">object-fit</span>:cover;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心就是利用</p><p>transform-style:preserve-3d和ransform:rotateY(calc(var(–i) * 45deg)) translateZ(10vw)构造一个三维立方体，可以想象在立方体的前后左右四个面各贴一张图片。</p><p>然后 利用动画 rotateY 从 0 到 360 度 让立方体 自转</p><p><strong>补充知识：</strong></p><p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/perspective">perspective</a></strong></p><p>指定了观察者与 z&#x3D;0 平面的距离，使具有三维位置变换的元素产生透视效果。</p><p>perspective 越大，观察者与平面的距离越远，物体越小。</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220925183438206.png" class="" title="image-20220925183438206"><p><strong>html 向 css 传参</strong></p><p>html 中写内联样式 :style&#x3D;”`–i:${index}`“</p><p>css 利用 var 接收 var(–i) </p><h2 id="路由不跳转问题"><a href="#路由不跳转问题" class="headerlink" title="路由不跳转问题"></a>路由不跳转问题</h2><p>同一页面下，query 参数不同，router.push 后页面不跳转。如下图，点击妙蛙花时，路由不跳转。</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220926141821034.png" class="" title="image-20220926141821034"><p>原因：vue官网详细解释说明<strong>使用同一路由携带不同参数，本质上是重用相同的组件实例，默认在跳转路由时会采用缓存策略,并不会刷新当前路由组件</strong>，因此不会调用组件的生命周期挂钩。</p><p>解决：监听 router 的动作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue3">watch: &#123;<br>    &#x27;$route&#x27; (to, from) &#123;<br>        this.$router.go(0);<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="能力图"><a href="#能力图" class="headerlink" title="能力图"></a>能力图</h2><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20221004185441044.png" class="" title="image-20221004185441044"><p>能力值越高，有色部分越多，白圈越少</p><p>核心是利用 svg 的 stroke-dashoffset 属性（线偏移量）来控制白圈</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--  Container  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;progress&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  Item  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">:data-name</span>=<span class="hljs-string">&quot;item.stat.name&quot;</span> <span class="hljs-attr">:data-percent</span>=<span class="hljs-string">&quot;item.base_stat&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in curPokemon?.stats&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 内层圆 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;-10 -10 220 220&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;9&quot;</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;translate(100,100)&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M 0,-100 A 100,100 0 0,1 86.6,-50&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl1)&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M 86.6,-50 A 100,100 0 0,1 86.6,50&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl2)&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M 86.6,50 A 100,100 0 0,1 0,100&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl3)&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M 0,100 A 100,100 0 0,1 -86.6,50&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl4)&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M -86.6,50 A 100,100 0 0,1 -86.6,-50&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl5)&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M -86.6,-50 A 100,100 0 0,1 0,-100&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;url(#cl6)&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 白圈 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;-10 -10 220 220&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M200,100 C200,44.771525 155.228475,0 100,0 C44.771525,0 0,44.771525 0,100 C0,155.228475 44.771525,200 100,200 C155.228475,200 200,155.228475 200,100 Z&quot;</span> <span class="hljs-attr">:stroke-dashoffset</span>=<span class="hljs-string">&quot;item.base_stat / 200 * 630&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-comment">&lt;!--  定义内层圆的颜色(线性梯度变化)  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">defs</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">linearGradient</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cl1&quot;</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#618099&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#8e6677&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">linearGradient</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">linearGradient</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cl2&quot;</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#8e6677&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#9b5e67&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">linearGradient</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">linearGradient</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cl3&quot;</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#9b5e67&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#9c787a&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">linearGradient</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">linearGradient</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cl4&quot;</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#9c787a&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#817a94&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">linearGradient</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">linearGradient</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cl5&quot;</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#817a94&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#498a98&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">linearGradient</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">linearGradient</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cl6&quot;</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#498a98&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">stop-color</span>=<span class="hljs-string">&quot;#618099&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">linearGradient</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">defs</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p>grid 布局，两行三列</p><p>ability 的名字和能力值分别通过伪元素 ::before 和 ::after 的形式插入</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.progress</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">25vw</span>;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>    <span class="hljs-attribute">grid-template-rows</span>: repeat(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>fr);<br>    <span class="hljs-attribute">margin</span>: -<span class="hljs-number">2vw</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">5vw</span>;<br>    <span class="hljs-comment">// border: 2px solid black;</span><br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-selector-tag">&amp;</span>&gt;<span class="hljs-selector-tag">li</span> &#123;<br>        <span class="hljs-attribute">display</span>: grid;<br>        <span class="hljs-attribute">grid-template-columns</span>: repeat(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>fr);<br>        <span class="hljs-attribute">grid-template-rows</span>: repeat(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>fr);<br>        <span class="hljs-attribute">position</span>: relative;<br>        <span class="hljs-attribute">text-align</span>: center;<br>        <span class="hljs-attribute">color</span>: <span class="hljs-number">#93A2AC</span>;<br>        <span class="hljs-attribute">font-family</span>: Lato;<br>        <span class="hljs-attribute">font-weight</span>:<span class="hljs-number">100</span>;<br>        <span class="hljs-attribute">margin</span>: <span class="hljs-number">2vw</span>;<br>        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>            <span class="hljs-attribute">content</span>: attr(data-name);<br>            <span class="hljs-attribute">position</span>: absolute;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>            <span class="hljs-attribute">top</span>: <span class="hljs-number">5vw</span>;<br>            <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">400</span>;<br>        &#125;<br>        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>            <span class="hljs-attribute">content</span>: attr(data-percent);<br>            <span class="hljs-attribute">position</span>: absolute;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>            <span class="hljs-attribute">top</span>: <span class="hljs-number">1.6vw</span>;<br>            <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2vw</span>;<br>            <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">400</span>;<br>            <span class="hljs-attribute">text-align</span>: center;<br>        &#125;<br>    &#125;<br>    <span class="hljs-selector-tag">svg</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">5vw</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">5vw</span>;<br>        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-attribute">position</span>: absolute;<br>            <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>            <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>            <span class="hljs-attribute">transform</span>: rotate(-<span class="hljs-number">90deg</span>);<br>        &#125;<br>        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) <span class="hljs-selector-tag">path</span> &#123;<br>            fill: <span class="hljs-attribute">none;</span><br><span class="hljs-attribute">            stroke-width</span>: <span class="hljs-number">25</span>;<br>            stroke-dasharray: 629;<br>            stroke: #fff;<br>            <span class="hljs-attribute">opacity</span>:.<span class="hljs-number">9</span>;<br>            <span class="hljs-attribute">animation</span>: load <span class="hljs-number">10s</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="让分页器一直变色"><a href="#让分页器一直变色" class="headerlink" title="让分页器一直变色"></a>让分页器一直变色</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">animation</span>: changeColor <span class="hljs-number">2s</span> linear infinite;<br><span class="hljs-keyword">@keyframes</span> changeColor &#123;<br>    <span class="hljs-selector-tag">from</span> &#123;<br>        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">0</span>)<br>    &#125;<br>    <span class="hljs-selector-tag">to</span> &#123;<br>        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">360deg</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用 animation 动画 和 filter: hue-rotate 属性，hue-rotate 是色调旋转滤镜</p><p>关于 hue-rotate 可以看张鑫旭的这篇文章 <a href="https://www.zhangxinxu.com/wordpress/2018/11/css-filter-hue-rotate-button/">https://www.zhangxinxu.com/wordpress/2018/11/css-filter-hue-rotate-button/</a></p><h2 id="边框360度转"><a href="#边框360度转" class="headerlink" title="边框360度转"></a>边框360度转</h2><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20221111202200896.png" class="" title="image-20221111202200896"> <p>利用 animation 和 clip-path 以及 filter-hue-rotate。clip-path 用于裁剪路径，可以看我的博客中的一篇文章。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.about-border</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">background-color</span>: transparent;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid;<br>    <span class="hljs-attribute">border-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">45deg</span>, <span class="hljs-built_in">rgb</span>(<span class="hljs-number">184</span>, <span class="hljs-number">159</span>, <span class="hljs-number">218</span>), <span class="hljs-built_in">rgb</span>(<span class="hljs-number">15</span>, <span class="hljs-number">48</span>, <span class="hljs-number">194</span>)) <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">100%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">animation</span>: clipPath <span class="hljs-number">5s</span> infinite linear;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> clipPath &#123;<br>    <span class="hljs-number">0%</span>&#123;<br>        <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">100%</span> <span class="hljs-number">0</span>);<br>        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">0deg</span>);<br>    &#125;<br>    <span class="hljs-number">25%</span> &#123;<br>        <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">100%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-number">50%</span> &#123;<br>        <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">100%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>);<br>        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">360deg</span>);<br>    &#125;<br>    <span class="hljs-number">75%</span> &#123;<br>        <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">100%</span>);<br>    &#125;<br>    <span class="hljs-number">100%</span> &#123;<br>        <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">100%</span> <span class="hljs-number">0</span>);<br>        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">0deg</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="待做"><a href="#待做" class="headerlink" title="待做"></a>待做</h1><p>类似 <a href="https://50projects50days.com/#projects">https://50projects50days.com/#projects</a></p><p>api 等待时，放皮卡丘跑步的 gif</p><p>左侧来一个精灵球，hover弹出很多选项</p><p>精灵间的对比</p><p>background-size: cover 图片大小自适应</p><p>vue3 + ts 的路由：</p><p><a href="https://blog.csdn.net/m0_63677099/article/details/124259762">https://blog.csdn.net/m0_63677099/article/details/124259762</a></p><p>types</p><p><a href="https://www.yuewen.com/#&amp;copyright">https://www.yuewen.com/#&amp;copyright</a></p><p><strong>一个很好的参考</strong></p><p><a href="https://codepen.io/tiffachoo/pen/omowyX">https://codepen.io/tiffachoo/pen/omowyX</a></p><h1 id="暂时做不到的"><a href="#暂时做不到的" class="headerlink" title="暂时做不到的"></a>暂时做不到的</h1><p><strong>1.每张卡要有自己的专属图片（最好是炫酷一点的），替代下方统一的图片</strong></p><p>开源 api 中没有</p><img src="/2022/09/06/pokemon%E9%A1%B9%E7%9B%AE/image-20220924191406689.png" class="" title="image-20220924191406689"><p><strong>2.不同种族的 card 应该有不同的配色方案</strong></p><p>没有 ui，十几个种族，自己设计太麻烦</p><h1 id="部署到-github-并生成网页"><a href="#部署到-github-并生成网页" class="headerlink" title="部署到 github 并生成网页"></a>部署到 github 并生成网页</h1><p><strong>完整流程：</strong></p><p><a href="https://blog.csdn.net/m0_46898790/article/details/126105486">https://blog.csdn.net/m0_46898790/article/details/126105486</a></p><p><strong>一些简单配置</strong></p><p><a href="https://blog.csdn.net/shinjie1210/article/details/122473024">https://blog.csdn.net/shinjie1210/article/details/122473024</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> legacyPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-legacy&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>    <span class="hljs-comment">// 兼容</span><br>    <span class="hljs-title function_">legacyPlugin</span>(&#123;<br>      <span class="hljs-attr">targets</span>: [<span class="hljs-string">&#x27;chrome 52&#x27;</span>], <span class="hljs-comment">// 需要兼容的目标列表，可以设置多个</span><br>      <span class="hljs-attr">additionalLegacyPolyfills</span>: [<span class="hljs-string">&#x27;regenerator-runtime/runtime&#x27;</span>] <span class="hljs-comment">// 面向IE11时需要此插件</span><br>    &#125;)<br>  ],<br>  <span class="hljs-comment">// 配置基本路径</span><br>  <span class="hljs-attr">base</span>: <span class="hljs-string">&#x27;./&#x27;</span>,<br>  <span class="hljs-attr">build</span>: &#123;<br>    <span class="hljs-attr">rollupOptions</span>: &#123;<br>      <span class="hljs-comment">// 打包后的文件根据后缀归类</span><br>      <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">chunkFileNames</span>: <span class="hljs-string">&#x27;static/js/[name]-[hash].js&#x27;</span>,<br>        <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">&#x27;static/js/[name]-[hash].js&#x27;</span>,<br>        <span class="hljs-attr">assetFileNames</span>: <span class="hljs-string">&#x27;static/[ext]/[name]-[hash].[ext]&#x27;</span>,<br>      &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 去除 console 和 debugger</span><br>    <span class="hljs-attr">terserOptions</span>: &#123;<br>      <span class="hljs-attr">compress</span>: &#123;<br>        <span class="hljs-attr">drop_console</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">drop_debugger</span>: <span class="hljs-literal">true</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>base 不加打包后的网页打不开的，路径会有问题</p><p><strong>构建网页</strong></p><p><a href="https://blog.csdn.net/mrliucx/article/details/125574957">https://blog.csdn.net/mrliucx/article/details/125574957</a></p><p><strong>网页地址</strong></p><p><a href="https://akirajy.github.io/pokemonBook/">https://akirajy.github.io/pokemonBook/</a></p><p>注：如果既要开源，又要通过 github 部署成网页，可以 main 分支中放源代码，pages 分支中放打包后的文件</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式与开发实践</title>
    <link href="/2022/09/05/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/09/05/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象的JS"><a href="#面向对象的JS" class="headerlink" title="面向对象的JS"></a>面向对象的JS</h2><h3 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h3><p>如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子</p><p>只关注对象的行为，而不关注对象本身</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同一操作作用于不同对象上时，可以产生不同的解释和结果。</p><p>多态背后的思想是将 “做什么” 和 “谁去做以及怎样去做，也就是将 ”不变的事物“ 与 ”可能改变的事物” 分类开来。这样后续再增加新的对象时，仅仅增加代码即可，不用再去修改之前的代码。</p><p>使用继承来得到多态效果，是让对象表现出多态性的最常用手段。</p>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue的事件修饰符</title>
    <link href="/2022/09/04/vue%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2022/09/04/vue%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6981628129089421326">https://juejin.cn/post/6981628129089421326</a>  这篇文章写得挺完整了</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事件修饰符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Content-Type</title>
    <link href="/2022/09/04/FormData/"/>
    <url>/2022/09/04/FormData/</url>
    
    <content type="html"><![CDATA[<h1 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h1><p><strong>Content-Type</strong>（MediaType），即是Internet Media Type，互联网媒体类型，也叫做<strong>MIME类型</strong>。在互联网中有成百上千中不同的数据类型，HTTP在传输数据对象时会为他们打上称为MIME的数据格式标签，用于<strong>区分数据类型</strong>。</p><p>在HTTP协议消息头中，使用Content-Type来表示请求和响应中的媒体类型信息。它用来告诉服务端如何处理请求的数据，以及告诉客户端（一般是浏览器）如何解析响应的数据，比如显示图片，解析并展示html等等。</p><p><strong>Content-Type的格式：</strong><br><strong>Content-Type：type&#x2F;subtype ;parameter</strong></p><p>type：主类型，任意的字符串，如text，如果是*号代表所有；<br>subtype：子类型，任意的字符串，如html，如果是*号代表所有，用“&#x2F;”与主类型隔开；<br>parameter：可选参数，如charset，boundary等。</p><p>例如：<br>Content-Type: text&#x2F;html;<br>Content-Type: application&#x2F;json;charset:utf-8;</p><table><thead><tr><th><strong>MIME 类型</strong></th><th>描述</th></tr></thead><tbody><tr><td>text&#x2F;plain</td><td>纯文本文档</td></tr><tr><td>text&#x2F;html</td><td>HTML 文档</td></tr><tr><td>text&#x2F;javascript</td><td>JavaScript 文件</td></tr><tr><td>text&#x2F;css</td><td>CSS 文件</td></tr><tr><td>application&#x2F;json</td><td>JSON 文件</td></tr><tr><td>application&#x2F;pdf</td><td>PDF 文件</td></tr><tr><td>application&#x2F;xml</td><td>XML 文件</td></tr><tr><td>image&#x2F;jpeg</td><td>JPEG 图像</td></tr><tr><td>image&#x2F;png</td><td>PNG 图像</td></tr><tr><td>image&#x2F;gif</td><td>GIF 图像</td></tr><tr><td>image&#x2F;svg+xml</td><td>SVG 图像</td></tr><tr><td>audio&#x2F;mpeg</td><td>MP3 文件</td></tr><tr><td>video&#x2F;mpeg</td><td>MP4 文件</td></tr></tbody></table><h2 id="application-x2F-json"><a href="#application-x2F-json" class="headerlink" title="application&#x2F;json"></a>application&#x2F;json</h2><p>现在越来越多的应用使用application&#x2F;json，用来告诉服务端消息主体是序列化的json字符串。由于json规范的流行，各大浏览器都开始原生支持JSON.stringfy。</p><p>而且spring对这个content-Type上传的数据有很好的支持，可以直接通过@RequestBody进行接收。也是当前完美适配当前流行的RestApi。</p><p>JSON 是一种轻量级的数据格式，以“键-值”对的方式组织的数据。使用这个类型，需要参数本身就是json格式的数据，参数会被直接放到请求实体里，不进行任何处理。服务端&#x2F;客户端会按json格式解析数据（约定好的情况下）。</p><p>请求参数</p><img src="/2022/09/04/FormData/20190111180712373.png" class="" title="application&#x2F;json请求参数"><p>http 请求报文</p><img src="/2022/09/04/FormData/20190624231555162.png" class="" title="application&#x2F;json报文"><h2 id="application-x2F-x-www-form-urlencoded"><a href="#application-x2F-x-www-form-urlencoded" class="headerlink" title="application&#x2F;x-www-form-urlencoded"></a>application&#x2F;x-www-form-urlencoded</h2><p>在最开始的请求方式中，请求参数都是放在url中，表单提交的时候，都是以key&#x3D;&amp;value&#x3D;的方式写在url后面。这也是浏览器表单提交的默认方式。</p><p>不支持文件，一般用于表单提交。</p><ul><li>请求参数<img src="/2022/09/04/FormData/20190111174842982.png" class="" title="application&#x2F;x-www-form-urlencoded请求参数"></li><li>http 请求报文<img src="/2022/09/04/FormData/20190624231322976.png" class="" title="application&#x2F;x-www-form-urlencoded报文"></li></ul><h2 id="multipart-x2F-form-data"><a href="#multipart-x2F-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>此种方式多用于<strong>文件上传</strong>，表单数据都保存在http的正文部分，各个表单项之间用boundary分开。</p><p>与application&#x2F;x-www-form-urlencoded不同，这是一个多部分多媒体类型。首先生成了一个 boundary 用于分割不同的字段，在请求实体里每个参数以——boundary开始，然后是附加信息和参数名，然后是空行，最后是参数内容。多个参数将会有多个boundary块。如果参数是文件会有特别的文件域。最后以——boundary–为结束标识。multipart&#x2F;form-data支持文件上传的格式，一般需要上传文件的表单则用该类型。</p><p>下面是一个例子：</p><ul><li>请求参数<img src="/2022/09/04/FormData/20190111174827455.png" class="" title="multipart&#x2F;form-data请求参数"></li><li>http 请求报文<img src="/2022/09/04/FormData/20190624231435322.png" class="" title="multipart&#x2F;form-data报文"></li></ul><p><code>Content-Disposition</code> 是必选项， <code>name</code> 属性代表着表单元素的 <code>key</code>，<code>filename</code> 则是上传文件的名称</p><h3 id="为什么需要-FormData"><a href="#为什么需要-FormData" class="headerlink" title="为什么需要 FormData"></a>为什么需要 FormData</h3><p><code>application/json</code> 作为请求头 <code>Content-Type</code> 字段值时，表示告知服务端参数是序列化后的 <code>JSON</code> 字符串，所以一般在传参时都会用 <code>JSON.stringify</code> 序列化一下，但是 <strong><code>JSON.stringify</code> 在转换某一些数据结构时会出问题</strong>，比如 会丢失 function 类型的参数、循环引用时会报错、**<code>Blob</code> &#x2F;<code>File</code> 对象会被转化成 <code>&#123;&#125;</code>**  等等。</p><p>如果要是图片那可以转换成 <code>base64</code> 格式进行上传解决，这种方式虽然可行，但是转换成 <code>base64</code> 格式需要很多字符，占用很多资源，而且很长，不便于阅读，另外就是服务端接收到这个参数还得解析，很麻烦，此时，<code>FormData</code> 就可用上了。</p><h3 id="使用-FormData"><a href="#使用-FormData" class="headerlink" title="使用 FormData"></a>使用 FormData</h3><p>window 上直接挂载了 FormData 对象</p><img src="/2022/09/04/FormData/image-20220904172337954.png" class="" title="image-20220904172337954"><p>我们一般都使用 append 方法</p><p>append 和 set 的区别：</p><p><code>append</code> 的 <code>key</code> 存在，就会附加到已有值集合的后面，而 <code>set</code> 会使用新值覆盖已有的值</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/a772116804/article/details/114586937">https://blog.csdn.net/a772116804/article/details/114586937</a></p><p><a href="https://juejin.cn/post/7057293668440834061">https://juejin.cn/post/7057293668440834061</a></p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手写常用函数</title>
    <link href="/2022/08/28/%E6%89%8B%E5%86%99%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/2022/08/28/%E6%89%8B%E5%86%99%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map"></a>Array.prototype.map</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 样例</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>].<span class="hljs-title function_">_map</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i * <span class="hljs-number">2</span>)<br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>mdn 里的 map</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">element, index, array</span>) &#123; <span class="hljs-comment">/* … */</span> &#125;, thisArg)<br><span class="hljs-comment">// thisArg 可省略</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 不能写箭头函数, this会指向数组的父级</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_map</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">const</span> array = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">const</span> newArray = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-comment">// 根据 mdn 的输入来写这里的输入</span><br>        newArray.<span class="hljs-title function_">push</span>(fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>], array[i], i, array))<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArray<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter"></a>Array.prototype.filter</h2><p>和 map 没什么区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 样例</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>].<span class="hljs-title function_">_filter</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i&gt;<span class="hljs-number">1</span>)<br>[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_filter</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">const</span> array = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">const</span> newArray = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>], array[i], i, array)) &#123;<br>            newArray.<span class="hljs-title function_">push</span>(array[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArray<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 样例</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_">_reduce</span>(<span class="hljs-function">(<span class="hljs-params">left, right</span>) =&gt;</span> left + right)<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>mdn</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">previousValue, currentValue, currentIndex, array</span>) &#123; <span class="hljs-comment">/* … */</span> &#125;, initialValue)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_reduce</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">const</span> array = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">let</span> flag<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>        preValue = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]<br>        flag = <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        preValue = array[<span class="hljs-number">0</span>]<br>        flag = <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = flag ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>        preValue = <span class="hljs-title function_">fn</span>(preValue, array[i], i, array)<br>    &#125;<br>    <span class="hljs-keyword">return</span> preValue<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><p>创建一个新对象，使用现有的对象来作为新创建对象的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用原型式继承的思想</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_objectCreate</span> = proto =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;object&#x27;</span> || proto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = proto<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call"></a>Function.prototype.call</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>    <span class="hljs-keyword">let</span> context = context || <span class="hljs-variable language_">window</span><br>    <span class="hljs-comment">// 1.将函数设为对象的属性(this指向当前函数, context是传入的对象)</span><br>    context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// 2.执行该函数</span><br>    <span class="hljs-keyword">let</span> result = context.<span class="hljs-title function_">fn</span>(...args)<br><br>    <span class="hljs-comment">// 3.执行完后删除函数</span><br>    <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Error&#x27;</span>)<br>    <span class="hljs-keyword">let</span> fn = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 返回一个函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> F) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>(...args, ...<span class="hljs-variable language_">arguments</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, [...args, ...<span class="hljs-variable language_">arguments</span>])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="new-实例化"><a href="#new-实例化" class="headerlink" title="new 实例化"></a>new 实例化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 样例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;<br><span class="hljs-keyword">let</span> p = <span class="hljs-title function_">_new</span>(<span class="hljs-title class_">Person</span>, <span class="hljs-string">&quot;sillywa&quot;</span>, <span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_new</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 1.创建一个空对象</span><br>    <span class="hljs-keyword">let</span> obj = &#123;&#125;<br>    <br>    <span class="hljs-comment">// 2.将该空对象的原型链连接到传入的对象</span><br>    <span class="hljs-keyword">let</span> [<span class="hljs-title class_">Con</span>, ...args] = <span class="hljs-variable language_">arguments</span><br>    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Con</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>    <br>    <span class="hljs-comment">// 3.执行函数并绑定this</span><br>    <span class="hljs-keyword">let</span> res = <span class="hljs-title class_">Con</span>.<span class="hljs-title function_">call</span>(obj, ...args)<br>    <br>    <span class="hljs-comment">// 4.如果函数有返回值并且为object，则返回函数的返回值，否则返回obj</span><br>    <span class="hljs-keyword">return</span> res <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? res : obj<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="x3D-x3D-扁平数据结构转Tree-x3D-x3D"><a href="#x3D-x3D-扁平数据结构转Tree-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;扁平数据结构转Tree&#x3D;&#x3D;"></a>&#x3D;&#x3D;扁平数据结构转Tree&#x3D;&#x3D;</h2><p>总的来说就两步：</p><ol><li><p>创建当前 id 的 map</p></li><li><p>将当前 id 的 map 放入 pid 的 map 的 children 中</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<br>  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;部门1&#x27;</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">0</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;部门2&#x27;</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">1</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;部门3&#x27;</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">1</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;部门4&#x27;</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">3</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;部门5&#x27;</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">4</span>&#125;,<br>]<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">arrayToTree</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = []<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;<br><br>  arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; id, pid &#125; = item<br>    <span class="hljs-comment">// 1.创建当前 id 的 map</span><br><br>    <span class="hljs-comment">// 还没有生成的话就生成一个, 避免下面报错</span><br>    <span class="hljs-keyword">if</span> (!map[id]) &#123;<br>      map[id] = &#123;<br>        <span class="hljs-attr">children</span>: [],<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 生成当前 id 的 树结构, 部分 children 可能已经在之前通过 pid 生成了</span><br>    map[id] = &#123;<br>      ...item,<br>      <span class="hljs-attr">children</span>: map[id][<span class="hljs-string">&#x27;children&#x27;</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> treeItem = map[id]<br><br>    <span class="hljs-comment">// 2.将当前 id 的 map 放入 pid 的 map 的 children 中</span><br>    <span class="hljs-keyword">if</span> (pid === <span class="hljs-number">0</span>) &#123;<br>      result.<span class="hljs-title function_">push</span>(treeItem)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (!map[pid]) &#123;<br>        map[pid] = &#123;<br>          <span class="hljs-attr">children</span>: []<br>        &#125;<br>      &#125;<br>      map[pid].<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(treeItem)<br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="只执行一次的-once"><a href="#只执行一次的-once" class="headerlink" title="只执行一次的 once"></a>只执行一次的 once</h2><p>实现一个 once 函数，记忆返回结果只执行一次</p><p>类似于 lodash.once</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// f 是一个函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">x</span>) =&gt; x;<br><br><span class="hljs-keyword">const</span> onceF = <span class="hljs-title function_">once</span>(f);<br><br><span class="hljs-comment">//=&gt; 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onceF</span>(<span class="hljs-number">3</span>))<br><br><span class="hljs-comment">//=&gt; 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onceF</span>(<span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">once</span>(<span class="hljs-params">f</span>) &#123;<br>  <span class="hljs-keyword">let</span> result<br>  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> result<br>    result = <span class="hljs-title function_">f</span>(...args)<br>    flag = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无限累加的-sum"><a href="#无限累加的-sum" class="headerlink" title="无限累加的 sum"></a>无限累加的 sum</h2><p>参数无限，调用次数无限</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">//6</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>).<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">//11</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>).<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">//10</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)(<span class="hljs-number">2</span>).<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">//9</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)(<span class="hljs-number">6</span>).<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">...rest</span>) =&gt; <span class="hljs-title function_">sum</span>(...args, ...rest)<br>  f.<span class="hljs-property">valueOf</span> = <span class="hljs-function">() =&gt;</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> f<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用于函数合成的-compose"><a href="#用于函数合成的-compose" class="headerlink" title="用于函数合成的 compose"></a>用于函数合成的 compose</h2><p>实现一个 compose 函数，进行函数合成，比如 redux 中的 compose，react 高阶组件连续调用时的 compose</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add10</span> = (<span class="hljs-params">x</span>) =&gt; x + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mul10</span> = (<span class="hljs-params">x</span>) =&gt; x * <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">add100</span> = (<span class="hljs-params">x</span>) =&gt; x + <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// (10 + 100) * 10 + 10 = 1110</span><br><span class="hljs-title function_">compose</span>(add10, mul10, add100)(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p><strong>错误的(我最初写的)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> funcs = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>).<span class="hljs-title function_">reverse</span>()<br>  <span class="hljs-keyword">const</span> n = funcs.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      num = funcs[i](num)<br>    &#125;<br>    <span class="hljs-keyword">return</span> num<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然没有考虑函数的参数个数与返回值个数的问题，只用了一个num，默认一个参数了。</p><p><strong>正确版</strong></p><p>利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">array.reduce</a> 函数</p><p>上一次的返回结果会作为下一次的参数，a 为上一个值，b为当前值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">...funcs</span>) &#123;<br>    <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(...args)))<br>&#125;<br></code></pre></td></tr></table></figure><p>是一个正向的，从左向右递推的过程。</p><p>如果 a 是函数，b是参数，就是 (a,b) &#x3D;&gt; a(b)</p><p>但是要考虑到 b 也是函数，所以 b 也得调用一下，得到返回值后再作为 a 的参数传入</p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>手写代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>手写函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueRouter的hash和history模式</title>
    <link href="/2022/08/28/VueRouter%E7%9A%84hash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/08/28/VueRouter%E7%9A%84hash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="VueRouter的hash和history模式"><a href="#VueRouter的hash和history模式" class="headerlink" title="VueRouter的hash和history模式"></a>VueRouter的hash和history模式</h2><p><code>vue-router</code> 在实现单页面前端路由时，提供了两种方式：<code>Hash</code> 模式和 <code>History</code> 模式</p><p>vue2 是根据 <code>mode</code> 参数来决定采用哪一种方式</p><p>vue3 则是 <code>history</code> 参数</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>localhost:8080&#x2F;#&#x2F;home</p><ul><li><code>vue-router</code> 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。  <code>hash</code>（#）是 <code>URL</code> 的锚点，代表的是网页中的一个位置，单单改变 <code>#</code> 后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 <code>#</code> 是用来指导浏览器动作的，对服务器端完全无用，<code>HTTP</code> 请求中也不会不包括 <code>#</code> ，同时每一次改变 <code>#</code> 后的部分，都会在浏览器的访问历史中增加一个记录，使用 “后退” 按钮，就可以回到上一个位置，所以说 <code>hash</code> 模式通过锚点值的改变，根据不同的值，渲染指定 <code>DOM</code> 位置的不同数据。</li><li><code>#</code> 符号本身以及它后面的字符称之为 <code>hash</code>，可通过<code> window.location.hash</code> 属性读取。</li><li><code>hash</code> 通过 <code>window.onhashchange</code> 的方式，来监听 <code>hash</code> 的改变，借此实现无刷新跳转的功能。</li></ul><p><strong>对 SEO 不友好</strong></p><h4 id="设置hash模式"><a href="#设置hash模式" class="headerlink" title="设置hash模式"></a>设置hash模式</h4><p>vue2 中默认为 mode:hash</p><p>vue3 中使用 createWebHashHistory</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue3">import &#123; createWebHashHistory &#125; from &#x27;vue-router&#x27;<br><br>const router = createRouter(&#123;<br>  history: createWebHashHistory(),<br>  routes<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><h4 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h4><p>localhost:8080&#x2F;home</p><p><code>history</code> 是路由的另一种模式，由于 hash 模式会在 url 中带#，如果不想要带 #的话，我们可以使用路由的 <code>history</code> 模式，只需要在响应的 <code>router</code> 配置规则时加上即可，<code>vue</code> 的路由默认是 <code>hash</code> 模式。</p><p>利用了<code>HTML5 History Interface</code>中新增的 <code>pushState()</code> 和<code> replaceState()</code> 方法。</p><p>这两个方法应用于浏览器的历史记录栈，在当前已有的<code> back、forward、go</code> 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><p>美观，没有#</p></li><li><p>pushState() 相比于直接修改 hash 的优势</p></li></ol><p>pushState()设置的新 URL 可以是与当前 URL 同源的任意 URL；而<code>hash</code>只可修改<code>#</code><br> 后面的部分，因此只能设置与当前 URL 同文档的 URL；</p><p>pushState()设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；<br> 而<code>hash</code>设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</p><p>pushState()通过<code>stateObject</code>参数可以添加任意类型的数据到记录中；<br> 而<code>hash</code>只可添加短字符串；</p><p>pushState()可额外设置<code>title</code>属性供后续使用。</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p><strong>需要后端配置（nginx代理转发，找不到就重定向到项目首页）</strong></p><p>否则刷新页面会报404，因为会重新发请求，而此时的 url 已经改变。</p><p>具体的说：当我们把 history 项目部署到服务器中后,此时我们在浏览器输入一个网址(比如是 <a href="https://link.juejin.cn/?target=http://www.test.com">www.test.com</a> ), 此时会经过 dns 解析，拿到 ip 地址后根据 ip 地址向该服务器发起请求,服务器接受到请求后,然后返回相应的结果(html,css,js)。如果我们在前端设置了重定向，此时页面会进行跳转到  <a href="https://link.juejin.cn/?target=http://www.test.com/home">www.test.com/home</a> ,在前端会进行匹配对应的组件然后将其渲染到页面上。此时如果我们刷新页面的话，浏览器会发送新的请求 <a href="https://link.juejin.cn/?target=http://www.test.com/home">www.test.com/home</a>, 如果后端服务器没有 &#x2F;home 对应的接口，那么就会返回404。</p><p>hash模式不会404，因为 #及之后的内容并不会放入请求</p><p>注意：开发环境没有这个问题，因为 webpack 处理好了。生产环境才会有问题。</p><h4 id="设置history模式"><a href="#设置history模式" class="headerlink" title="设置history模式"></a>设置history模式</h4><p>vue2 中设置 mode:history</p><p>vue3 中设置 createWebHistory</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue3">import &#123; createWebHistory &#125; from &#x27;vue-router&#x27;<br><br>const router = createRouter(&#123;<br>  history: createWebHistory(),<br>  routes<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="实际项目中对两种模式的使用"><a href="#实际项目中对两种模式的使用" class="headerlink" title="实际项目中对两种模式的使用"></a>实际项目中对两种模式的使用</h3><img src="/2022/08/28/VueRouter%E7%9A%84hash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F/image-20220911221416987.png" class="" title="image-20220911221416987"><p>我们看 vue3 的官网</p><p>点击左侧的章节，中间部分会被整体替换，使用的是 history 模式。url 如下</p><p><a href="https://cn.vuejs.org/guide/introduction.html">https://cn.vuejs.org/guide/introduction.html</a></p><p>点击右侧的本页目录，中间部分不会替换，而是滚动到对应位置，使用的是 hash 模式。url 如下</p><p><a href="https://cn.vuejs.org/guide/typescript/composition-api.html#typing-component-props">https://cn.vuejs.org/guide/typescript/composition-api.html#typing-component-props</a></p><p>注意：<strong>上面写的是错的，这里其实根本不是 hash，而是 html 自带的锚点。</strong></p><p>现在感觉大部分的网页都使用的是 history，可能是因为对 SEO 不友好？</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/7116336664540086286#heading-7">https://juejin.cn/post/7116336664540086286#heading-7</a></p><p><a href="https://juejin.cn/post/7096034733649297421">https://juejin.cn/post/7096034733649297421</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>declare</title>
    <link href="/2022/08/12/declare/"/>
    <url>/2022/08/12/declare/</url>
    
    <content type="html"><![CDATA[<h1 id="Declare"><a href="#Declare" class="headerlink" title="Declare"></a>Declare</h1><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><h3 id="什么是声明文件"><a href="#什么是声明文件" class="headerlink" title="什么是声明文件"></a>什么是声明文件</h3><p><strong>声明文件就是给js代码补充类型标注</strong>. 这样在ts编译环境下就不会提示js文件”缺少类型”.</p><p>声明文件以<code>.d.ts</code>结尾，一般<strong>放在根目录下</strong>。</p><h3 id="查看库的声明文件"><a href="#查看库的声明文件" class="headerlink" title="查看库的声明文件"></a>查看库的声明文件</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 以 jquery 为例</span><br>npm i <span class="hljs-meta">@types</span>/jquery<br></code></pre></td></tr></table></figure><p>安装后, 我们可以在<code>node_modules/@types/jquery</code>中的看到声明文件</p><p>如果找不到，就需要自己手写了</p><h2 id="怎么写声明文件"><a href="#怎么写声明文件" class="headerlink" title="怎么写声明文件"></a>怎么写声明文件</h2><h3 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h3><h4 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h4><p>通过<code>declare</code>我们可以标注js全局变量的类型.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// global.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">o</span>: <span class="hljs-built_in">object</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">enum</span> dir &#123;<br>    top,<br>    right,<br>    bottom,<br>    left<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts">n = <span class="hljs-number">321</span><br>s = <span class="hljs-string">&#x27;文字&#x27;</span><br><span class="hljs-keyword">let</span> o1 = o;<br><span class="hljs-title function_">f</span>(<span class="hljs-string">&#x27;123&#x27;</span>).<span class="hljs-title function_">toFixed</span>();<br>dir.<span class="hljs-property">bottom</span>.<span class="hljs-title function_">toFixed</span>();<br><br><span class="hljs-comment">// 报错</span><br>n = <span class="hljs-string">&#x27;312&#x27;</span><br>s = 123g<span class="hljs-string">&#x27;yo是哟个</span><br></code></pre></td></tr></table></figure><h4 id="declare-namespace"><a href="#declare-namespace" class="headerlink" title="declare namespace"></a><strong>declare namespace</strong></h4><p>这个<code>namespace</code>代表后面的全局变量是一个对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// global.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-attr">n</span>:<span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-attr">f</span>:<span class="hljs-function">(<span class="hljs-params">s:<span class="hljs-built_in">string</span></span>)=&gt;</span><span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">s</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">n</span>.<span class="hljs-title function_">toFixed</span>();<br><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-title function_">f</span>(<span class="hljs-string">&#x27;文字&#x27;</span>).<span class="hljs-title function_">toFixed</span>();<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">s</span>.<span class="hljs-title function_">toFixed</span>();<br><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">n</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-title function_">f</span>(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><h4 id="修改已存在的全局声明"><a href="#修改已存在的全局声明" class="headerlink" title="修改已存在的全局声明"></a>修改已存在的全局声明</h4><p><code>node_modules/typescript/lib</code>下，有很多系统变量的声明文件</p><p>如果你要修改<strong>已存在</strong>的全局变量的声明可以这么写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">global</span> &#123;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">String</span> &#123;<br>        <span class="hljs-title function_">hump</span>(<span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 注意: 修改&quot;全局声明&quot;必须在模块内部, 所以至少要有 export&#123;&#125;字样</span><br><span class="hljs-comment">// 不然会报错❌: 全局范围的扩大仅可直接嵌套在外部模块中或环境模块声明中</span><br><span class="hljs-keyword">export</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>现在<code>String</code>类型在vscode的语法提示下多了一个<code>hump</code>的方法,不过我们只是声明, 并没有用js实现, 所以运行会报错。</p><h3 id="模块声明"><a href="#模块声明" class="headerlink" title="模块声明"></a>模块声明</h3><h4 id="什么是模块声明"><a href="#什么是模块声明" class="headerlink" title="什么是模块声明"></a>什么是模块声明</h4><p>npm下载的”包”自带了声明文件, 如果我们需要对其类型声明进行扩展就可以使用”<strong>declare module</strong>“语法。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br>app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$axios</span> = axios;<br></code></pre></td></tr></table></figure><p>功能上我们实现了”this.axios”,但是ts并不能自动推断出我们添加了axios”, 所以添加如下声明文件:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// global.d.ts</span><br><br><span class="hljs-comment">// axios的实例类型</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AxiosInstance</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 声明要扩充@vue/runtime-core包的声明.</span><br><span class="hljs-comment">// 这里扩充&quot;ComponentCustomProperties&quot;接口, 因为他是vue3中实例的属性的类型.</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;@vue/runtime-core&#x27;</span> &#123;<br>  <br>  <span class="hljs-comment">// 给`this.$http`提供类型</span><br>  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ComponentCustomProperties</span> &#123;<br>    <span class="hljs-attr">$axios</span>: <span class="hljs-title class_">AxiosInstance</span>;<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>这里扩充”<strong>ComponentCustomProperties</strong>“接口, 因为他是vue3中实例的属性的类型.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a href="https://juejin.cn/post/7008710181769084964">参考</a></h2><p>本文绝大部分内容来源于下面两篇文章</p><p><a href="https://juejin.cn/post/6844903993727008776">https://juejin.cn/post/6844903993727008776</a></p><p><a href="https://juejin.cn/post/7008710181769084964">https://juejin.cn/post/7008710181769084964</a></p>]]></content>
    
    
    <categories>
      
      <category>TS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么React官网那么快</title>
    <link href="/2022/08/08/%E4%B8%BA%E4%BB%80%E4%B9%88React%E5%AE%98%E7%BD%91%E9%82%A3%E4%B9%88%E5%BF%AB/"/>
    <url>/2022/08/08/%E4%B8%BA%E4%BB%80%E4%B9%88React%E5%AE%98%E7%BD%91%E9%82%A3%E4%B9%88%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="服务端渲染-SSR"><a href="#服务端渲染-SSR" class="headerlink" title="服务端渲染 SSR"></a>服务端渲染 SSR</h2><p>无论是服务端渲染还是客户端渲染，一开始都是要请求一个 <code>HTML</code> 文本，但是区别就在于这个文本是否已经被服务端组装好了</p><ul><li>客户端渲染还需要去下载和执行<code>Javascript</code>脚本之后才能得到我们想要的页面效果，所以速度会比服务端渲染慢很多</li><li>服务端渲染得到的<code>HTML</code>文档就已经组合好了对应的文本，浏览器请求到之后直接解析渲染出来即可，不需要再去下载和执行额外的<code>Javasript</code> 脚本，所以速度会比客户端渲染快很多</li></ul><p>下图是客户端渲染和服务端渲染的流程图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/610390beb91049e49c897392fe130d3d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="预加载-x2F-预处理资源"><a href="#预加载-x2F-预处理资源" class="headerlink" title="预加载&#x2F;预处理资源"></a>预加载&#x2F;预处理资源</h2><h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h3><p>关键字 <strong>preload</strong> 作为元素 <code>&lt;link&gt;</code> 的属性 <code>rel</code>的值，表示用户十分有可能需要在当前浏览中加载目标资源，所以<strong>浏览器必须预先获取和缓存对应资源</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;script&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/webpack-runtime-732352b70a6d0733ac95.js&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>好处就是让在当前页面中可能被访问到的资源提前加载但并不阻塞页面的初步渲染，进而提升性能。</p><blockquote><p>注意：使用 <code>preload</code>作为 <code>link</code>标签<code>rel</code>属性的属性值的话一定要记得在标签上添加 <code>as</code>属性，其属性值就是要预加载的内容类型</p></blockquote><h3 id="preconnect"><a href="#preconnect" class="headerlink" title="preconnect"></a>preconnect</h3><p><strong>preconnect</strong> 是提示浏览器用户可能需要来自目标域名的资源，因此<strong>浏览器可以通过抢先启动与该域名的连接</strong>来改善用户体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preconnect&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.google-analytics.com&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="dns-prefetch"><a href="#dns-prefetch" class="headerlink" title="dns-prefetch"></a>dns-prefetch</h3><p><strong>DNS-prefetch</strong> (<strong>DNS 预获取</strong>) 是尝试<strong>在请求资源之前解析域名</strong>。这可能是后面要加载的文件，也可能是用户尝试打开的链接目标。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.google-analytics.com&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="prefetch"><a href="#prefetch" class="headerlink" title="prefetch"></a>prefetch</h3><p><strong>prefetch</strong> 作为元素 的属性 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link%23attr-rel">rel</a> 的值，是为了提示浏览器，用户未来的浏览有可能需要加载目标资源，所以<strong>浏览器会事先获取和缓存对应资源</strong>，优化用户体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/page-data/docs/getting-started.html/page-data.json&quot;</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;fetch&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>什么时候使用：</strong></p><p><strong>当你的页面中具有可能跳转到其他页面的路由链接时</strong>，就可以使用<code>prefetch</code> 预请求对应页面的资源了。如果一个页面中路由链接太多，全部发一遍显然浪费流量，也不利于性能优化。</p><p>可以通过监听 <code>Link</code>元素，当其出现到可见区域时动态插入带有<code>prefetch</code>属性值的<code>link</code>标签到<code>HTML</code>文档中，从而去预加载对应路由页面的一些资源，这样当用户点击路由链接跳转过去时由于资源已经请求好所以页面加载会特别快。（<strong>懒加载思想</strong>）</p><h3 id="preload-和-prefetch-的区别"><a href="#preload-和-prefetch-的区别" class="headerlink" title="preload 和 prefetch 的区别"></a>preload 和 prefetch 的区别</h3><p>两者都用于提前获取和缓存对应资源</p><p>preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度</p><p>prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7128369638794231839">https://juejin.cn/post/7128369638794231839</a> 本文绝大部分内容来源于这篇文章</p>]]></content>
    
    
    <categories>
      
      <category>优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSR</tag>
      
      <tag>预加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实习记录</title>
    <link href="/2022/08/01/%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/08/01/%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h2><p>npm install 失败</p><p>将 package-lock.json 文件删去后，再 install 才成功</p><p>原因大概是团队中的 node 版本不同</p><p><strong><a href="https://juejin.cn/post/7078233610683170824">package-lock.json</a></strong></p><p>package-lock.json 会<strong>在 npm 更改 node_modules 目录树 或者 package.json 时自动生成</strong> ，它准确的描述了当前项目npm包的依赖树，并且在随后的安装中会根据 package-lock.json 来安装，保证是相同的一个依赖树，不考虑这个过程中是否有某个依赖有小版本的更新。（安装依赖时，优先 package-lock.json ，没有时再看 package.json）</p><p>它的产生就是来对整个依赖树进行版本固定的（锁死）。</p><p>注意，使用<code>cnpm install</code>时候，并不会生成 <code>package-lock.json</code> 文件，也不会根据 <code>package-lock.json</code> 来安装依赖包，还是会使用 <code>package.json</code> 来安装。</p><h2 id="修复漏洞"><a href="#修复漏洞" class="headerlink" title="修复漏洞"></a>修复漏洞</h2><p>修复上线前检测出的漏洞，主要是<strong>基于 DOM 的 XSS 攻击的安全隐患</strong>。</p><p><a href="https://blog.csdn.net/lgxzzz/article/details/125010336">https://blog.csdn.net/lgxzzz/article/details/125010336</a></p><p>相关插件 xss &#x2F; vue-xss(只支持 js) &#x2F; vue-dompurify-html</p><p>发现问题主要是因为使用了 v-html</p><p><strong>1.通过 vue-dompurify-html 插件 实现</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> vue-dompurify-<span class="hljs-selector-tag">html</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">import VueDOMPurifyHTML from &#x27;vue-dopurify-html&#x27;<br><br>app.use(VueDOMPurifyHTML)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">v-dompurify-html = <span class="hljs-string">&quot;rawHtml&quot;</span><br></code></pre></td></tr></table></figure><p><strong>2.通过 xss 插件实现</strong></p><p><a href="https://github.com/leizongmin/js-xss">https://github.com/leizongmin/js-xss</a></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> xss<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置白名单</span><br><span class="hljs-keyword">var</span> options = &#123;<br>    <span class="hljs-attr">whiteList</span>: &#123;<br>        <span class="hljs-attr">a</span>: [<span class="hljs-string">&quot;href&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>],<br>    &#125;,<br>&#125;<br><br><span class="hljs-comment">// 实例化</span><br>myxss = <span class="hljs-keyword">new</span> xss.<span class="hljs-title class_">FilterXSS</span>(options);<br><br><span class="hljs-comment">// 对需要转义的部分调用myxss.process()</span><br>html = myxss.<span class="hljs-title function_">process</span>(<span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="后台管理系统新增页面"><a href="#后台管理系统新增页面" class="headerlink" title="后台管理系统新增页面"></a>后台管理系统新增页面</h2><h3 id="曲库管理"><a href="#曲库管理" class="headerlink" title="曲库管理"></a>曲库管理</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于从后台管理系统将音乐资源导入数据库，从而显示在 APP 中。</p><h4 id="主要需求"><a href="#主要需求" class="headerlink" title="主要需求"></a>主要需求</h4><p>资源有三个级别：教材 &gt; 专辑 &gt; 单曲，每个级别都可以新增（上传）或删除。</p><p>输入框用于搜索教材，单选框用于固定乐器</p><p>可以下载教材到本地</p><h3 id="APP版本管理"><a href="#APP版本管理" class="headerlink" title="APP版本管理"></a>APP版本管理</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>用于记录与管理 APP 版本的迭代信息。</p><p>两个 APP ：调音器 &#x2F; 好乐器</p><p>两个 os：ios &#x2F; 安卓</p><h4 id="主要需求-1"><a href="#主要需求-1" class="headerlink" title="主要需求"></a>主要需求</h4><p>新增版本</p><p>查看版本详情</p><h3 id="题库管理页面迭代"><a href="#题库管理页面迭代" class="headerlink" title="题库管理页面迭代"></a>题库管理页面迭代</h3><h2 id="首页新增陪练总览部分"><a href="#首页新增陪练总览部分" class="headerlink" title="首页新增陪练总览部分"></a>首页新增陪练总览部分</h2><p>查看陪练的用户信息以及答题信息</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>技术上没什么太难的地方</p><p>但是当时有两个问题花了我比较久的时间。</p><p>一个问题是在上传资源的时候，资源会丢失，我找了很久问题的原因，后面问了 leader 才知道是被平安拦截掉了，平安的安全措施比较严格，不能从内网向外网传稍大的资源。这个问题要完全解决非常麻烦，可能架构上要改，所以就没有从技术层面去解决，而是在上传资源的时候切到外网。</p><h2 id="音乐基础新增试唱功能"><a href="#音乐基础新增试唱功能" class="headerlink" title="音乐基础新增试唱功能"></a>音乐基础新增试唱功能</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>一种新题型，原先的题型主要都是选择题。</p><h3 id="主要需求-2"><a href="#主要需求-2" class="headerlink" title="主要需求"></a>主要需求</h3><p>给一个谱子，用户点击 button 倒计时后开始清唱，用户开始唱的时候会录音，同时会有一个小方块来提示用户唱到哪一个音符了。这个小方块会随着时间移动，当它移动到某个音符的上面，就说明应该唱到这个音了。唱完之后会将录音传给后端，使用算法比对进行打分，然后返回一个分数给用户。</p><p>两种谱子：五线谱 &#x2F; 简谱</p><p>两种谱子给的资源不一致</p><p>五线谱有 xml 文件，将其转为 json 后，解构获得有效信息，主要是每个音符的 起始时间、终止时间、和在谱子中的位置</p><p>简谱没有 xml 文件，因此需要 解析 mid 文件来获取每个音符的时间信息，而位置信息要根据谱子来计算，因为谱子的制定是有规则的，谱子里的距离和时间是线性的，我们可以通过音符的时间信息计算出他们的位置。</p><p>而有每个音符触发的时间有音符在谱子中所处的位置，我们就可以控制方块在正确的时间处于正确的位置上来提醒用户。</p><h3 id="零碎的需求"><a href="#零碎的需求" class="headerlink" title="零碎的需求"></a>零碎的需求</h3><p>五线谱 &#x2F; 简谱 的切换</p><p>播放录音</p><p>播放范唱（midi，人声）</p><p>控制速度</p><p>节拍器</p><h3 id="难点-1"><a href="#难点-1" class="headerlink" title="难点"></a>难点</h3><p>控制方块的位置，花了些时间计算</p><p>对于 midi 文件的理解与处理，npm 上找了很多包来解析 midi 和播放 midi</p><p>节拍器</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>情景，任务，行动，结果</strong></p><p>实习期间，我完成的最主要的一个工作是在我们已有的一个app上新增一个功能，首先介绍一下这个app，这个app一方面它是一个调音器，是一个乐器的辅助工具；另一方面，它是一个音乐题库，这个题库里面只有比较老套的选择判断题，我的任务就是要给这个题库加一种新题型，题干是一首歌的谱子(可以选择五线谱和简谱），题目要求用户跟着谱子哼唱，前端会进行录音，在哼唱完毕后传给后端，后端结合算法做一个评分，再返回给前端。这是整个的一个流程。这个流程其实很简单，有难度的是一些辅助功能。</p><p>1.在录音时谱子上面会有一个指示器，实时指向当前应该被唱到的音符，避免用户漏拍子或者唱着唱着不知道唱到哪了。</p><p>2.实现了一个类似于全民k歌的功能，首先会根据谱子的数据利用svg绘制一个音高线图，这个音高线图会随着时间向左移动，用户在哼唱时会有一个小球根据用户哼唱的音高上下跳动，用于辅助用户控制自己的音准。</p><p>3.实现了一个节拍器控件，节拍器就是在录音时会根据谱子规律的发出哒哒哒哒哒哒的音效，用来辅助用户更好地跟紧节奏。这个问题我想到两种解决方案，一是利用一个很短的音频文件，每当指示器指到一个新的音符就播放它。二是利用 H5 的 Web Audio API 的 Audio Context 来创造声音，原理就是创建振荡器，制定波形和频率，然后将其和电脑的扬声器连接就可以了。因为声音本质就是通过震动产生的嘛。考虑到我没有现成的音频资源，也秉持着不额外增加资源的原则，就选择了第二种方案。在测试第二种方案的时候也遇到了问题，就是 Audio Context 所创建的音频并不是一个可以被反复利用的音频，它会在播放完毕后被销毁。而因为在我们的场景下需要短时间反复播放该音频，反复的创建销毁实例肯定不是一个好的选择，而且 Audio Context 因为需要声卡中的资源，所以硬件上会有限制，不能同时创建太多的音频。我最后的解决方案是在开始录音的时候创建一个不设终止时间的音频，但是断开和扬声器的连接，根据谱子需要打节拍的时候就短暂连接上音频发出一声哒，直到录音终止再销毁这个音频实例，这样我们每次录音就只需要创建一个音频。</p><p>这是几个最主要的功能，还有一些零零散散的比较简单的，比如说控制录音时的速度控件，这个速度实际会影响三个部分，谱子上的指示器移动的速度，音高线图移动的速度，还有节拍器哒哒哒的速度。我是将速度转成了时间，因为一首歌的时间是固定的嘛，每个音符也是固定的，所以不管是哪个部分，到了规定的时间就去做规定的事情。</p><h3 id="关于封装组件"><a href="#关于封装组件" class="headerlink" title="关于封装组件"></a>关于封装组件</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>按功能和位置分（主要是按功能）</p><img src="实习记录/image-20221020134042416.png" alt="image-20221020134042416" style="zoom:67%;" /><h4 id="引入并使用子组件"><a href="#引入并使用子组件" class="headerlink" title="引入并使用子组件"></a>引入并使用子组件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Tempo</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Tempo</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Tempo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Testing&#x27;</span>,<br>    <span class="hljs-attr">components</span>: &#123;<br>        <span class="hljs-title class_">SingQuestion</span>,<br>        <span class="hljs-title class_">Tempo</span>,<br>        <span class="hljs-title class_">ChangeQuestion</span>,<br>        ...<br>    &#125;<br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="学习到了什么"><a href="#学习到了什么" class="headerlink" title="学习到了什么"></a>学习到了什么</h2><ul><li><p>git</p><p>git add .</p><p>git commit -m “…”</p><p>git push</p><p>git stash</p><p>git stash pop</p></li><li><p>vue3 + ts 实操</p><ul><li>vue3<ul><li>组件间通信（全局事件总线 emitBus 较多）</li><li>nextTick</li></ul></li><li>ts<ul><li>interface</li></ul></li></ul></li><li><p>代码规范</p><ul><li>宏观上</li></ul><p>代码分块明确，同一功能的代码尽量放在一起提升可维护性，当然 vue3 的组合式 api 意义就在这里；</p><p>抽离函数逻辑，不要把一块东西写的太复杂。同样的，组件也是；</p><ul><li>微观上</li></ul><p>变量命名不要太长、要尽量能够顾名思义；</p><p>减少魔法数字的出现，用变量替代；</p><p>项目开启了 eslint，对于是否书写分号这些细节也有要求；</p></li><li><p>独立解决未知问题的能力</p><ul><li>领域未知</li></ul><p>之前从未接触过音乐领域，乐理也是一窍不通。但在做需求的过程中需要一定的音乐基础，主要是在对于数据的理解上（比如数据中时间的单位我一开始以为是 ms，后面才知道是跟节拍有关，那么要将节拍转成 s，又涉及一个新的名词叫 bpm）以及一些插件的使用上（如 midi 音频文件的播放插件 &#x2F; 解析 midi 的插件 &#x2F; 读取用户声音频率的插件），读取到频率后怎么转成数字音高，数字音高怎么转成符号音高。</p><ul><li>从未接触过的需求</li></ul><p>刚拿到需求还是比较迷茫的，因为里面有一些东西是之前没有接触过的。</p><p>通过努力一步一步的解决了</p></li><li><p>沟通能力</p><ul><li>与产品和后端的沟通非常重要</li></ul><p>理解有参差的话会事倍功半，在写后台管理项目时就遇到了问题</p><ul><li>不懂要问</li></ul><p>不要僵着浪费时间</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>实习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解ES6</title>
    <link href="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    <url>/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/</url>
    
    <content type="html"><![CDATA[<h1 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721192756233.png" class="" title="image-20220721192756233"><p>没什么新的东西 就不写了</p><p>不知道为什么这本书后面都用的 var</p><h1 id="字符串与正则表达式"><a href="#字符串与正则表达式" class="headerlink" title="字符串与正则表达式"></a>字符串与正则表达式</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721192733715.png" class="" title="image-20220721192733715"><h2 id="更好的-Unicode-支持"><a href="#更好的-Unicode-支持" class="headerlink" title="更好的 Unicode 支持"></a>更好的 Unicode 支持</h2><h3 id="关于-Unicode"><a href="#关于-Unicode" class="headerlink" title="关于 Unicode"></a><a href="https://www.cnblogs.com/yongG/p/12153646.html">关于 Unicode</a></h3><p>Unicode使用16位二进制来存储文字。我们将一个16位的二进制编码叫做一个码元（Code Unit），Unicode编码范围在0 - 2^16。也就是我们所说的占一个字节。</p><p>由于技术的发展，Unicode对文字编码进行了扩展，将某些文字扩展到了32位（占用两个码元），并且，将某个文字对应的二进制数字叫做码点（Code Point），Unicode编码范围在0 - 2^32，占2个字节。</p><p>特别要注意，码点可以是一个码元，也可以是两个码元。</p><p>字符串的length属性返回的是码元。所以在对一些字符串如果要处理长度的时候要注意这一点。</p><p><strong>ES6 为了支持 Unicode 的发展也新增了一些方法</strong></p><h3 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h3><p>可以在给定字符串中按位置提取 Unicode 代码点。该方法接受的是<strong>码元位置</strong>而非字符位置，并返回一个整数值。</p><p><strong>charCodeAt 的优化版</strong></p><p>charCodeAt是根据码元来匹配，codePointAt是根据码点来进行匹配的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;𘚠a&quot;</span> ;<span class="hljs-comment">// 特殊字符显示不出来</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 55329</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 56992</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 97</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 100000</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 56992</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 97</span><br></code></pre></td></tr></table></figure><p><strong>判断字符包含了一个还是两个码元</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 16 位字符的上边界用十六进制表示就是 FFFF ，因此任何大于该数字的代码点必须用两个码元（共 32 位）来表示。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">is32Bit</span>(<span class="hljs-params">c</span>) &#123;<br>    <span class="hljs-keyword">return</span> c.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>) &gt; <span class="hljs-number">0xFFFF</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>String.fromCodePoint</strong></p><p>codePointAt() 的逆操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCodePoint</span>(<span class="hljs-number">134071</span>))   <span class="hljs-comment">// 𠮷</span><br></code></pre></td></tr></table></figure><p>codePointAt &lt;—&gt; fromCodePoint</p><p>charCodeAt &lt;—&gt; fromCharCode</p><h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h3><p>开发国际化应用时，这个方法很重要</p><p>在比较字符串时，必须被标准化为同一种形式</p><h3 id="正则表达式-u-标志"><a href="#正则表达式-u-标志" class="headerlink" title="正则表达式 u 标志"></a>正则表达式 u 标志</h3><p>正则表达式假定单个字符由一个16位的码元表示。为了解决这个问题，ES6 定义了用于处理 Unicode 的 u 标志</p><p>当一个正则表达式设置了 u 标志后看，工作表模式将切换到针对字符，而不是针对码元</p><p><strong>计算码点数量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">codePointLength</span>(<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = text.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[\s\S]/gu</span>)<br>    <span class="hljs-keyword">return</span> result ? result.<span class="hljs-property">length</span> : <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>判断是否支持 u 标志</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasRegExpU</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> pattern = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串的其他改动"><a href="#字符串的其他改动" class="headerlink" title="字符串的其他改动"></a>字符串的其他改动</h2><h3 id="识别子字符串的方法"><a href="#识别子字符串的方法" class="headerlink" title="识别子字符串的方法"></a>识别子字符串的方法</h3><p><strong>includes()</strong> 方法，在给定文本存在于字符串中的任意位置时会返回 true ，否则返回false ；</p><p><strong>startsWith()</strong> 方法，在给定文本出现在字符串起始处时返回 true ，否则返回 false ；</p><p><strong>endsWith()</strong> 方法，在给定文本出现在字符串结尾处时返回 true ，否则返回 false 。</p><p>每个方法都接受两个参数：<strong>需要搜索的文本</strong>，以及<strong>可选的搜索起始位置索引</strong>。</p><p>当提供了第二个参数时， includes() 与 startsWith() 方法会从该索引位置开始尝试匹配；而<strong>endsWith() 方法会将字符串长度减去该参数</strong>，以此为起点开始尝试匹配。</p><p>当第二个参数未提供时， includes() 与 startsWith() 方法会从字符串起始处开始查找，而 endsWith() 方法则从尾部开始。实际上，第二个参数减少了搜索字符串的次数。以下是使用这些方法的演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&quot;Hello world!&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;Hello&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;!&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;o&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;o&quot;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;world!&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;x&quot;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>若你需要找到它们在另一个字符串中的确切位置，则需要使用 indexOf() 和 lastIndexOf() 。</strong></p><p>如果向 startsWith() 、 endsWith() 或 includes() 方法传入了正则表达式,会抛出错误。</p><p>而 indexOf() 以及 lastIndexOf() 会将正则表达式转换为字符串并搜索它。</p><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>ES6 还为字符串添加了一个 repeat() 方法，它接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;x&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// &quot;xxx&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;hellohello&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;abc&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;abcabcabcabc&quot;</span><br></code></pre></td></tr></table></figure><h2 id="正则表达式的其他改动"><a href="#正则表达式的其他改动" class="headerlink" title="正则表达式的其他改动"></a>正则表达式的其他改动</h2><h3 id="y-标志"><a href="#y-标志" class="headerlink" title="y 标志"></a>y 标志</h3><p>y 标志影响正则表达式搜索时的粘连（ sticky ）属性，它表示从正则表达式的 lastIndex 属性值的位置开始检索字符串中的匹配字符。如果在该位置没有匹配成功，那么正则表达式将停止检索</p><h3 id="复制正则表达式"><a href="#复制正则表达式" class="headerlink" title="复制正则表达式"></a>复制正则表达式</h3><p>允许复制正则表达式时修改标志</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re1 = <span class="hljs-regexp">/ab/i</span>,<br><span class="hljs-comment">// ES5 中会抛出错误, ES6 中可用</span><br>re2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(re1, <span class="hljs-string">&quot;g&quot;</span>);<span class="hljs-comment">// 如果没有第二个参数, re2 就会拥有与 re1 相同的标志。</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &quot;/ab/i&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re2.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &quot;/ab/g&quot;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;ab&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;ab&quot;</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;AB&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;AB&quot;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="flags-属性"><a href="#flags-属性" class="headerlink" title="flags 属性"></a>flags 属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/ab/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re.<span class="hljs-property">source</span>); <span class="hljs-comment">// &quot;ab&quot; ES5就有</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re.<span class="hljs-property">flags</span>); <span class="hljs-comment">// &quot;g&quot;</span><br></code></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p><strong>模板字符串解决了什么问题：</strong></p><p>多行字符串：针对多行字符串的形式概念；</p><p>基本的字符串格式化：将字符串部分替换为已存在的变量值的能力；</p><p>HTML 转义：能转换字符串以便将其安全插入到 HTML 中的能力。</p><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = <span class="hljs-string">`Multiline</span><br><span class="hljs-string">string`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <br><span class="hljs-comment">// &quot;Multiline</span><br><span class="hljs-comment">// string&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">length</span>); <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure><p>反引号之内的所有空白符都是字符串的一部分，因此需要留意缩进</p><p>如果让多行文本保持合适的缩进很重要，考虑将多行模板字面量的第一行空置并在此后进行缩进</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> html = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;div&gt;</span><br><span class="hljs-string">&lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="hljs-string">&lt;/div&gt;`</span>.<span class="hljs-title function_">trim</span>();<br></code></pre></td></tr></table></figure><h3 id="制造替代位"><a href="#制造替代位" class="headerlink" title="制造替代位"></a>制造替代位</h3><p>${任意表达式}</p><p>模板字面量本身也是 JS 表达式，因此可嵌套</p><h3 id="标签化模板"><a href="#标签化模板" class="headerlink" title="标签化模板"></a>标签化模板</h3><p>一个模板标签（ template tag ）能对模板字面量进行转换并返回最终的字符串值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = tag<span class="hljs-string">`Hello world`</span>;<br></code></pre></td></tr></table></figure><p>标签（ tag ）是函数，它被调用时接收需要处理的模板字面量数据。标签所接收的数据被划分为独立片段，并且必须将它们组合起来以创建结果。第一个参数是个数组，包含被 JS 解释过的字面量字符串，随后的参数是每个替换位的解释值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span>(<span class="hljs-params">literals, ...substitutions</span>) &#123;<br>    <span class="hljs-comment">// 返回一个字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内置的标签 String.raw()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message1 = <span class="hljs-string">`Multiline\nstring`</span>,<br>message2 = <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`Multiline\nstring`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message1);<br><span class="hljs-comment">// &quot;Multiline</span><br><span class="hljs-comment">// string&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message2); <span class="hljs-comment">// &quot;Multiline\\nstring&quot;</span><br></code></pre></td></tr></table></figure><p>内部实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">raw</span>(<span class="hljs-params">literals, ...substitutions</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">// 仅使用 substitution 的元素数量来进行循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; substitutions.<span class="hljs-property">length</span>; i++) &#123;<br>        result += literals.<span class="hljs-property">raw</span>[i]; <span class="hljs-comment">// 改为使用原始值</span><br>        result += substitutions[i];<br>    &#125;<br>    <span class="hljs-comment">// 添加最后一个字面量</span><br>    result += literals.<span class="hljs-property">raw</span>[literals.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">let</span> message = raw<span class="hljs-string">`Multiline\nstring`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// &quot;Multiline\\nstring&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">length</span>); <span class="hljs-comment">// 17</span><br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220721204939237.png" class="" title="image-20220721204939237"><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>参数默认值的存在触发了 arguments 对象与具名参数的分离</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 非严格模式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mixArgs</span>(<span class="hljs-params">first, second = <span class="hljs-string">&quot;b&quot;</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>);          <span class="hljs-comment">// 1</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// true  </span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// false</span><br>    first = <span class="hljs-string">&quot;c&quot;</span>;<br>    second = <span class="hljs-string">&quot;d&quot;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// false</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second === <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// false</span><br>&#125;<br><span class="hljs-title function_">mixArgs</span>(<span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure><p>参数默认值可以使用表达式</p><p>参数默认值存在暂时性死区</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">first = second, second</span>) &#123;<br>    <span class="hljs-keyword">return</span> first + second;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 抛出错误</span><br></code></pre></td></tr></table></figure><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>…具名参数</p><p>是包含传递给函数的其余参数的一个数组</p><p>函数的 length 属性用于指示剧名参数的数量，而剩余参数对其毫无影响</p><p><strong>剩余参数的限制条件：</strong></p><p>一、函数只能有一个剩余参数，并且它必须被放在最后。</p><p>二、剩余参数不能在对象字面量的 setter 属性中使用。（对象字面量的 setter 被限定只能使用单个参数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> object = &#123;<br><span class="hljs-comment">// 语法错误：不能在 setter 中使用剩余参数</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">...value</span>) &#123;<br>        <span class="hljs-comment">// 一些操作</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>设计剩余参数是为了替代 ES 中的 arguments</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkArgs</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args.<span class="hljs-property">length</span>);<span class="hljs-comment">// 2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>);<span class="hljs-comment">// 2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args[<span class="hljs-number">0</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);<span class="hljs-comment">// a a</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args[<span class="hljs-number">1</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<span class="hljs-comment">// b b</span><br>&#125;<br><span class="hljs-title function_">checkArgs</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>拓展运算符</strong></p><p>拓展运算符常和剩余参数一起使用</p><p>以一个例子为例，查找数组最大值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES5及以前</span><br><span class="hljs-keyword">let</span> values = [<span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">75</span>, <span class="hljs-number">100</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Math</span>, values)); <span class="hljs-comment">// 100</span><br><br><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">let</span> values = [<span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">75</span>, <span class="hljs-number">100</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...values)); <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><h2 id="ES6-的名称属性"><a href="#ES6-的名称属性" class="headerlink" title="ES6 的名称属性"></a>ES6 的名称属性</h2><p>匿名函数使得调试困难，因此 ES6 给所有函数添加了 name 属性。name 仅用于在调试时获得函数的相关信息，不能获取对函数的引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">var</span> doAnotherThing = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doSomething.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;doSomething&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doAnotherThing.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;doAnotherThing&quot;</span><br></code></pre></td></tr></table></figure><p><strong>特殊情况</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> doSomething = <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingElse</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">firstName</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Nicholas&quot;</span><br>&#125;,<br>    <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doSomething.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;doSomethingElse&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">sayName</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;sayName&quot;</span><br><span class="hljs-keyword">var</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(person, <span class="hljs-string">&quot;firstName&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">get</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;get firstName&quot;</span><br></code></pre></td></tr></table></figure><p>getter 函数会有 get 前缀，setter 函数会有 set 前缀</p><p>getter 与 setter 函数都必须使用 Object.getOwnPropertyDescriptor 来检索</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> doSomething = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doSomething.<span class="hljs-title function_">bind</span>().<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;bound doSomething&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>()).<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;anonymous&quot;</span><br></code></pre></td></tr></table></figure><p>使用 bind() 创建的函数会有 bound 前缀</p><p>使用 Function 构造器创建的函数会有 anonymous 前缀</p><h2 id="明确函数的双重用途"><a href="#明确函数的双重用途" class="headerlink" title="明确函数的双重用途"></a>明确函数的双重用途</h2><p>一般函数 和 构造函数(new)，构造函数名首字母大写</p><p>JS 为函数提供了两个内部方法，[[Call]] 和 [[Construct]]</p><p>函数未使用 new 调用时，[[call]] 方法执行，运行函数体</p><p>函数使用 new 调用时，[[Construct]] 方法调用，创建一个新的对象，并且以该对象为 this 执行函数体</p><p>拥有 [[Constructor]] 方法的函数被称为构造器</p><p><strong>判断调用的是什么方法</strong></p><p>当 [[Constructor]] 被调用时，new.target 为 new 调用的构造函数</p><p>当 [[Call]] 被调用时，new.target 为 undefiend</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>)<span class="hljs-comment">// [Function: Person]</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 使用 new</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You must use new with Person.&quot;</span>)<br>    &#125;   <br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><span class="hljs-keyword">var</span> notAPerson = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">&quot;Michael&quot;</span>); <span class="hljs-comment">// 出错！</span><br></code></pre></td></tr></table></figure><h2 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h2><p>块级函数会被提升到所在代码块的顶部</p><p>而使用 let 的函数表达式不会</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>没有 this 、 super 、 arguments ，也没有 new.target 绑定。this 、 super 、arguments 、以及函数内部的 new.target 的值由所在的、最靠近的非箭头函数来决定。</p><p>不能被使用 new 调用： 箭头函数没有 [[Construct]] 方法，因此不能被用为构造函数，使用 new 调用箭头函数会抛出错误。</p><p>没有原型： 既然不能对箭头函数使用 new ，那么它也不需要原型，也就是没有prototype 属性。</p><p>不能更改 this ： this 的值在函数内部不能被修改，在函数的整个生命周期内其值会保持不变。</p><p>没有 arguments 对象： 既然箭头函数没有 arguments 绑定，你必须依赖于具名参数或剩余参数来访问函数的参数。</p><p>不允许重复的具名参数： 箭头函数不允许拥有重复的具名参数，无论是否在严格模式下；而相对来说，传统函数只有在严格模式下才禁止这种重复。</p><p>箭头函数也拥有 name 属性，并且遵循与其他函数相同的规则</p><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>这是一项引擎优化，改变了尾部调用的系统。</p><p>尾调用（tail call ）指的是调用函数的语句是另一个函数的最后语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">doSomethingElse</span>(); <span class="hljs-comment">// 尾调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 ES5 引擎中实现的尾调用，其处理就像其他函数调用一样：<strong>一个新的栈帧</strong>（ stack frame）被创建并推到调用栈之上，用于表示该次函数调用。这意味着<strong>之前每个栈帧都被保留在内存中，当调用栈太大时会出问题。</strong></p><p>ES6 在严格模式下力图为特定尾调用减少调用栈的大小（非严格模式的尾调用则保持不变）。<strong>当满足以下条件时，尾调用优化会清除当前栈帧并再次利用它，而不是为尾调用创建新的栈帧</strong>：</p><ol><li>尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）；</li><li>进行尾调用的函数在尾调用返回结果后不能做额外操作；</li><li>尾调用的结果作为当前函数的返回值。</li></ol><p><strong>尾调用优化主要是用在递归中</strong></p><p>不考虑尾调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 未被优化：在返回之后还要执行乘法</span><br>    <span class="hljs-keyword">return</span> n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑尾调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 未被优化：在返回之后还要执行乘法</span><br>        <span class="hljs-keyword">return</span> n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在重写的 factorial() 函数中，添加了第二个参数 p ，其默认值为 1 。 p 参数保存着前一次乘法的结果，因此下一次的结果就能在进行函数调用之前被算出。</p><p><strong>尾调用优化是你在书写任意递归函数时都需要考虑的因素</strong>，因为它能提供显著的性能提升，尤其是被应用到计算复杂度很高的函数时。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220722162911548.png" class="" title="image-20220722162911548"><h2 id="需计算属性名"><a href="#需计算属性名" class="headerlink" title="需计算属性名"></a>需计算属性名</h2><p>方括号允许你将变量或字符串字面量指定为属性名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 变量</span><br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&quot;last name&quot;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-string">&quot;first name&quot;</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    [lastName]: <span class="hljs-string">&quot;Zakas&quot;</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;first name&quot;</span>]); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[lastName]); <span class="hljs-comment">// &quot;Zakas&quot;</span><br><br><span class="hljs-comment">// 字符串字面量</span><br><span class="hljs-keyword">var</span> suffix = <span class="hljs-string">&quot; name&quot;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    [<span class="hljs-string">&quot;first&quot;</span> + suffix]: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    [<span class="hljs-string">&quot;last&quot;</span> + suffix]: <span class="hljs-string">&quot;Zakas&quot;</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;first name&quot;</span>]); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;last name&quot;</span>]); <span class="hljs-comment">// &quot;Zakas&quot;</span><br></code></pre></td></tr></table></figure><h2 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h2><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>Object.is() 用来判断两个值是否相等，修复了 &#x3D;&#x3D;&#x3D; 的一些问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-number">0</span> == -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(+<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>用于混入对象</p><p>Object.assign() 方法接受任意数量的供应者，而接收者会按照供应者在参数中的顺序来依次接收它们的属性。这意味着在接收者中，第二个供应者的属性可能会覆盖第一个供应者的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> receiver = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(receiver,<br>    &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;js&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;file.js&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;css&quot;</span><br>    &#125;<br>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver.<span class="hljs-property">type</span>); <span class="hljs-comment">// &quot;css&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;file.js&quot;</span><br></code></pre></td></tr></table></figure><p><strong>由于 Object.assign() 使用赋值运算符，供应者的访问器属性就会转变成接收者的数据属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> receiver = &#123;&#125;,<br>supplier = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;file.js&quot;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(receiver, supplier);<br><br><span class="hljs-keyword">var</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(receiver, <span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">value</span>); <span class="hljs-comment">// &quot;file.js&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">get</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h2 id="自有属性的枚举顺序"><a href="#自有属性的枚举顺序" class="headerlink" title="自有属性的枚举顺序"></a>自有属性的枚举顺序</h2><p>ES6 则严格定义了对象自有属性在被枚举时返回的顺序。</p><p>对 Object.getOwnPropertyNames() 与 Reflect.ownKeys 如何返回属性造成了影响，还同样影响了 Object.assign() 处理属性的顺序。</p><p><strong>自有属性枚举时基本顺序如下：</strong></p><ol><li>所有的数字类型键，按升序排列。</li><li>所有的字符串类型键，按被添加到对象的顺序排列。</li><li>所有的符号类型（详见第六章）键，也按添加顺序排列。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span><br>&#125;;<br><br>obj.<span class="hljs-property">d</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// &quot;012acbd&quot;</span><br></code></pre></td></tr></table></figure><p>数值类型的键会被合并并排序；字符串类型的键会跟在数值类型的键之后</p><p>for-in 循环的枚举顺序仍未被明确规定，因为并非所有的 JS 引擎都采用相同的方式。而 Object.keys() 和 JSON.stringify() 也使用了与 for-in 一样的枚举顺序。</p><h2 id="更强大的原型"><a href="#更强大的原型" class="headerlink" title="更强大的原型"></a>更强大的原型</h2><h3 id="修改对象的原型"><a href="#修改对象的原型" class="headerlink" title="修改对象的原型"></a><strong>修改对象的原型</strong></h3><p>直到 ES5 为止， JS 编程最重要的假定之一就是对象的原型在初始化完成后会保持不变。</p><p>ES6 通过添加 <strong>Object.setPrototypeOf()</strong> 方法而改变了这种假定，此方法允许你修改任意指定对象的原型。</p><p>它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h3><p>super 使得在对象原型上的功能调用变得更容易</p><p>super 是指向当前对象的原型的一个指针，实际上就是 Object.getPrototypeOf(this) 的值</p><h2 id="正式的“方法”定义"><a href="#正式的“方法”定义" class="headerlink" title="正式的“方法”定义"></a>正式的“方法”定义</h2><p>在 ES6 之前，“方法”的概念从未被正式定义，它此前仅指对象的函数属性（而非数据属性）。</p><p>ES6 则正式做出了定义：<strong>方法是一个拥有 [[HomeObject]] 内部属性的函数</strong>，此内部属性指向该方法所属的对象。</p><p>任何对 super 的引用都会使用 [[HomeObject]] 属性来判断要做什么。第一步是在 [[HomeObject]] 上调用 Object.getPrototypeOf() 来获取对原型的引用；接下来，在该原型上查找同名函数；最后，创建 this 绑定并调用该方法。</p><h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220722201416156.png" class="" title="image-20220722201416156"><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p><strong>当使用解构来配合 var 、 let 或 const 来声明变量时，必须提供初始化器</strong>（即等号右边的值）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 语法错误！</span><br><span class="hljs-keyword">var</span> &#123; type, name &#125;;<br><br><span class="hljs-comment">// 语法错误！</span><br><span class="hljs-keyword">let</span> &#123; type, name &#125;;<br><br><span class="hljs-comment">// 语法错误！</span><br><span class="hljs-keyword">const</span> &#123; type, name &#125;;<br></code></pre></td></tr></table></figure><p><strong>解构赋值表达式的值为表达式右侧（在 &#x3D; 之后）的值。</strong></p><p>也就是说在任何期望有个值的位置都可以使用解构赋值表达式。例如，传递值给函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> node = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Identifier&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span><br>&#125;,<br>type = <span class="hljs-string">&quot;Literal&quot;</span>,<br>name = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outputInfo</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value === node); <span class="hljs-comment">// true</span><br>&#125;<br><br><span class="hljs-title function_">outputInfo</span>(&#123; type, name &#125; = node);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(type); <span class="hljs-comment">// &quot;Identifier&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// &quot;foo&quot;</span><br></code></pre></td></tr></table></figure><p><strong>可以给默认值，也可以给不同的变量名</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> node = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Identifier&quot;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">type</span>: localType, <span class="hljs-attr">name</span>: localName = <span class="hljs-string">&quot;bar&quot;</span>&#125; = node<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localType); <span class="hljs-comment">// &quot;Identifier&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localName); <span class="hljs-comment">// &quot;bar&quot;</span><br></code></pre></td></tr></table></figure><p><strong>嵌套解构</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> node = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Identifier&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,<br>        <span class="hljs-attr">loc</span>: &#123;<br>        <span class="hljs-attr">start</span>: &#123;<br>            <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">column</span>: <span class="hljs-number">1</span><br>        &#125;,<br>        <span class="hljs-attr">end</span>: &#123;<br>            <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">column</span>: <span class="hljs-number">4</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 提取 node.loc.start</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">loc</span>: &#123; <span class="hljs-attr">start</span>: localStart &#125;&#125; = node;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localStart.<span class="hljs-property">line</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localStart.<span class="hljs-property">column</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>与对象差别不大，也有默认值、嵌套解构等</p><p><strong>可以用来交换两个值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[a,b] = [b,a]<br></code></pre></td></tr></table></figure><p><strong>剩余项</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [ <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span> ];<br><span class="hljs-keyword">let</span> [ firstColor, ...restColors ] = colors;<span class="hljs-comment">// restColors 是一个数组</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstColor); <span class="hljs-comment">// &quot;red&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restColors.<span class="hljs-property">length</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restColors[<span class="hljs-number">0</span>]); <span class="hljs-comment">// &quot;green&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restColors[<span class="hljs-number">1</span>]); <span class="hljs-comment">// &quot;blue&quot;</span><br></code></pre></td></tr></table></figure><p><strong>克隆数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在 ES6 中克隆数组</span><br><span class="hljs-keyword">let</span> colors = [ <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span> ];<br><span class="hljs-keyword">let</span> [ ...clonedColors ] = colors;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clonedColors); <span class="hljs-comment">//&quot;[red,green,blue]&quot;</span><br></code></pre></td></tr></table></figure><h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setCookie</span>(<span class="hljs-params">name, value,</span><br><span class="hljs-params">    &#123;</span><br><span class="hljs-params">        secure = <span class="hljs-literal">false</span>,</span><br><span class="hljs-params">        path = <span class="hljs-string">&quot;/&quot;</span>,</span><br><span class="hljs-params">        domain = <span class="hljs-string">&quot;example.com&quot;</span>,</span><br><span class="hljs-params">        expires = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.now() + <span class="hljs-number">360000000</span>)</span><br><span class="hljs-params">    &#125; = &#123;&#125;</span><br><span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>此代码中参数解构给每个属性都提供了默认值</strong>，所以你可以避免检查指定属性是否已被传入（以便在未传入时使用正确的值）。<strong>而整个解构的参数同样有一个默认值，即一个空对象</strong>，令该参数成为可选参数。</p><h1 id="Set-与-Map"><a href="#Set-与-Map" class="headerlink" title="Set 与 Map"></a>Set 与 Map</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220724205823067.png" class="" title="image-20220724205823067"><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="判断值是否重复"><a href="#判断值是否重复" class="headerlink" title="判断值是否重复"></a>判断值是否重复</h3><p>Set 和 Map 不会使用强制类型转换来判断值是否重复，而是使用 Object.is() 方法（唯一例外时 +0 与 -0 被判断为相等)</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a><strong>forEach()</strong></h3><p>forEach() 方法会被传递一个回调函数，该回调接受三个参数：</p><ol><li>Set 中下个位置的值；</li><li>Set 中下个位置的键；</li><li>目标 Set 自身。</li></ol><p>因为 Set 中 每一项同时认定为键与值，因此 1 和 2 是相同的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, ownerSet</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot; &quot;</span> + value);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ownerSet === set);<br>&#125;);<br><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-literal">true</span><br><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>如果想在回调函数中使用 this ，你可以给 forEach() 传入一个 this 值作为第二个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-keyword">let</span> processor = &#123;<br>    <span class="hljs-title function_">output</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;,<br>    <span class="hljs-title function_">process</span>(<span class="hljs-params">dataSet</span>) &#123;<br>        dataSet.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">output</span>(value);<br>        &#125;, <span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;;<br>processor.<span class="hljs-title function_">process</span>(set);<br></code></pre></td></tr></table></figure><h2 id="Weak-Set"><a href="#Weak-Set" class="headerlink" title="Weak Set"></a>Weak Set</h2><p>只允许存储对象弱引用，不能存储基本类型。add(基本类型)会报错，has()或delete()会返回 false</p><p>Weak Set 不可迭代，不能用于 for-of 循环，没有 keys() 与 values() 方法，没有 forEach()，没有 size 属性</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map-的初始化"><a href="#Map-的初始化" class="headerlink" title="Map 的初始化"></a>Map 的初始化</h3><p><strong>你能将数组传递给 Map 构造器，以便使用数据来初始化一个 Map</strong> 。该<strong>数组中的每一项也必须是数组</strong>，内部数组的首个项会作为键，第二项则为对应值。因此整个Map 就被这些双项数组所填充。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>], [<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">25</span>]]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;age&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;age&quot;</span>)); <span class="hljs-comment">// 25</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h2 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h2><p>所有键都必须是对象，都是弱引用，不会干扰垃圾回收。</p><p>没有 size 属性，没有 clear() 方法</p><p><strong>实际应用：在对象实例中存储私有数据</strong></p><p>在 ES6 中对象的所有属性都是公开的，因此若想让数据对于对象自身可访问、而在其他条件下不可访问，那么你就需要使用一些创造力。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 一般用 _属性 表示私有属性, 但并不能做到真正私有</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = name;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>        privateData.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, &#123; <span class="hljs-attr">name</span>: name &#125;);<br>    &#125;<br>    <br>    <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">name</span>;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Person</span>;<br>&#125;());<br></code></pre></td></tr></table></figure><p>当 Person 构造器被调用时，将 this 作为键在 Weak Map 上建立了一个入口，而包含私有信息的对象成为了对应的值，其中只存放了 name 属性。通过将 this 传递给 privateData.get() 方法，以获取值对象并访问其 name 属性， getName() 函数便能提取私有信息。这种技术让私有信息能够保持私有状态，并且当与之关联的对象实例被销毁时，私有信息也会被同时销毁。</p><h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><p><strong>意义：</strong></p><p>for 循环需要初始化变量以便追踪集合内的位置，而迭代器则以编程方式返回集合中的下一个项。</p><p><strong>作用：</strong></p><p>新增的 for-of 与它协同工作，扩展运算符（ … ）也使用了它，而它甚至还能让异步操作更易完成。</p><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726144254499.png" class="" title="image-20220726144254499"><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="何为迭代器"><a href="#何为迭代器" class="headerlink" title="何为迭代器"></a>何为迭代器</h3><p>迭代器是被设计专用于迭代的对象，带有特定接口。所有的迭代器对象都拥有 next() 方法，会返回一个结果对象。该结果对象有两个属性：对应下一个值的 value ，以及一个布尔类型的 done ，其值为 true 时表示没有更多值可供使用。迭代器持有一个指向集合位置的内部指针，每当调用了 next() 方法，迭代器就会返回相应的下一个值。</p><p>若你在最后一个值返回后再调用 next() ，所返回的 done 属性值会是 true ，并且 value 属性值会是迭代器自身的返回值（ return value ，即使用 return 语句明确返回的值）。该“返回值”不是原数据集的一部分，却会成为相关数据的最后一个片段，或在迭代器未提供返回值的时候使用 undefined 。迭代器自身的返回值类似于函数的返回值，是向调用者返回信息的最后手段。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><h3 id="何为生成器"><a href="#何为生成器" class="headerlink" title="何为生成器"></a>何为生成器</h3><p>生成器（ generator ）是能返回一个迭代器的函数。生成器函数由放在 function 关键字之后的一个星号（ * ）来表示，并能使用新的 yield 关键字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 生成器</span><br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">// 生成器能像正规函数那样被调用，但会返回一个迭代器</span><br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>yield 关键字也是 ES6 新增的，指定了迭代器在被 next() 方法调用时应当按顺序返回的值，传递给 next() 的参数会成为 yield 语句的值。</p><p><strong>生成器函数最有意思的方面可能就是它们会在每个 yield 语句后停止执行，在函数中停止执行的能力是极其强大的。</strong></p><p>yield 关键字只能用在生成器内部，用于其他位置都时语法错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params">items</span>) &#123;<br>    items.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>        <span class="hljs-comment">// 语法错误</span><br>        <span class="hljs-keyword">yield</span> item + <span class="hljs-number">1</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 星号放置在 function 关键字与圆括号之间，是因为这个函数表达式是匿名的</span><br><span class="hljs-keyword">let</span> createIterator = <span class="hljs-keyword">function</span> *(items) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">yield</span> items[i];<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>不能将箭头函数创建为生成器</p><h3 id="生成器对象方法"><a href="#生成器对象方法" class="headerlink" title="生成器对象方法"></a>生成器对象方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6 方法的速记法，只要在方法名之前加上一个星号*</span><br><span class="hljs-keyword">var</span> o = &#123;<br>    *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params">items</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">yield</span> items[i];<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> iterator = o.<span class="hljs-title function_">createIterator</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><h2 id="可迭代对象与-for-of-循环"><a href="#可迭代对象与-for-of-循环" class="headerlink" title="可迭代对象与 for-of 循环"></a>可迭代对象与 for-of 循环</h2><p>可迭代对象时包含 Symbol.iterator 属性的对象。</p><p>ES6 中，所有的集合对象（数组、Set与Map）以及字符串都是可迭代对象。</p><p>生成器创建的所有迭代器都是可迭代对象，因为生成器默认就会为 Symbol.iterator 属性赋值。</p><p>可迭代对象被设计用于与 ES 新增的 for-of 循环配合使用。</p><p><strong>for-of 循环会调用当前对象的 Symbol.Iterator 方法（发生在后台），获取一个迭代器 iterator，然后在调用 iterator 的 next</strong></p><p>在不可迭代对象、 null 或 undefined 上使用 for-of 语句，会抛出错误。</p><h3 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h3><p>可以使用 Symbol.iterator 来访问对象上的默认迭代器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> iterator = values[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<br></code></pre></td></tr></table></figure><p>既然 Symbol.iterator 指定了默认迭代器，你就可以使用它来检测一个对象是否能进行迭代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isIterable</span>(<span class="hljs-params">object</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> object[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] === <span class="hljs-string">&quot;function&quot;</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-string">&quot;Hello&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>())); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>())); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>())); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isIterable</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>())); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>for-of 循环在执行之前会做类似的检查，因此在遇到不可迭代对象是才会抛出错误</p><p>Weak Set 与 Weak Map 并未拥有内置的迭代器，使用弱引用意味着无法获知这些集合内部到底有多少个值，同时意味着没有方法可以迭代这些值。</p><h3 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h3><p>开发者自定义对象默认情况下不是可迭代对象，但你可以创建一个包含生成器的 Symbol.iterator 属性，让它们成为可迭代对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> collection = &#123;<br>    <span class="hljs-attr">items</span>: [],<br>    *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>) &#123;<br>            <span class="hljs-keyword">yield</span> item;<br>        &#125;<br>    &#125;<br>&#125;;<br><br>collection.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);<br>collection.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);<br>collection.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> collection) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>当使用 let-of 迭代 collection 时，会调用内部的 Symbol.iterator，从而迭代 this.items。</p><p><strong>只有当内置的迭代器无法满足你的需要时，才有必要创建自定义迭代器，这最常发生在定义你自己的对象或类时</strong></p><h2 id="内置的迭代器"><a href="#内置的迭代器" class="headerlink" title="内置的迭代器"></a>内置的迭代器</h2><h3 id="集合的迭代器"><a href="#集合的迭代器" class="headerlink" title="集合的迭代器"></a>集合的迭代器</h3><p>ES6 的三种集合对象：数组、Map、Set，都拥有如下迭代器</p><p>entries() ：返回一个包含键值对的迭代器；<br>values() ：返回一个包含集合中的值的迭代器；<br>keys() ：返回一个包含集合中的键的迭代器。</p><p><strong>集合的默认迭代器</strong></p><p>当 for-of 循环没有显式指定迭代器时，每种集合类型都有一个默认的迭代器供循环使用。</p><p><strong>values() 方法是数组与 Set 的默认迭代器，而 entries() 方法则是 Map 的默认迭代器。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [ <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span> ];<br><span class="hljs-keyword">let</span> tracking = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1234</span>, <span class="hljs-number">5678</span>, <span class="hljs-number">9012</span>]);<br><span class="hljs-keyword">let</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br>data.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;Understanding ES6&quot;</span>);<br>data.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;format&quot;</span>, <span class="hljs-string">&quot;print&quot;</span>);<br><br><span class="hljs-comment">// 与使用 colors.values() 相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> colors) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><br><span class="hljs-comment">// 与使用 tracking.values() 相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> tracking) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>&#125;<br><br><span class="hljs-comment">// 与使用 data.entries() 相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> data) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串的迭代器"><a href="#字符串的迭代器" class="headerlink" title="字符串的迭代器"></a>字符串的迭代器</h3><p><strong>方括号表示法工作在码元而非字符上</strong>，因此它不能被用于正确访问双字节的字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;A B&quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i &lt; message.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message[i]);<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">A</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">B</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>ES6 旨在为 Unicode 提供完全支持，字符串的默认迭代器就是解决字符串迭代问题的一种尝试。这样一来，<strong>借助字符串默认迭代器就能处理字符而不是码元。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;A B&quot;</span> ;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> message) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">A</span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(blank)</span><br><span class="hljs-comment">B</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="NodeList-的迭代器"><a href="#NodeList-的迭代器" class="headerlink" title="NodeList 的迭代器"></a>NodeList 的迭代器</h3><p>随着默认迭代器被附加到 ES6 ， DOM 关于 NodeList 的规定也包含了一个默认迭代器（此规定在 HTML 规范而非 ES6 规范中），其表现方式与数组的默认迭代器一致。</p><h2 id="扩展运算符与非数组的可迭代对象"><a href="#扩展运算符与非数组的可迭代对象" class="headerlink" title="扩展运算符与非数组的可迭代对象"></a>扩展运算符与非数组的可迭代对象</h2><p>扩展运算符能作用于所有可迭代对象，并且会使用默认迭代器来判断需要使用哪些值。所有的值都从迭代器中被读取出来并插入数组，遵循迭代器返回值的顺序。</p><p>扩展运算符是将可迭代对象转换为数组的最简单方法。你可以将字符串转换为包含字符（而非码元）的数组，也能将浏览器中的 NodeList 对象转换为节点数组。</p><h2 id="迭代器高级功能"><a href="#迭代器高级功能" class="headerlink" title="迭代器高级功能"></a>迭代器高级功能</h2><h3 id="传递参数给迭代器"><a href="#传递参数给迭代器" class="headerlink" title="传递参数给迭代器"></a>传递参数给迭代器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 关键在于：传递给 next() 的参数会成为 yield 语句的值</span><br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> first = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> second = <span class="hljs-keyword">yield</span> first + <span class="hljs-number">2</span>; <span class="hljs-comment">// 4 + 2</span><br>    <span class="hljs-keyword">yield</span> second + <span class="hljs-number">3</span>; <span class="hljs-comment">// 5 + 3</span><br>&#125;<br><br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;&#123; value: 6, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// &quot;&#123; value: 8, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726152259722.png" class="" title="image-20220726152259722"><h3 id="在迭代器中抛出错误"><a href="#在迭代器中抛出错误" class="headerlink" title="在迭代器中抛出错误"></a>在迭代器中抛出错误</h3><p>能传递给迭代器的不仅是数据，还可以是错误条件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> first = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> second = <span class="hljs-keyword">yield</span> first + <span class="hljs-number">2</span>; <span class="hljs-comment">// yield 4 + 2 ，然后抛出错误</span><br>    <span class="hljs-keyword">yield</span> second + <span class="hljs-number">3</span>; <span class="hljs-comment">// 永不会被执行</span><br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;&#123; value: 6, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Boom&quot;</span>))); <span class="hljs-comment">// 从生成器中抛出了错误</span><br></code></pre></td></tr></table></figure><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726152623070.png" class="" title="image-20220726152623070"><p><strong>可以在内部使用 try…catch 捕获错误</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> first = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> second;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        second = <span class="hljs-keyword">yield</span> first + <span class="hljs-number">2</span>; <span class="hljs-comment">// yield 4 + 2 ，然后抛出错误</span><br>    &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>        second = <span class="hljs-number">6</span>; <span class="hljs-comment">// 当出错时，给变量另外赋值</span><br>    &#125;<br>    <span class="hljs-keyword">yield</span> second + <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// &quot;&#123; value: 6, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Boom&quot;</span>))); <span class="hljs-comment">// &quot;&#123; value: 9, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure><p>将 next() 与 throw() 都当作迭代器的指令，会有助于思考。</p><p>next() 方法指示迭代器继续执行（可能会带着给定的值），而 throw() 方法则指示迭代器通过抛出一个错误继续执行。<strong>在调用点之后会发生什么，根据生成器内部的代码来决定。</strong></p><h3 id="生成器的-return-语句"><a href="#生成器的-return-语句" class="headerlink" title="生成器的 return 语句"></a>生成器的 return 语句</h3><p><strong>return 会终止后续的程序</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>return 可以指定返回值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 42, done: true &#125;&quot; 非常特殊，value 不为 undefined，done 为 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>扩展运算符与 for-of 循环会忽略 return 语句所指定的任意值。</strong>一旦它们看到 done的值为 true ，它们就会停止操作而不会读取对应的 value 值。不过，在生成器进行委托时，迭代器的返回值会非常有用。</p><h3 id="生成器委托"><a href="#生成器委托" class="headerlink" title="生成器委托"></a>生成器委托</h3><p>一些情况下，将两个迭代器的值合并在一起会更有用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createNumberIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createColorIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;red&quot;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;green&quot;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">createCombinedIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> *<span class="hljs-title function_">createNumberIterator</span>();<br>    <span class="hljs-keyword">yield</span> *<span class="hljs-title function_">createColorIterator</span>();<br>    <span class="hljs-keyword">yield</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">var</span> iterator = <span class="hljs-title function_">createCombinedIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: 2, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: &quot;red&quot;, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: &quot;green&quot;, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: true, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="异步任务运行"><a href="#异步任务运行" class="headerlink" title="异步任务运行"></a>异步任务运行</h2><p><strong>由于生成器能让你在执行过程中有效地暂停代码操作，它就开启了与异步编程相关的许多可能性。</strong></p><p>由于 yield 能停止运行，并在重新开始运行前等待 next() 方法被调用，你就可以在没有回调函数的情况下实现异步调用。</p><p><strong>传统异步操作</strong></p><p>调用一个包含回调的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;config.json&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, contents</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">throw</span> err;<br>    &#125;<br>        <br>    <span class="hljs-title function_">doSomethingWith</span>(contents);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Done&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>使用 yield</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">taskDef</span>) &#123;<br>    <span class="hljs-comment">// 创建迭代器，让它在别处可用</span><br>    <span class="hljs-keyword">let</span> task = <span class="hljs-title function_">taskDef</span>();<br>    <span class="hljs-comment">// 启动任务</span><br>    <span class="hljs-keyword">let</span> result = task.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-comment">// 递归使用函数来保持对 next() 的调用</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">step</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 如果还有更多要做的</span><br>        <span class="hljs-keyword">if</span> (!result.<span class="hljs-property">done</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result.<span class="hljs-property">value</span> === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>                result.<span class="hljs-title function_">value</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (err) &#123;<br>                        result = task.<span class="hljs-keyword">throw</span>(err);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><br>                    result = task.<span class="hljs-title function_">next</span>(data);<br>                    <span class="hljs-title function_">step</span>();<br>                &#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result = task.<span class="hljs-title function_">next</span>(result.<span class="hljs-property">value</span>);<br>                <span class="hljs-title function_">step</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 开始处理过程</span><br>    <span class="hljs-title function_">step</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">run</span>(<span class="hljs-keyword">function</span>*() &#123;<br>    <span class="hljs-keyword">let</span> contents = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;config.json&quot;</span>);<br>    <span class="hljs-title function_">doSomethingWith</span>(contents);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Done&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>此例执行了异步的 readFile() 操作，而在<strong>主要代码中并未暴露出任何回调函数</strong>。除了 yield 之外，<strong>此代码看起来与同步代码并无二致</strong>。既然执行异步操作的函数都遵循了同一接口，你就可以用貌似同步的代码来书写处理逻辑。</p><p>看上去好像更复杂了，但这是因为当前回调任务少，<strong>如果需要嵌套回调函数，或者需要按顺序处理一系列的异步任务时，使用生成器和迭代器会方便很多</strong>。</p><h1 id="JS-的类"><a href="#JS-的类" class="headerlink" title="JS 的类"></a>JS 的类</h1><img src="/2022/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/image-20220726161901329.png" class="" title="image-20220726161901329"><h2 id="ES5-中的仿类结构"><a href="#ES5-中的仿类结构" class="headerlink" title="ES5 中的仿类结构"></a>ES5 中的仿类结构</h2><p><strong>自定义类型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PersonType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">PersonType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>person.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PersonType</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonClass</span> &#123;<br>    <span class="hljs-comment">// 等价于 PersonType 构造器</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-comment">// 自有属性</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-comment">// 等价于 PersonType.prototype.sayName</span><br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonClass</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>person.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// &quot;function&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span>); <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure><p><strong>自有属性：该属性出现在实例上而不是原型上，只能在类的构造器或方法内部进行创建。</strong></p><p><strong>类与自定义类型的区别</strong></p><ol><li><strong>类声明不会被提升，这与函数定义不同</strong>。类声明的行为与 let 相似，因此在程序的执行到达声明处之前，类会存在于暂时性死区内。</li><li><strong>类声明中的所有代码会自动运行在严格模式下</strong>，并且也无法退出严格模式。</li><li><strong>类的所有方法都是不可枚举的</strong>，这是对于自定义类型的显著变化，后者必须用Object.defineProperty() 才能将方法改变为不可枚举。</li><li><strong>类的所有方法内部都没有 [[Construct]]</strong> ，因此使用 new 来调用它们会抛出错误。</li><li><strong>调用类构造器时不使用 new</strong> ，会抛出错误。</li><li><strong>试图在类的方法内部重写类名</strong>，会抛出错误。</li></ol><p><strong>如果我们不使用类来定义上面的 PersonClass</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 直接等价于 PersonClass</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">PersonType2</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">PersonType2</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>        <br>        <span class="hljs-comment">// 确认函数被调用时使用了 new</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Constructor must be called with new.&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">PersonType2</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;sayName&quot;</span>, &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <br>            <span class="hljs-comment">// 确认函数被调用时没有使用 new</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Method cannot be called with new.&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>        &#125;,<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">PersonType2</span>;<br>&#125;());<br></code></pre></td></tr></table></figure><h2 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h2><p>类与函数有相似之处，即它们都有两种形式：声明与表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title class_">PersonClass</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonClass2</span> &#123;<span class="hljs-comment">// PersonClass2 可省略，匿名和具名</span><br>    <span class="hljs-comment">// 等价于 PersonType 构造器</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 等价于 PersonType.prototype.sayName</span><br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonClass</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>person.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>); <span class="hljs-comment">// &quot;function&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span>); <span class="hljs-comment">// &quot;function&quot;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">PersonClass2</span>); <span class="hljs-comment">// &quot;undefined&quot;外部是访问不到 PersonClass2 的</span><br></code></pre></td></tr></table></figure><h2 id="作为一级公民的类"><a href="#作为一级公民的类" class="headerlink" title="作为一级公民的类"></a>作为一级公民的类</h2><p>能被当作值来使用的就称为一级公民</p><p>JS的函数就是一级公民，类也延续了下来。</p><p>类能作为参数传入函数；也有立即调用类构造器的用法。</p><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js设计与实现</title>
    <link href="/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="框架设计概览"><a href="#框架设计概览" class="headerlink" title="框架设计概览"></a>框架设计概览</h2><h3 id="权衡的艺术"><a href="#权衡的艺术" class="headerlink" title="权衡的艺术"></a>权衡的艺术</h3><h4 id="命令式和声明式"><a href="#命令式和声明式" class="headerlink" title="命令式和声明式"></a>命令式和声明式</h4><p>命令式 关注过程</p><p>声明式 关注结果</p><p>Vue.js 帮我们封装了过程，内部实现是命令式的，而暴露给用户的却更加声明式</p><h4 id="性能与可维护性的权衡"><a href="#性能与可维护性的权衡" class="headerlink" title="性能与可维护性的权衡"></a>性能与可维护性的权衡</h4><p>声明式代码的性能不优于命令式代码的性能</p><p>命令式代码的更新性能消耗 &#x3D; 直接修改的性能消耗</p><p>声明式代码的更新性能消耗 &#x3D; 直接修改的性能消耗 + <strong>找出差异的性能消耗</strong></p><p>但声明式代码的可维护性更强</p><p>设计框架时 要保证可维护性的同时让性能损失最小化</p><h4 id="虚拟-DOM-的性能到底如何"><a href="#虚拟-DOM-的性能到底如何" class="headerlink" title="虚拟 DOM 的性能到底如何"></a>虚拟 DOM 的性能到底如何</h4><p>虚拟 DOM 就是为了<strong>最小化找出差异</strong>这一步的性能消耗而出现的 (diff算法)</p><p><strong>创建页面差异不大</strong></p><img src="/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20220718191653483.png" class="" title="image-20220718191653483"><p><strong>更新页面性能差异大</strong></p><img src="/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20220718191710254.png" class="" title="image-20220718191710254"><p><strong>更新页面的性能效果总结</strong></p><img src="/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20220718171611741.png" class="" title="image-20220718171611741"><h4 id="运行时和编译时"><a href="#运行时和编译时" class="headerlink" title="运行时和编译时"></a>运行时和编译时</h4><p>纯运行时，没有编译的过程，没办法分析用户提供的内容</p><p>纯编译时，可以分析用户提供的内容，性能更好，但用户提供的内容必须编译后才能用，有损灵活性</p><p>Vue.js 是运行时 + 编译时的架构</p><h3 id="框架设计的核心要素"><a href="#框架设计的核心要素" class="headerlink" title="框架设计的核心要素"></a>框架设计的核心要素</h3><h4 id="提供用户的开发体验"><a href="#提供用户的开发体验" class="headerlink" title="提供用户的开发体验"></a>提供用户的开发体验</h4><p>更友好的警告</p><p>自定义输出形式</p><h4 id="控制框架代码的体积"><a href="#控制框架代码的体积" class="headerlink" title="控制框架代码的体积"></a>控制框架代码的体积</h4><p>利用 Tree-shaking 机制，配合构建工具预定义常量的能力，如预定义 __DEV__常量，从而实现仅在开发环境中打印警告信息，从而控制线上代码体积</p><h4 id="良好的-Tree-Shaking"><a href="#良好的-Tree-Shaking" class="headerlink" title="良好的 Tree-Shaking"></a>良好的 Tree-Shaking</h4><p>利用 &#x2F;*#__PURE__*&#x2F; 注释 来让 webpack 相信这段代码不会产生副作用，从而 tree-shaking 掉</p><p>副作用：当调用函数的时候会对外部产生影响</p><p>Vue.js 3 源码中，基本都是在一些顶级调用的函数中使用 &#x2F;*#__PURE__*&#x2F; 注释掉</p><h4 id="框架应该输出怎样的构建产物"><a href="#框架应该输出怎样的构建产物" class="headerlink" title="框架应该输出怎样的构建产物"></a>框架应该输出怎样的构建产物</h4><p>为了让用户能够通过 <script> 标签直接引用并使用，需要输出 IIFE 格式的资源</p><p>为了让用户能够通过 <script type="module"> 引用并使用，需要输出 ESM 格式的资源</p><p>ESM格式的资源有两种：</p><p>esm-browser.js 用于浏览器使用 __DEV__  true/false 来判断环境</p><p>esm-bundler.js 用于打包工具 使用 process.env.NODE_ENV !== ‘production’ 来判断</p><p>为了让用户能够通过在服务端通过</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">const</span> <span class="hljs-variable">Vue</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;vue&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>使用，需要输出 CommonJS 格式的资源（一般用于服务端渲染）</p><h4 id="特性开关"><a href="#特性开关" class="headerlink" title="特性开关"></a>特性开关</h4><p>Vue.js 提供了很多功能，如果不需要可以通过特性开关关闭，这样打包时代码就不会出现在最终资源中，文件体积减小</p><p>比如 Vue3.js 中我们仍可使用 options API，可以关闭，通过 __VUE_OPTIONS_API__ 控制。</p><p>实现特性开关的方法和 __DEV__ 是一样的，本质上是通过 rollup.js(webpack) 的预定义常量插件来实现</p><p>可以使用 webpack.DefinePlugin 插件来控制是否开启</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> webpack.DefinePlugin (&#123;<br>__VUE_OPTIONS_API__: <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-literal">true</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Vue3.js 中将错误处理程序封装为一个函数 callWithErrorHandling</p><p>还提供了 registerErrorHandler 函数，用户可以使用它注册错误处理程序</p><h4 id="良好的-TS-支持"><a href="#良好的-TS-支持" class="headerlink" title="良好的 TS 支持"></a>良好的 TS 支持</h4><p>使用 TS 编写框架 和 框架对 TS 类型 支持友好是完全不同的</p><h3 id="Vue3-js-的设计思路"><a href="#Vue3-js-的设计思路" class="headerlink" title="Vue3.js 的设计思路"></a>Vue3.js 的设计思路</h3><h4 id="声明式描述-UI"><a href="#声明式描述-UI" class="headerlink" title="声明式描述 UI"></a>声明式描述 UI</h4><p>描述 UI 的两种方式：模板和虚拟 DOM</p><p>组件中的 render 函数就是使用虚拟 DOM 来描述 UI</p><p>h 函数就是一个辅助创建虚拟 DOM 的工具函数</p><h4 id="初始渲染器"><a href="#初始渲染器" class="headerlink" title="初始渲染器"></a>初始渲染器</h4><p><strong>渲染器</strong>的作用就是把 <strong>虚拟 DOM 转为 真实 DOM</strong></p><p>代码部分看书上的 renderer 函数</p><h4 id="组件的本质"><a href="#组件的本质" class="headerlink" title="组件的本质"></a>组件的本质</h4><p>组件就是一组 DOM 元素的封装</p><h4 id="模板的工作原理"><a href="#模板的工作原理" class="headerlink" title="模板的工作原理"></a>模板的工作原理</h4><img src="/2022/07/18/Vue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20220718204108277.png" class="" title="image-20220718204108277"><h4 id="编译器分析动态内容"><a href="#编译器分析动态内容" class="headerlink" title="编译器分析动态内容"></a>编译器分析动态内容</h4><p>代码中有静态内容（如写死的字符串），有动态内容（如双向绑定的变量）</p><p>动态内容改变时，渲染器会自动寻找变更点，找起来比较麻烦。</p><p>如果编译器有能力分析动态内容，获取更多信息，就会方便很多。</p><p>编译器能够识别出哪些是静态属性，哪些是动态属性（代码显然不一样），在生成虚拟 DOM 的时候就会携带额外的 patchFlags 信息。(patchFlags 应该是 vue3 新增的)</p>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类型转换</title>
    <link href="/2022/07/15/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/07/15/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>JS 没有严格的数据类型，所以可以互相转换</p><ul><li>显示类型转换：<code>Number()</code>, <code>String()</code>, <code>Boolean()</code></li><li>隐式类型转换：四则运算，判断语句，<code>Native</code> 调用，<code>JSON</code> 方法</li></ul><h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><h3 id="1-Number"><a href="#1-Number" class="headerlink" title="1. Number()"></a><strong>1. Number()</strong></h3><h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><ul><li>数字：转换后还是原来的值</li><li>字符串：如果能被解析成数字，就得到数字，否则就是 <code>NaN</code>，空字符串为0</li><li>布尔值：<code>true</code> 转为1，false 转为0</li><li><code>undefined</code>: 转为 <code>NaN</code></li><li><code>null</code>：转为0 引用类型转换</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;1&quot;</span>)) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;1a&quot;</span>)) <span class="hljs-comment">// NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;)) <span class="hljs-comment">// NaN 原因往下看</span><br></code></pre></td></tr></table></figure><h4 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><p>先调用对象自身的 <code>valueOf</code> 方法，如果该方法返回原始类型的值(数值、字符串和布尔值)，则直接对该值使用 <code>Number</code> 方法，不再继续</p><p>如果 <code>valueOf</code> 方法返回复合类型的值，再调用对象自身的 <code>toString</code> 方法，如果 <code>toString</code> 方法返回原始类型的值，则对该值使用 <code>Number</code> 方法，不再继续</p><p>如果 <code>toString</code> 方法返回的还是复合类型的值，则报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(a)) <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 原理</span><br>a.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// &#123;a:1&#125;</span><br>a.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;[object Object]&quot;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h3 id="2-String"><a href="#2-String" class="headerlink" title="2. String()"></a><strong>2. String()</strong></h3><h4 id="简单数据类型-1"><a href="#简单数据类型-1" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><ul><li>数字：转换成相应字符串</li><li>字符串：转换后还是原来的值</li><li>布尔值：<code>true</code> 转为”true”，<code>false</code> 转为”false”</li><li><code>undefined</code>: 转为”undefined”</li><li><code>null</code>：转为”null” 引用类型转换</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// &quot;1&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>)) <span class="hljs-comment">// &quot;1&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// &quot;true&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// &quot;null&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(&#123;<span class="hljs-attr">b</span>:<span class="hljs-number">1</span>&#125;)) <span class="hljs-comment">// &quot;[object Object]&quot; 原因往下看</span><br></code></pre></td></tr></table></figure><h4 id="复杂数据类型-1"><a href="#复杂数据类型-1" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><p>先调用 <code>toString</code> 方法，如果 <code>toString</code> 方法返回的是原始类型的值，则对该值使用 <code>String</code> 方法，不再继续</p><p>如果 <code>toString</code> 方法返回的是复合类型的值，再调用 <code>valueOf</code> 方法，如果 <code>valueOf</code> 方法返回的是原始类型的值，则对该值使用 <code>String</code> 方法，不再继续</p><p>如果 <code>valueOf</code> 方法返回的是复合类型的值，则报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> b = &#123;<span class="hljs-attr">b</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(b)) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-comment">// 原理</span><br>b.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-comment">// b.valueOf() 由于返回的不是复合类型所以没有调valueOf()</span><br><span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;[object Object]&quot;</span>) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-Boolean"><a href="#3-Boolean" class="headerlink" title="3. Boolean()"></a><strong>3. Boolean()</strong></h3><h4 id="简单数据类型-2"><a href="#简单数据类型-2" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><ul><li>0</li><li>-0</li><li>“”</li><li>null</li><li>undefined</li><li>NaN</li></ul><p>以上统一转为false，其他一律为true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(-<span class="hljs-number">0</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&quot;&quot;</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-title class_">NaN</span>)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="复杂数据类型-2"><a href="#复杂数据类型-2" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><p>都转为 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(obj1))<span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(obj2))<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 四则运算  如把String隐式转换成Number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-string">&#x27;1&#x27;</span> === <span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 判断语句  如把String隐式转为Boolean</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// Native调用  如把Object隐式转为String</span><br><span class="hljs-title function_">alert</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]]) <span class="hljs-comment">// &quot;nb&quot;</span><br><br><span class="hljs-comment">// JSON方法 如把String隐式转为Object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&quot;&#123;a:1&#125;&quot;</span>)) <span class="hljs-comment">// &#123;a:1&#125;</span><br></code></pre></td></tr></table></figure><p>几道隐式转换题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-literal">true</span>+<span class="hljs-literal">true</span>  ) <span class="hljs-comment">// 2                   解：true相加是用四则运算隐式转换Number 就是1+1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(  <span class="hljs-number">1</span>+&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;   ) <span class="hljs-comment">// &quot;1[object Object]&quot;  解：上面说了Native调用&#123;a:1&#125;为&quot;[object Object]&quot;  数字1+字符串直接拼接</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(   []+[]    ) <span class="hljs-comment">// &quot;&quot;                  解：String([]) =》 [].toString() = &quot;&quot; =》 &quot;&quot;+&quot;&quot; =》 &quot;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(   []+&#123;&#125;    ) <span class="hljs-comment">// &quot;[object Object]&quot;   解：&quot;&quot; + String(&#123;&#125;) =》 &quot;&quot; + &#123;&#125;.toString() = &quot;&quot; + &quot;[object Object]&quot; =》 &quot;[object Object]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(   &#123;&#125;+&#123;&#125;    ) <span class="hljs-comment">// &quot;[object Object][object Object]&quot; 和上面同理</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文大部分内容来自于这篇文章<a href="https://juejin.cn/post/6995591618371780622">https://juejin.cn/post/6995591618371780622</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>定位</title>
    <link href="/2022/07/14/%E5%AE%9A%E4%BD%8D/"/>
    <url>/2022/07/14/%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>一种布局方式</p><p>定位 &#x3D; 定位模式 + 边偏移</p><h2 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h2><table><thead><tr><th>边偏移属性</th><th align="left">示例</th><th>描述</th></tr></thead><tbody><tr><td><code>top</code></td><td align="left"><code>top: 80px / 50%</code></td><td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td></tr><tr><td><code>bottom</code></td><td align="left"><code>bottom: 80px</code></td><td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td></tr><tr><td><code>left</code></td><td align="left"><code>left: 80px</code></td><td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td></tr><tr><td><code>right</code></td><td align="left"><code>right: 80px</code></td><td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td></tr></tbody></table><h2 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h2><table><thead><tr><th>值</th><th align="center">语义</th><th></th></tr></thead><tbody><tr><td>static</td><td align="center"><strong>静态</strong>定位</td><td>标准流 无定位</td></tr><tr><td>relative</td><td align="center"><strong>相对</strong>定位</td><td>标准流 相对自身定位 标准流区域的位置仍占有</td></tr><tr><td>absolute</td><td align="center"><strong>绝对</strong>定位</td><td>脱离标准流 相对最近的有定位且不为 static 的祖先元素定位，若没有则相对 body 定位</td></tr><tr><td>fixed</td><td align="center"><strong>固定</strong>定位</td><td>脱离标准流 相对于浏览器窗口定位</td></tr><tr><td>sticky</td><td align="center"><strong>粘性</strong>定位</td><td>根据窗口滚动自动切换 relative 和 fixed，由设置的边偏移决定</td></tr></tbody></table><h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p>在使用<strong>定位</strong>布局时，可能会<strong>出现盒子重叠的情况</strong>。</p><p>加了定位的盒子，默认<strong>后来者居上</strong>， 后面的盒子会压住前面的盒子。</p><p>使用 <code>z-index</code> 层叠等级属性可以<strong>调整盒子的堆叠顺序</strong>。</p><p><code>z-index</code> 的特性如下：</p><ol><li><strong>属性值</strong>：<strong>整数</strong>，默认值是 0，数值越大，盒子越靠上；</li><li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li><li><strong>数字后面不能加单位</strong>。</li></ol><p><strong>注意</strong>：<code>z-index</code> 只能应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>设定 position ＝ absolute 或 fixed 可以创建 BFC 解决高度塌陷, 外边距重叠，清除浮动问题</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>scoped和样式穿透</title>
    <link href="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/"/>
    <url>/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="scoped-和样式穿透"><a href="#scoped-和样式穿透" class="headerlink" title="scoped 和样式穿透"></a>scoped 和样式穿透</h1><h2 id="scoped"><a href="#scoped" class="headerlink" title="scoped"></a>scoped</h2><h3 id="不使用-scoped"><a href="#不使用-scoped" class="headerlink" title="不使用 scoped"></a>不使用 scoped</h3><p>顺便复习一下 vue3 中路由的使用</p><p><strong>配置路由并导出</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/router/router.ts</span><br><span class="hljs-comment">// 配置路由并导出</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">NoRed</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/nored.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Red</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/red.vue&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123; createRouter,createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><br><span class="hljs-keyword">const</span> routes = [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/red&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Red</span>&#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/no_red&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">NoRed</span>&#125;<br>]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<span class="hljs-comment">// vue3 的 history 模式对应 createWebHashHistory hash 模式</span><br>    routes<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><p><strong>引入并使用组件</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/main.ts</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">// 引入路由</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router/router&#x27;</span><br><br><span class="hljs-comment">// use 路由</span><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>写组件</strong></p><p>只在 red 中写样式并不加 scoped</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src/components/nored.vue --&gt;<br>&lt;template&gt;<br>    &lt;div&gt; <br>      &lt;h1&gt;我应该不是红色&lt;/h1&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br><br>&lt;/script&gt;<br><br>&lt;style&gt; <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src/components/red.vue --&gt;<br>&lt;template&gt;<br>    &lt;div&gt; <br>      &lt;h1&gt;我应该是红色&lt;/h1&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br><br>&lt;/script&gt;<br><br>&lt;style&gt; <br>  a &#123;<br>    color: red<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>显示组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src/App.vue --&gt;<br>&lt;script setup lang=&quot;ts&quot;&gt;<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;p&gt;<br>     &lt;router-link to=&quot;/red&quot;&gt;red&lt;/router-link&gt;<br>     &lt;router-link to=&quot;/no_red&quot; style=&quot;margin-left: 20px;&quot;&gt;nored&lt;/router-link&gt;<br>     &lt;router-view&gt;&lt;/router-view&gt;<br>   &lt;/p&gt;<br>&lt;/template&gt;<br><br>&lt;style&gt;<br><br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>效果是</strong></p><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713222944618.png" class="" title="image-20220713222944618"><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713223018761.png" class="" title="image-20220713223018761"><p>只在 red 组件中写了样式 结果 nored 也有了样式</p><h3 id="使用-scoped"><a href="#使用-scoped" class="headerlink" title="使用 scoped"></a>使用 scoped</h3><p>在 red 组件的 style 标签中加上 scoped</p><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713222944618.png" class="" title="image-20220713222944618"><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713222951713.png" class="" title="image-20220713222951713"><p><strong>原理上就是 vue 在该组件的标签中加了一串字符</strong></p><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713223437121.png" class="" title="image-20220713223437121"><p><strong>该组件中的样式中也会以属性选择器的方式拼接上</strong></p><img src="/2022/07/13/scoped%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/image-20220713223714421.png" class="" title="image-20220713223714421"><p><strong>实际的步骤</strong></p><p>给HTML的DOM节点加一个不重复data属性(形如：data-v-123)来表示他的唯一性</p><p>在每句css选择器的末尾（编译后的生成的css语句）加一个当前组件的data属性选择器（如[data-v-123]）来私有化样式</p><p>如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的data属性</p><h3 id="scoped-的副作用"><a href="#scoped-的副作用" class="headerlink" title="scoped 的副作用"></a>scoped 的副作用</h3><p>如果我们在使用第三方库时企图修改其样式且使用 scoped（尤其是一些 ui 库）</p><p>会发现标签上并没有加上字符串，而样式中却加上了，因此样式会失效。</p><h2 id="样式穿透"><a href="#样式穿透" class="headerlink" title="样式穿透"></a>样式穿透</h2><p>不使用样式穿透</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.lei</span> &#123;<br>    <span class="hljs-selector-tag">input</span> &#123;<br>        <span class="hljs-attribute">background</span>: red<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用样式穿透 <strong>:deep()</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.lei</span> &#123;<br>    :<span class="hljs-selector-tag">deep</span>(input) &#123;<br>        <span class="hljs-attribute">background</span>: red<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以修改第三方库的样式了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7083051766874374174">https://juejin.cn/post/7083051766874374174</a></p><p><a href="https://blog.csdn.net/qq1195566313/article/details/123319462">https://blog.csdn.net/qq1195566313/article/details/123319462</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则</title>
    <link href="/2022/07/11/%E6%AD%A3%E5%88%99/"/>
    <url>/2022/07/11/%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Regular Expression</p><p>正则表达式是用于<strong>匹配字符串中字符组合的模式</strong>（文本搜索&#x2F;替换）</p><p>正则表达式是<strong>对象</strong></p><p>这些模式被用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a> 方法，以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><code>matchAll</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a> 方法。</p><p>可以简化字符串操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 举个例子, 提取字符串中的数字</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abas3244sda5552&quot;</span><br><br><span class="hljs-comment">// 使用 api</span><br><span class="hljs-keyword">let</span> nums = [...str].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> !<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">parseInt</span>(a)))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nums.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>))<br><br><span class="hljs-comment">// 使用 正则表达式</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1.使用双斜杠 /pattern/attributes</span><br><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/ab+c/</span><br><br><span class="hljs-comment">// 2.使用构造函数 new RegExp(pattern, attributes)</span><br><span class="hljs-keyword">let</span> re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;ab+c&quot;</span>)<br></code></pre></td></tr></table></figure><p>参数 <em><strong>pattern</strong></em> 是一个<strong>字符串</strong>，指定了正则表达式的模式或其他正则表达式。</p><p>参数 <em>attributes</em> 是一个可选的字符串，包含属性 “g”、”i” 和 “m”。</p><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_i.asp">i</a></td><td align="left">执行对大小写不敏感的匹配。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_g.asp">g</a></td><td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td align="left">m</td><td align="left">执行多行匹配。</td></tr></tbody></table><h2 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h2><p>方括号用于查找某个范围内的字符：</p><table><thead><tr><th align="left">表达式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[<a href="https://www.w3school.com.cn/jsref/jsref_regexp_charset.asp">abc]</a></td><td align="left">查找方括号之间的任何字符。</td></tr><tr><td align="left">[<a href="https://www.w3school.com.cn/jsref/jsref_regexp_charset_not.asp">^abc]</a></td><td align="left">查找任何不在方括号之间的字符。</td></tr><tr><td align="left">[0-9]</td><td align="left">查找任何从 0 至 9 的数字。</td></tr><tr><td align="left">[a-z]</td><td align="left">查找任何从小写 a 到小写 z 的字符。</td></tr><tr><td align="left">[A-Z]</td><td align="left">查找任何从大写 A 到大写 Z 的字符。</td></tr><tr><td align="left">[A-z]</td><td align="left">查找任何从大写 A 到小写 z 的字符。</td></tr><tr><td align="left">[adgk]</td><td align="left">查找给定集合内的任何字符。</td></tr><tr><td align="left">[^adgk]</td><td align="left">查找给定集合外的任何字符。</td></tr><tr><td align="left">(red|blue|green)</td><td align="left">查找任何指定的选项。</td></tr></tbody></table><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>元字符（Metacharacter）是拥有特殊含义的字符：</p><table><thead><tr><th align="left">元字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_dot.asp">.</a></td><td align="left">查找单个字符，除了换行和行结束符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_wordchar.asp">\w</a></td><td align="left">查找单词字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_wordchar_non.asp">\W</a></td><td align="left">查找非单词字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_digit.asp">\d</a></td><td align="left">查找数字。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_digit_non.asp">\D</a></td><td align="left">查找非数字字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_whitespace.asp">\s</a></td><td align="left">查找空白字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_whitespace_non.asp">\S</a></td><td align="left">查找非空白字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_begin.asp">\b</a></td><td align="left">匹配单词边界。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_begin_not.asp">\B</a></td><td align="left">匹配非单词边界。</td></tr><tr><td align="left">\0</td><td align="left">查找 NUL 字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_newline.asp">\n</a></td><td align="left">查找换行符。</td></tr><tr><td align="left">\f</td><td align="left">查找换页符。</td></tr><tr><td align="left">\r</td><td align="left">查找回车符。</td></tr><tr><td align="left">\t</td><td align="left">查找制表符。</td></tr><tr><td align="left">\v</td><td align="left">查找垂直制表符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_octal.asp">\xxx</a></td><td align="left">查找以八进制数 xxx 规定的字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_hex.asp">\xdd</a></td><td align="left">查找以十六进制数 dd 规定的字符。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_unicode_hex.asp">\uxxxx</a></td><td align="left">查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><table><thead><tr><th align="left">量词</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_onemore.asp">n+</a></td><td align="left">匹配任何包含至少一个 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_zeromore.asp">n*</a></td><td align="left">匹配任何包含零个或多个 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_zeroone.asp">n?</a></td><td align="left">匹配任何包含零个或一个 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_nx.asp">n{X}</a></td><td align="left">匹配包含 X 个 n 的序列的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_nxy.asp">n{X,Y}</a></td><td align="left">匹配包含 X 至 Y 个 n 的序列的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_nxcomma.asp">n{X,}</a></td><td align="left">匹配包含至少 X 个 n 的序列的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_ndollar.asp">n$</a></td><td align="left">匹配任何结尾为 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_ncaret.asp">^n</a></td><td align="left">匹配任何开头为 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_nfollow.asp">?&#x3D;n</a></td><td align="left">匹配任何其后紧接指定字符串 n 的字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_nfollow_not.asp">?!n</a></td><td align="left">匹配任何其后没有紧接指定字符串 n 的字符串。</td></tr></tbody></table><h2 id="RegExp-对象属性"><a href="#RegExp-对象属性" class="headerlink" title="RegExp 对象属性"></a>RegExp 对象属性</h2><table><thead><tr><th align="left">属性</th><th align="left">描述</th><th align="left">FF</th><th align="left">IE</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_global.asp">global</a></td><td align="left">RegExp 对象是否具有标志 g。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_ignorecase.asp">ignoreCase</a></td><td align="left">RegExp 对象是否具有标志 i。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_lastindex_regexp.asp">lastIndex</a></td><td align="left">一个整数，标示开始下一次匹配的字符位置。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_multiline_regexp.asp">multiline</a></td><td align="left">RegExp 对象是否具有标志 m。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_source_regexp.asp">source</a></td><td align="left">正则表达式的源文本。</td><td align="left">1</td><td align="left">4</td></tr></tbody></table><h2 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">FF</th><th align="left">IE</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_regexp_compile.asp">compile</a></td><td align="left">编译正则表达式。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_exec_regexp.asp">exec</a></td><td align="left">检索字符串中指定的值。返回找到的值，并确定其位置。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_test_regexp.asp">test</a></td><td align="left">检索字符串中指定的值。返回 true 或 false。</td><td align="left">1</td><td align="left">4</td></tr></tbody></table><h2 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">FF</th><th align="left">IE</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_search.asp">search</a></td><td align="left">检索与正则表达式相匹配的值。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_match.asp">match</a></td><td align="left">找到一个或多个正则表达式的匹配。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_replace.asp">replace</a></td><td align="left">替换与正则表达式匹配的子串。</td><td align="left">1</td><td align="left">4</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_split.asp">split</a></td><td align="left">把字符串分割为字符串数组。</td><td align="left">1</td><td align="left">4</td></tr></tbody></table><h2 id="几个正则例子"><a href="#几个正则例子" class="headerlink" title="几个正则例子"></a>几个正则例子</h2><h3 id="手机号匹配"><a href="#手机号匹配" class="headerlink" title="手机号匹配"></a>手机号匹配</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/^1[34578]\d&#123;9&#125;$/g</span><br></code></pre></td></tr></table></figure><p>^从字符串开头进行匹配</p><p>$从字符串末尾进行匹配</p><p>1 第一位为1</p><p>[34578]第二位一般是 3&#x2F;4&#x2F;5&#x2F;7&#x2F;8</p><p>\d 表示所有数字</p><p>{9}表示重复的次数（这里表示 9 个数字）</p><p>g 表示全局模式</p><h3 id="qq-号匹配"><a href="#qq-号匹配" class="headerlink" title="qq 号匹配"></a>qq 号匹配</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/^[1-9][0-9]&#123;4,9&#125;$/g</span><br></code></pre></td></tr></table></figure><p>{4,9}表示重复次数的范围 （这里表示 4-9 个数字）</p><h3 id="十六进制表示颜色"><a href="#十六进制表示颜色" class="headerlink" title="十六进制表示颜色"></a>十六进制表示颜色</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">4BD1CC 或 <span class="hljs-comment">#0AB</span></span><br><span class="hljs-meta prompt_">/#</span><span class="language-bash">?([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span><br></code></pre></td></tr></table></figure><p>#? 表示 # 可有可无（开发时根据实际情况写）</p><p>(a|b) 表示两组（两种情况）</p><h3 id="常见邮箱格式"><a href="#常见邮箱格式" class="headerlink" title="常见邮箱格式"></a>常见邮箱格式</h3><p>可接受的字符有 英文字符 数字 _ - .</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">分成三组 <span class="hljs-number">12345678</span>@qq.com<br>/^([<span class="hljs-keyword">A</span>-Za-z0-<span class="hljs-number">9</span>_\-\.]+)@([<span class="hljs-keyword">A</span>-Za-z0-<span class="hljs-number">9</span>_\-\.]+)\.([<span class="hljs-keyword">A</span>-Za-z]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;)$/g<br></code></pre></td></tr></table></figure><p>-在正则中表示范围，.表示除了换行符外的任意字符，所以都需要转义</p><p>理论上来说是需要控制长度的，这里就不限定字符数了（+表示 1个字符到无限个字符）</p><h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.bilibili.com<span class="hljs-regexp">/danlaoshi/</span><span class="hljs-number">666</span>/<br><span class="hljs-regexp">/^((https?|ftp|file):\/\/)?([\da-z\.\-]+)\.)([a-z\.]&#123;2,6&#125;)([\/\w\.\-]*)*\/?$/g</span><br></code></pre></td></tr></table></figure><p>https? 就表示 http 或 https</p><p>我们输入网址时可能不会写上协议名称，因此分组并加上问号</p><p>+表示1到无穷大</p><p>*表示0到无穷大</p><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-variable">&lt;div class=&quot;lwj&quot;&gt;</span>lwj<span class="hljs-variable">&lt;/div&gt;</span><br><span class="hljs-variable">&lt;div&gt;</span><span class="hljs-variable">&lt;/div&gt;</span><br><span class="hljs-variable">&lt;img /&gt;</span><br><br>/^<span class="hljs-variable">&lt;([a-z]+)([^&gt;</span>]+)<span class="hljs-symbol">*</span>(?:&gt;(.<span class="hljs-symbol">*</span>)<span class="hljs-variable">&lt;\/\1&gt;</span>|<span class="hljs-string">\s+\/&gt;)$/gm</span><br></code></pre></td></tr></table></figure><p>\1 表示引用前面括号包裹起来的第一个组</p><p>也就是说，这里 \1 表示 ([a-z]+)</p><p>\s 表示空格</p><p>?: 出现在括号的开头 表示不需要捕获该组</p><h3 id="更多常用正则"><a href="#更多常用正则" class="headerlink" title="更多常用正则"></a>更多常用正则</h3><p><a href="https://juejin.cn/post/7119242343798013959">https://juejin.cn/post/7119242343798013959</a></p><h2 id="在线测试工具"><a href="#在线测试工具" class="headerlink" title="在线测试工具"></a>在线测试工具</h2><p><a href="https://c.runoob.com/front-end/854/">https://c.runoob.com/front-end/854/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp">https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp</a></p><p><a href="https://www.bilibili.com/video/BV1QK4y1K72U/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=1616b746cefe2e7615c229563ba38eb4">https://www.bilibili.com/video/BV1QK4y1K72U/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=1616b746cefe2e7615c229563ba38eb4</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>正则</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>正则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue源码解析</title>
    <link href="/2022/07/10/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/10/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>(更新中)</p><h1 id="数据响应式原理"><a href="#数据响应式原理" class="headerlink" title="数据响应式原理"></a>数据响应式原理</h1><h2 id="将数据变为响应式"><a href="#将数据变为响应式" class="headerlink" title="将数据变为响应式"></a>将数据变为响应式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 让 data 变为响应式</span><br><span class="hljs-comment">// let val 临时变量也是可以的, 但是不美观, 可以封装到函数 defineReactive 中 , 也方便复用</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, val</span>) &#123;<br>    <span class="hljs-comment">// 没传 val 的话 就使用原有的值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>        val = data[key]<br>    &#125;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// getter</span><br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;访问 obj 的&#x27;</span> + key + <span class="hljs-string">&#x27;属性&#x27;</span>)<br>            <span class="hljs-keyword">return</span> val<br>        &#125;,<br>        <span class="hljs-comment">// setter</span><br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;改变 obj 的&#x27;</span> + key + <span class="hljs-string">&#x27;属性&#x27;</span>, newValue)<br>            <span class="hljs-keyword">if</span> (val === newValue) <span class="hljs-keyword">return</span><br>            val = newValue<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归侦测对象全部属性"><a href="#递归侦测对象全部属性" class="headerlink" title="递归侦测对象全部属性"></a>递归侦测对象全部属性</h2><p>若对象层级深，深层对象并不是响应式的，需要递归对象的全部属性</p><p>创建 Observer 类将一个 object 转换为每个层级的属性都是响应式的</p><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// \src\index.js</span><br><span class="hljs-keyword">import</span> observe <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./observe.js&#x27;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123;<br>        <span class="hljs-attr">c</span>: <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 递归入口 */</span><br><span class="hljs-title function_">observe</span>(obj)<br><br>obj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>)<br></code></pre></td></tr></table></figure><h3 id="observe-辅助函数"><a href="#observe-辅助函数" class="headerlink" title="observe 辅助函数"></a>observe 辅助函数</h3><p>作用: 1.判断递归出口    2.避免循环引用反复创建 Observer 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// \src\observe.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Observer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Observer&quot;</span><br><br><span class="hljs-comment">/* 创建 observe 函数 -- 作用: 1.判断递归出口    2.避免循环引用反复创建 Observer 实例 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 递归的出口</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">let</span> ob<br>    <span class="hljs-comment">// 防止循环引用</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value.<span class="hljs-property">__ob__</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>        ob = value.<span class="hljs-property">__ob__</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(value)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Observer-类"><a href="#Observer-类" class="headerlink" title="Observer 类"></a>Observer 类</h3><p>给 value __ob__ 属性, 遍历所有属性并调用 defineReactive 使它们变为响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// \src\Observer.js</span><br><br><span class="hljs-keyword">import</span> &#123; def &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span><br><span class="hljs-keyword">import</span> defineReactive <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./defineReactive&#x27;</span><br><br><span class="hljs-comment">/* Observer 类, 给 value __ob__ 属性, 遍历所有属性并调用 defineReactive 使它们变为响应式 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-comment">// this 为 new 的实例</span><br>        <span class="hljs-title function_">def</span>(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-variable language_">this</span>, <span class="hljs-literal">false</span>)   <span class="hljs-comment">// 目前 __ob__ 的意义好像只有在 observe 中判断循环引用</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Observer 构造器&#x27;</span>, value)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value)<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历所有键, 让其响应式</span><br>    <span class="hljs-title function_">walk</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> value) &#123;<br>            <span class="hljs-title function_">defineReactive</span>(value, k)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="defineReactive-函数"><a href="#defineReactive-函数" class="headerlink" title="defineReactive 函数"></a>defineReactive 函数</h3><p>让 data 变为响应式, 对每个 val 调用 observe, 开启递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// \src\defineReactive.js</span><br><br><span class="hljs-keyword">import</span> observe <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./observe.js&#x27;</span><br><br><span class="hljs-comment">/* 让 data 变为响应式, 对每个 val 调用 observe, 开启递归 */</span><br><span class="hljs-comment">// let val 临时变量也是可以的, 但是不美观, 可以封装到函数 defineReactive 中 , 也方便复用</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, val</span>) &#123;<br>    <span class="hljs-comment">// 没传 val 的话 就使用原有的值</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是 defineReactive&#x27;</span>, data, key)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>        val = data[key]<br>    &#125;<br><br>    <span class="hljs-comment">// 子元素要进行 observe, 至此形成递归. 这个递归是函数循环调用，不是自己调自己</span><br>    <span class="hljs-keyword">let</span> childOb = <span class="hljs-title function_">observe</span>(val)<br><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// getter</span><br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;访问&#x27;</span> + key + <span class="hljs-string">&#x27;属性&#x27;</span>)<br>            <span class="hljs-keyword">return</span> val<br>        &#125;,<br>        <span class="hljs-comment">// setter</span><br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;改变&#x27;</span> + key + <span class="hljs-string">&#x27;属性&#x27;</span>, newValue)<br>            <span class="hljs-keyword">if</span> (val === newValue) <span class="hljs-keyword">return</span><br>            val = newValue<br>            <span class="hljs-comment">// 当设置了新值, 新值也要 observe</span><br>            childOb = <span class="hljs-title function_">observe</span>(newValue)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>重写下 Object.defineProperty, 将 enumerable 变为参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// \src\utils.js</span><br><br><span class="hljs-comment">/* 重写下 Object.defineProperty, 将 enumerable 变为参数 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> def = <span class="hljs-keyword">function</span>(<span class="hljs-params">obj, key, value, enumerable</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>        value, <br>        enumerable,<br>        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="整个流程"><a href="#整个流程" class="headerlink" title="整个流程"></a>整个流程</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">执行<span class="hljs-built_in">observe</span>(obj)<br>├── new <span class="hljs-built_in">Observer</span>(obj),并执行this<span class="hljs-selector-class">.walk</span>()遍历obj的属性，执行<span class="hljs-built_in">defineReactive</span>()<br>    ├── <span class="hljs-built_in">defineReactive</span>(obj, a)<br>        ├── 执行<span class="hljs-built_in">observe</span>(obj.a) 发现obj<span class="hljs-selector-class">.a</span>不是对象，直接返回<br>        ├── 执行<span class="hljs-built_in">defineReactive</span>(obj, a) 的剩余代码(定义obj的a属性的响应式)<br>    ├── <span class="hljs-built_in">defineReactive</span>(obj, b) <br>    ├── 执行<span class="hljs-built_in">observe</span>(obj.b) 发现obj<span class="hljs-selector-class">.b</span>是对象<br>        ├── 执行 new <span class="hljs-built_in">Observer</span>(obj.b)，遍历obj<span class="hljs-selector-class">.b</span>的属性，执行<span class="hljs-built_in">defineReactive</span>()<br>                    ├── 执行<span class="hljs-built_in">defineReactive</span>(obj.b, c)<br>                        ├── 执行<span class="hljs-built_in">observe</span>(obj.b.c) 发现obj<span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.c</span>不是对象，直接返回<br>                        ├── 执行<span class="hljs-built_in">defineReactive</span>(obj.b, c)的剩余代码(定义obj.b的c属性的响应式)<br>            ├── 执行<span class="hljs-built_in">defineReactive</span>(obj, b)的剩余代码(定义obj的b属性的响应式)<br>代码执行结束<br></code></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>不是自己调用自己的递归，还是三个函数相互调用的循环</p><img src="/2022/07/10/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220710214346769.png" class="" title="image-20220710214346769"><p>当传入 observe 的值不是对象时跳出递归</p><h2 id="数组的响应式处理"><a href="#数组的响应式处理" class="headerlink" title="数组的响应式处理"></a>数组的响应式处理</h2><h3 id="为什么需要处理数组的响应式"><a href="#为什么需要处理数组的响应式" class="headerlink" title="为什么需要处理数组的响应式"></a>为什么需要处理数组的响应式</h3><p>正因为我们可以<strong>通过Array原型上的方法来改变数组的内容</strong>，所以 object 那种<strong>通过getter&#x2F;setter的实现方式就行不通了</strong>。</p><p>ES6 之前没有提供可以拦截原型方法的能力，我们可以用自定义的方法去覆盖原生的原型方法。</p><p><strong>Vue 是通过改写数组的七个方法（可以改变数组自身内容的方法）来实现对数组的响应式处理</strong></p><p>这些方法分别是：<strong>push、pop、shift、unshift、splice、sort、reverse</strong></p><h3 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h3><p>这七个方法都是定义在 Array.prototype上，要保留方法的功能，同时增加数据劫持的代码</p><p>思路就是 以 Array.prototype为原型，创建一个新对象 arrayMethods<br>然后在新对象arrayMethods上定义（改写）这些方法<br>定义 数组 的原型指向 arrayMethods</p><p>这就相当于用一个拦截器覆盖 Array.prototype，每当使用Array原型上的方法操作数组时，其实执行的是拦截器中提供的方法。在拦截器中使用原生Array的原型方法去操作数组。</p><h3 id="重写数组方法"><a href="#重写数组方法" class="headerlink" title="重写数组方法"></a>重写数组方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// array.js</span><br><span class="hljs-keyword">import</span> &#123; def &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span><br><br><span class="hljs-keyword">const</span> arrayPrototype = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><br><span class="hljs-comment">// 以 arrayPrototype 为原型创建 arrayMethods 对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(arrayPrototype)<br><br><span class="hljs-keyword">const</span> methodsNeedChange = [<br>    <span class="hljs-string">&#x27;push&#x27;</span>,<br>    <span class="hljs-string">&#x27;pop&#x27;</span>,<br>    <span class="hljs-string">&#x27;shift&#x27;</span>,<br>    <span class="hljs-string">&#x27;unshift&#x27;</span>,<br>    <span class="hljs-string">&#x27;splice&#x27;</span>,<br>    <span class="hljs-string">&#x27;sort&#x27;</span>,<br>    <span class="hljs-string">&#x27;reverse&#x27;</span><br>]<br><br>methodsNeedChange.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">methodName</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 备份原来的方法</span><br>    <span class="hljs-keyword">const</span> original = arrayPrototype[methodName]<br><br>    <span class="hljs-comment">// 定义新的方法</span><br>    <span class="hljs-title function_">def</span>(arrayMethods, methodName, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 恢复原来的功能</span><br>        <span class="hljs-keyword">const</span> result = original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>)<br><br>        <span class="hljs-comment">// 把这个数组身上的 __ob__ 取出来,</span><br>        <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span><br><br>        <span class="hljs-comment">// 有三种方法 push unshift splice 能插入新项, 要将新项变为 observe的</span><br>        <span class="hljs-comment">// inserted 用来存要插入的项</span><br>        <span class="hljs-keyword">let</span> inserted = []<br>        <br>        <span class="hljs-comment">// 根据方法名来判断要插入的项是什么并存入 inserted</span><br>        <span class="hljs-keyword">switch</span>(methodName) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;unshift&#x27;</span>:<br>                inserted = <span class="hljs-variable language_">arguments</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;splice&#x27;</span>:<br>                inserted = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>)<br>                <span class="hljs-keyword">break</span><br>        &#125;<br><br>        <span class="hljs-comment">// 判断有没有要插入的新项, 让新项也变为响应的</span><br>        <span class="hljs-keyword">if</span> (inserted.<span class="hljs-property">length</span>) &#123;<br>            ob.<span class="hljs-title function_">observeArray</span>(inserted)<br>        &#125;<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;啦啦啦&#x27;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    &#125;, <span class="hljs-literal">false</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="observeArray"><a href="#observeArray" class="headerlink" title="observeArray"></a>observeArray</h3><p>如果是数组的话走 observeArray 来遍历所有键；否则走 walk</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; def &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span><br><span class="hljs-keyword">import</span> defineReactive <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./defineReactive.js&#x27;</span><br><span class="hljs-keyword">import</span> &#123; arrayMethods &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./array.js&#x27;</span><br><span class="hljs-keyword">import</span> observe <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./observe.js&#x27;</span><br><br><span class="hljs-comment">/* Observer 类, 给 value __ob__ 属性, 遍历所有属性并调用 defineReactive 使它们变为响应式 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-comment">// this 为 new 的实例</span><br>        <span class="hljs-title function_">def</span>(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-variable language_">this</span>, <span class="hljs-literal">false</span>)   <span class="hljs-comment">// 目前 __ob__ 的意义好像只有在 observe 中判断循环引用</span><br><br>        <span class="hljs-comment">// 检查是数组还是对象</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>            <span class="hljs-comment">// 如果是数组, 将这个数组的原型指向 arrayMethods (arrayMethods的原型上的方法是改写过的)</span><br>            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(value, arrayMethods)<br>            <span class="hljs-comment">// 让这个数组变得 observe</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observeArray</span>(value)<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历所有键, 让其响应式</span><br>    <span class="hljs-title function_">walk</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> value) &#123;<br>            <span class="hljs-title function_">defineReactive</span>(value, k)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 数组的特殊遍历</span><br>    <span class="hljs-title function_">observeArray</span>(<span class="hljs-params">arr</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = arr.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>            <span class="hljs-comment">// 逐项 observe</span><br>            <span class="hljs-title function_">observe</span>(arr[i])<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>Dep 类</p><p>依赖收集，用来管理依赖</p><p>每个 Observer 的实例成员中都有一个 Dep 的实例</p><p>Watcher 类</p><p>中介，数据发生</p><img src="/2022/07/10/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220713134710965.png" class="" title="image-20220713134710965"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1G54y1s7xV/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=1616b746cefe2e7615c229563ba38eb4">https://www.bilibili.com/video/BV1G54y1s7xV/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=1616b746cefe2e7615c229563ba38eb4</a></p><p><a href="https://juejin.cn/post/6932659815424458760">https://juejin.cn/post/6932659815424458760</a></p><p><a href="https://blog.csdn.net/weixin_44972008/article/details/115922118">https://blog.csdn.net/weixin_44972008/article/details/115922118</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>Vue源码解读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双向绑定</tag>
      
      <tag>虚拟DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JS</title>
    <link href="/2022/07/10/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"/>
    <url>/2022/07/10/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/</url>
    
    <content type="html"><![CDATA[<h1 id="（更新中）"><a href="#（更新中）" class="headerlink" title="（更新中）"></a>（更新中）</h1><h1 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h1><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><h3 id="传统编译语言"><a href="#传统编译语言" class="headerlink" title="传统编译语言"></a>传统编译语言</h3><h4 id="分词-x2F-词法分析"><a href="#分词-x2F-词法分析" class="headerlink" title="分词&#x2F;词法分析"></a>分词&#x2F;词法分析</h4><p><strong>将由字符组成的字符串分解成有意义的代码块（词法单元 token）</strong></p><p>var a &#x3D; 2; 会被拆为 var、a、&#x3D;、2、；</p><h4 id="解析-x2F-语法分析"><a href="#解析-x2F-语法分析" class="headerlink" title="解析&#x2F;语法分析"></a>解析&#x2F;语法分析</h4><p><strong>将词法单元流（数组）转换成抽象语法树（Abstract Syntax Tree, AST）</strong></p><p>var a &#x3D; 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作NumericLiteral（它的值是2）的子节点。</p><h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p><strong>将 AST 转换为可执行代码的过程被称为代码生成。</strong></p><p>简单来说就是有某种方法可以将var a &#x3D; 2; 的 AST 转化为一组机器指令，用来创建一个叫作a 的变量（包括分配内存等），并将一个值储存在a 中。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><img src="你不知道的JS/image-20220710153154238.png" alt="image-20220710153154238" style="zoom:80%;" /><h3 id="JS-的编译过程"><a href="#JS-的编译过程" class="headerlink" title="JS 的编译过程"></a>JS 的编译过程</h3><p>复杂得多（时间短，需要优化性能）</p><p>对于JS来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳。</p><p>简单地说，任何JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript 编译器首先会对var a &#x3D; 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。</p><h3 id="处理工具"><a href="#处理工具" class="headerlink" title="处理工具"></a>处理工具</h3><h4 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h4><p>从头到尾负责整个JavaScript 程序的编译及执行过程。</p><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>负责<strong>语法分析及代码生成</strong>等</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>负责<strong>收集并维护由所有声明的标识符（变量）组成的一系列查询</strong>，并实施一套非常严格的规则，<strong>确定</strong>当前执行的代码对这些标识符的<strong>访问权限</strong>。</p><h3 id="var-a-x3D-2-后发生了什么"><a href="#var-a-x3D-2-后发生了什么" class="headerlink" title="var a &#x3D; 2 后发生了什么"></a>var a &#x3D; 2 后发生了什么</h3><p>编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。然后开始生成代码。</p><p>在生成代码的过程中：变量的赋值操作会执行两个动作。</p><ol><li><p>首先编译器会在当前作用域中声明一个变量（如果之前没有声明过，否则忽略声明继续编译）</p></li><li><p>然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值（找不到就抛出异常）。</p></li></ol><p><strong>引擎如何查找变量</strong></p><p><strong>LHS 查询</strong></p><p>如果查找的目的是对变量进行赋值，那么就会使用LHS 查询</p><p>a &#x3D; 2</p><p><strong>RHS 查询</strong></p><p>如果目的是获取变量的值，就会使用RHS 查询。</p><p>console.log(a)</p><h2 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h2><h3 id="作用域-2"><a href="#作用域-2" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是根据名称查找变量的一套规则。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a><strong>作用域链</strong></h3><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>大部分标准语言编译器的第一个工作阶段叫作词法化</p><p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，是静态的。</p><h3 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h3><p><strong>欺骗词法作用域会导致性能下降</strong></p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>动态生成代码（即通过代码生成代码）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str, a</span>) &#123;<br>    <span class="hljs-built_in">eval</span>( str ); <span class="hljs-comment">// 欺骗！</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a, b );<br>&#125;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-title function_">foo</span>( <span class="hljs-string">&quot;var b = 3;&quot;</span>, <span class="hljs-number">1</span> ); <span class="hljs-comment">// 1, 3</span><br></code></pre></td></tr></table></figure><p>严格模式下，eval(..) 在运行时有其自己的词法作用域，无法欺骗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <span class="hljs-built_in">eval</span>( str );<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// ReferenceError: a is not defined</span><br>&#125;<br><span class="hljs-title function_">foo</span>( <span class="hljs-string">&quot;var a = 2&quot;</span> );<br></code></pre></td></tr></table></figure><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。</p><p>严格模式禁止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-comment">// 单调乏味的重复&quot;obj&quot;</span><br>obj.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;<br>obj.<span class="hljs-property">b</span> = <span class="hljs-number">3</span>;<br>obj.<span class="hljs-property">c</span> = <span class="hljs-number">4</span>;<br><span class="hljs-comment">// 简单的快捷方式</span><br><span class="hljs-keyword">with</span> (obj) &#123;<br>    a = <span class="hljs-number">3</span>;<br>    b = <span class="hljs-number">4</span>;<br>    c = <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在全局变量泄露的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">with</span> (obj) &#123;<br>        a = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> o1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-keyword">var</span> o2 = &#123;<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-title function_">foo</span>( o1 );<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( o1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2</span><br><span class="hljs-title function_">foo</span>( o2 );<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( o2.<span class="hljs-property">a</span> ); <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2——a 被泄漏到全局作用域上了</span><br></code></pre></td></tr></table></figure><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>性能很差，不要使用！</p><p>原因：JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。使用 eval 或 with 会使他们失效。</p>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>作用域</tag>
      
      <tag>this</tag>
      
      <tag>对象</tag>
      
      <tag>原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/07/09/Git/"/>
    <url>/2022/07/09/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><img src="/2022/07/09/Git/image-20220709160235846.png" class="" title="image-20220709160235846"><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="用户设置"><a href="#用户设置" class="headerlink" title="用户设置"></a>用户设置</h3><p><strong>设置用户名</strong></p><p>git config –global user.name lwj</p><p><strong>设置邮箱</strong></p><p>git config –global user.email <a href="mailto:&#54;&#49;&#57;&#x35;&#48;&#x30;&#x38;&#x32;&#56;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#109;">&#54;&#49;&#57;&#x35;&#48;&#x30;&#x38;&#x32;&#56;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#109;</a></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>git init</p><p>多了一个 .git 文件夹，git 的所有记录都在此文件夹中</p><p>默认位于 master (主分支)</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>echo “版本1” &gt; lao.md</p><p>lao.md 为我们创建的文件；版本1 为在文件中添加的内容</p><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><p>git status</p><p>用于查看目前分支，以及需要做什么步骤</p><img src="/2022/07/09/Git/image-20220709161701963.png" class="" title="image-20220709161701963"><p>处于 master 分支</p><p>刚刚添加的文件 lao.md 为 untracked files，需要添加到缓存区</p><h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><p>git add lao.md</p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p>git commit会进入 vim 编辑器</p><p>git commit -m “版本2和版本3”加上 -m 和提交信息 则不会进入 vim</p><h3 id="查看之前版本"><a href="#查看之前版本" class="headerlink" title="查看之前版本"></a>查看之前版本</h3><p>git log</p><img src="/2022/07/09/Git/image-20220709162553790.png" class="" title="image-20220709162553790"><h3 id="不需要提交的文件"><a href="#不需要提交的文件" class="headerlink" title="不需要提交的文件"></a>不需要提交的文件</h3><p>创建 .gitignore 文件</p><p>echo &gt; .gitignore</p><p>在 .gitignore 中写上不想提交的文件 rubbish.md，git status 后就不会显示该文件了</p><img src="/2022/07/09/Git/image-20220709163820131.png" class="" title="image-20220709163820131"><p>配置 .gitignore 后</p><img src="/2022/07/09/Git/image-20220709163829783.png" class="" title="image-20220709163829783"><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>一个分支代表一条独立的开发线。</p><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><img src="/2022/07/09/Git/image-20220709164756819.png" class="" title="image-20220709164756819"><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>git branch 分支名</p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><p>git branch</p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>git checkout 分支名</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>git branch -d 分支名（会有提示）</p><p>git branch -D 分支名（不会有提示，非常确定要删除时使用）</p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>把别的分支合并到当前所处分支</p><p>git merge 分支名</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="拷贝远程仓库到本地"><a href="#拷贝远程仓库到本地" class="headerlink" title="拷贝远程仓库到本地"></a>拷贝远程仓库到本地</h3><p>直接 download，则版本历史和记录(.git)不会下载</p><p>使用 git clone url 更好</p><h3 id="查看本地仓库与远程仓库的联系"><a href="#查看本地仓库与远程仓库的联系" class="headerlink" title="查看本地仓库与远程仓库的联系"></a>查看本地仓库与远程仓库的联系</h3><p>git remote -v</p><h3 id="更新远程仓库"><a href="#更新远程仓库" class="headerlink" title="更新远程仓库"></a>更新远程仓库</h3><p>git push</p><p>2021年后不支持通过账号密码，而要生成个人 token</p><h3 id="更新本地仓库"><a href="#更新本地仓库" class="headerlink" title="更新本地仓库"></a>更新本地仓库</h3><p>git fetch (远程仓库&#x2F;分支名)更新本地仓库，本地文件（工作区）并不会改变</p><p>git diff 远程仓库名&#x2F;分支名查看工作区和本地仓库的区别</p><p>如果没问题则可使用 git pull 把远程仓库的内容直接整合到工作区</p><h2 id="vscode-中的-git"><a href="#vscode-中的-git" class="headerlink" title="vscode 中的 git"></a>vscode 中的 git</h2><p>初始化仓库</p><p>相当于 git init</p><img src="/2022/07/09/Git/image-20220709170218325.png" class="" title="image-20220709170218325"><p>一些操作</p><img src="/2022/07/09/Git/image-20220709170748070.png" class="" title="image-20220709170748070"><p>左下角切换分支</p><img src="/2022/07/09/Git/image-20220709171256207.png" class="" title="image-20220709171256207"><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><p>stash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>1.需要临时切分支时</p><p>2.多人同时修改同一分支时</p><img src="/2022/07/09/Git/image-20221026215721434.png" class="" title="image-20221026215721434"><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 保存当前未commit的代码</span><br>git stash<br><br><span class="hljs-comment"># 保存当前未commit的代码并添加备注</span><br>git stash save <span class="hljs-string">&quot;备注的内容&quot;</span><br><br><span class="hljs-comment"># 列出stash的所有记录</span><br>git stash list<br><br><span class="hljs-comment"># 删除stash的所有记录</span><br>git stash clear<br><br><span class="hljs-comment"># 应用最近一次的stash</span><br>git stash apply<br><br><span class="hljs-comment"># 应用最近一次的stash，随后删除该记录</span><br>git stash pop<br><br><span class="hljs-comment"># 删除最近的一次stash</span><br>git stash drop<br>复制代码<br></code></pre></td></tr></table></figure><p>当有多条 stash，可以指定操作stash，首先使用stash list 列出所有记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git stash list<br>stash@&#123;0&#125;: WIP on ...<br>stash@&#123;1&#125;: WIP on ...<br>stash@&#123;2&#125;: On ...<br>复制代码<br></code></pre></td></tr></table></figure><p>应用第二条记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git stash apply stash@&#123;1&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>pop，drop 同理。</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a><a href="https://blog.csdn.net/weixin_45032067/article/details/124621305">版本回退</a></h2><p><strong>场景一：如果想将代码恢复到之前某个提交的版本，且那个版本之后提交的版本都不要了，就可以使用 git reset</strong></p><p><strong>原理：</strong> git <a href="https://so.csdn.net/so/search?q=reset&spm=1001.2101.3001.7020">reset</a> 的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本</p><p><strong>操作：</strong></p><ol><li>查看版本号：git log，也可以上代码托管网页上查看history，找到需要回滚的目标版本号</li><li>使用“git reset –hard 目标版本号”命令将版本回退</li><li>使用“git push -f”提交更改，此时如果用“git push”会报错，因为我们本地库HEAD指向的版本比远程库的要旧，用“git push -f”强制推上去。</li></ol><p><strong>场景二：如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。</strong></p><p><strong>原理：</strong>我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。</p><p><strong>操作：</strong></p><ol><li><p>查看版本号：git log，也可以上代码托管网页上查看history，找到需要撤销的目标版本号</p></li><li><p>使用“git revert -n 版本号”反做，并使用“git commit -m 版本名”提交：<br>  （1）反做，使用“git revert -n 版本号”命令。</p></li></ol><p>  注意： 这里可能会出现冲突，那么需要手动修改冲突的文件。而且要git add 文件名。<br>  （2）提交，使用“git commit -m 版本名”</p><ol start="3"><li>使用“git push”推上远程库：</li></ol><h2 id="使用顺序注意"><a href="#使用顺序注意" class="headerlink" title="使用顺序注意"></a>使用顺序注意</h2><p><a href="https://blog.csdn.net/aaaaa1994/article/details/90340224">https://blog.csdn.net/aaaaa1994/article/details/90340224</a> 实习期间遇到了同样的问题</p><p>1.本地修改与远程代码无冲突，优先使用</p><p>pull -&gt; commit -&gt; push</p><p><strong>2.本地修改与远程代码有冲突，优先使用</strong></p><p>commit -&gt; pull -&gt; push</p><p>pull 是为了本地 commit 和远程 commit 的对比记录</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.337.search-card.all.click&amp;vd_source=1616b746cefe2e7615c229563ba38eb4">https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.337.search-card.all.click&amp;vd_source=1616b746cefe2e7615c229563ba38eb4</a></p><p><a href="https://www.runoob.com/git/git-basic-operations.html">https://www.runoob.com/git/git-basic-operations.html</a></p><p><a href="https://juejin.cn/post/7157754634746986504">https://juejin.cn/post/7157754634746986504</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3</title>
    <link href="/2022/07/01/vue3/"/>
    <url>/2022/07/01/vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h1><h2 id="构建与结构"><a href="#构建与结构" class="headerlink" title="构建与结构"></a>构建与结构</h2><h3 id="使用-vite-快速构建一个-vue3-项目"><a href="#使用-vite-快速构建一个-vue3-项目" class="headerlink" title="使用 vite 快速构建一个 vue3 项目"></a>使用 vite 快速构建一个 vue3 项目</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>初始化<br><span class="hljs-regexp">//</span> yarn create vite<br><span class="hljs-built_in">npm</span> init vite@latest<br><br><span class="hljs-number">2.</span>进入文件夹后安装依赖包<br><span class="hljs-built_in">npm</span> install<br><br><span class="hljs-number">3.</span>启动()<br><span class="hljs-built_in">npm</span> run dev<br></code></pre></td></tr></table></figure><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>vue2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;)<br>vm.$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>vue3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入的不再是Vue构造函数了，引入的是一个名为createApp的工厂函数</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">//创建应用实例对象——app(类似于之前Vue2中的vm，但app比vm更“轻”)</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br><span class="hljs-comment">//挂载</span><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br><span class="hljs-comment">// 卸载</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    app.<span class="hljs-title function_">unmount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h2 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h2><h3 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h3><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><ol><li><p>Vue3.0 中的新配置项，值为一个函数</p></li><li><p>组件中所用到的数据、方法等都要配置在 setup 中</p></li><li><p>setup 函数有两种返回值：</p></li></ol><p><strong>返回一个对象，对象中的属性、方法，在模板中均可直接使用</strong></p><p>返回一个渲染函数，可以自定义渲染内容（较少使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;h1&gt;信息：&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;sayHello&quot;&gt;说话&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; h &#125; from &#x27;vue&#x27;<br><br>export default &#123;<br>    name: &#x27;App&#x27;,<br><br>    // 这样的数据无响应式<br>    setup() &#123;<br>        // 数据<br>        let name = &#x27;张三&#x27;<br>        let age = 18<br><br>        // 方法<br>        function sayHello() &#123;<br>            alert(`我叫xxx$&#123;name&#125;, 我$&#123;age&#125;岁了`)<br>        &#125;<br><br>        // 返回一个对象<br>        /* return &#123;<br>            name,<br>            age,<br>            sayHello<br>        &#125; */<br><br>        // 返回一个函数 (渲染函数)<br>        return () =&gt; &#123;return h(&#x27;h1&#x27;, &#x27;尚硅谷&#x27;)&#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>vue2 中定义 data &#x2F; methods 都是键值对形式的，因为本身式对象（所以不需要 let &#x2F; function）</p><p>vue3 setup是一个函数，所以里面的数据和方法都是需要定义的。并且 setup 不能用 async 定义。</p><h5 id="setup-的两个参数"><a href="#setup-的两个参数" class="headerlink" title="setup 的两个参数"></a>setup 的两个参数</h5><p>props 和 context </p><p>context 里有三个属性：attrs、emit、slots</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">export default &#123;<br>name: &#x27;Demo&#x27;,<br>props:[&#x27;msg&#x27;,&#x27;school&#x27;],<br>    emits:[&#x27;hello&#x27;],<br>    setup(props,&#123;attrs, emit, slots&#125;)&#123;&#125;<br></code></pre></td></tr></table></figure><p>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</p><p>context：上下文对象</p><p>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。</p><p>slots: 收到的插槽内容, 相当于 this.$slots。</p><p>emit: 分发自定义事件的函数, 相当于 this.$emit。</p><p><strong><a href="https://blog.csdn.net/LueLueLue77/article/details/124964058">context 里还有 expose</a></strong></p><p>expose可以使父组件直接去修改子组件的数据</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p><strong>作用：定义一个响应式数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;h1&gt;信息：&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>&lt;h3&gt;工作种类：&#123;&#123;job.type&#125;&#125;&lt;/h3&gt;<br>&lt;h3&gt;工作薪水：&#123;&#123;job.salary&#125;&#125;&lt;/h3&gt;<br>    &lt;button @click=&quot;changeInfo&quot;&gt;修改人的信息&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    import &#123;ref&#125; from &#x27;vue&#x27;<br><br>    export default &#123;<br>        name: &#x27;App&#x27;,<br><br>        // 这样的数据无响应式<br>        setup() &#123;<br>            // 数据<br>let name = ref(&#x27;张三&#x27;)<br>let age = ref(23)<br>let job = ref(&#123;<br>type:&#x27;前端&#x27;,<br>salary:&#x27;20K&#x27;<br>&#125;)<br><br>            // 方法<br>            function changeInfo() &#123;<br>                name.value = &#x27;李四&#x27;<br>                age.value = 33<br>                job.value.type = &#x27;算法&#x27;<br>                job.value.salary = &#x27;30K&#x27;<br>            &#125;<br><br>            // 返回一个对象<br>            return &#123;<br>                name,<br>                age,<br>                job,<br>                changeInfo<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>为什么修改数据需要 .value？</strong></p><p>被 ref 包裹的数据变为了对象，是 RefImpl (reference implement) 的实例，可称为引用对象，就实现响应式了。</p><img src="/2022/07/01/vue3/image-20220701143037245.png" class="" title="image-20220701143037245"><p><strong>为什么 html 部分不需要 .value？</strong></p><p>检测到是响应式数据后，会自动解析</p><p><strong>ref 处理对象类型用的 proxy（操作封装在 reactive 函数中），简单类型还是用的 object.defineProperty（本身object.defineProperty的问题就在于对象&#x2F;数组）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// name是简单数据类型, job是对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-property">value</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(job.<span class="hljs-property">value</span>)<br></code></pre></td></tr></table></figure><img src="/2022/07/01/vue3/image-20220701150926114.png" class="" title="image-20220701150926114"><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><p><strong>作用：定义一个&#x3D;&#x3D;对象类型&#x3D;&#x3D;的响应式数据</strong></p><p>对象使用 reactive 而不是用 ref ，可以少写 .value</p><p><strong>语法：</strong>const 代理对象&#x3D; reactive(源对象)接收一个对象（或数组），<strong>返回一个代理对象</strong>（Proxy的实例对象）。</p><p>通过代理对象修改源对象。</p><p><strong>可以将多个简单数据类型封装为一个对象使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;h1&gt;信息：&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;<br>&lt;h3&gt;工作种类：&#123;&#123;person.job.type&#125;&#125;&lt;/h3&gt;<br>&lt;h3&gt;工作薪水：&#123;&#123;person.job.salary&#125;&#125;&lt;/h3&gt;<br>    &lt;h3&gt;爱好：&#123;&#123;person.hobby&#125;&#125;&lt;/h3&gt;<br>    &lt;h3&gt;测试的数据c：&#123;&#123;person.job.a.b.c&#125;&#125;&lt;/h3&gt;<br>    &lt;button @click=&quot;changeInfo&quot;&gt;修改人的信息&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    import &#123;reactive&#125; from &#x27;vue&#x27;<br><br>    export default &#123;<br>        name: &#x27;App&#x27;,<br><br>        setup() &#123;<br>            let person = reactive(&#123;<br>                name: &#x27;张三&#x27;,<br>                age: 28,<br>                job: &#123;<br>                    type:&#x27;前端&#x27;,<br>                    salary:&#x27;20K&#x27;,<br>                    a: &#123;<br>                        b: &#123;<br>                            c: 666<br>                        &#125;<br>                    &#125;<br>                &#125;,<br>                hobby: [&#x27;抽烟&#x27;, &#x27;喝酒&#x27;, &#x27;烫头&#x27;]<br>            &#125;)<br>           <br>            // 方法<br>            function changeInfo() &#123;<br>                person.name = &#x27;李四&#x27;,<br>                person.age = 48,<br>                person.job.type = &#x27;算法&#x27;,<br>                person.job.salary = &#x27;30K&#x27;<br>                person.job.a.b.c = 999,<br>                person.hobby[0] = &#x27;学习&#x27;<br>            &#125;<br><br>            // 返回一个对象<br>            return &#123;<br>                person,<br>                changeInfo<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><h5 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h5><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, <span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>    get () &#123;&#125;, <br>    set () &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h5 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h5><ul><li><p>实现原理: </p><ul><li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p></li><li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p></li><li><p>MDN文档中描述的Proxy与Reflect：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br><span class="hljs-comment">// 拦截读取属性值</span><br>    get (target, prop) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截设置属性值或添加新属性</span><br>    set (target, prop, value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, prop, value)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截删除属性</span><br>    deleteProperty (target, prop) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, prop)<br>    &#125;<br>&#125;)<br><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;tom&#x27;</span>   <br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="reactive与ref"><a href="#reactive与ref" class="headerlink" title="reactive与ref"></a>reactive与ref</h4><ul><li><p>从定义数据角度对比：</p><ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li><p>从原理角度对比：</p><ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li><p>从使用角度对比：</p><ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li><li><p>从是否丢失相应性对比：</p><ul><li><p>refactive 被传递给函数或是从一般对象上被解构时，不会丢失响应性。</p></li><li><p>ref 被传递给函数或是从一般对象上被解构时，不会丢失响应性。</p></li></ul><p><strong>简言之，<code>ref()</code> 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。</strong></p></li></ul><h4 id="ref-实验中"><a href="#ref-实验中" class="headerlink" title="$ref(实验中)"></a>$ref(实验中)</h4><p>相对于普通的 JavaScript 变量，我们不得不用相对繁琐的 <code>.value</code> 来获取 ref 的值。这是一个受限于 JavaScript 语言限制的缺点。然而，通过编译时转换，我们可以让编译器帮我们省去使用 <code>.value</code> 的麻烦。Vue 提供了一种编译时转换，使得我们可以像这样书写之前的“计数器”示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue3">&lt;script setup&gt;<br>let count = $ref(0)<br><br>function increment() &#123;<br>  // 无需 .value<br>  count++<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h4 id="setup-注意点"><a href="#setup-注意点" class="headerlink" title="setup 注意点"></a>setup 注意点</h4><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul><img src="/2022/07/01/vue3/image-20220701211921826.png" class="" title="image-20220701211921826"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params">props,context</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---setup---&#x27;</span>,context)<br>    <br>    <span class="hljs-comment">//数据</span><br>    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<br>        <span class="hljs-attr">age</span>:<span class="hljs-number">18</span><br>    &#125;)<br><br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>        context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">666</span>)<br>    &#125;<br><br>    <span class="hljs-comment">//返回一个对象</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        person,<br>        test<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;computed&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>    ...<br><span class="hljs-comment">//计算属性——简写(没有考虑计算属性被修改的情况)</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>    &#125;)<br>    <span class="hljs-comment">//计算属性——完整</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(&#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>            <span class="hljs-keyword">const</span> nameArr = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br>            person.<span class="hljs-property">firstName</span> = nameArr[<span class="hljs-number">0</span>]<br>            person.<span class="hljs-property">lastName</span> = nameArr[<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;)<br>    <br>    <span class="hljs-keyword">return</span> &#123;<br>        fullName<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</p><p>监视reactive定义的响应式数据中某个属性时：deep配置有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//情况一：监视ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>(sum,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-comment">//情况二：监视多个ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>([sum,msg],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)<br>&#125;) <br><br><span class="hljs-comment">/* 情况三：监视reactive定义的响应式数据</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-title function_">watch</span>(person,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">false</span>&#125;) <span class="hljs-comment">//此处的deep配置不再奏效</span><br><br><span class="hljs-comment">//情况四：监视reactive定义的响应式数据中的某个属性</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <br><br><span class="hljs-comment">//情况五：监视reactive定义的响应式数据中的某些属性</span><br><span class="hljs-title function_">watch</span>([<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">name</span>],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-comment">//特殊情况</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <span class="hljs-comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span><br></code></pre></td></tr></table></figure><h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h4><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：<strong>不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性</strong>。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> x1 = sum.<span class="hljs-property">value</span><br>    <span class="hljs-keyword">const</span> x2 = person.<span class="hljs-property">age</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;watchEffect配置的回调执行了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><strong>vue2</strong></p><img src="/2022/07/01/vue3/image-20220708144649496.png" class="" title="image-20220708144649496"><p><strong>vue3</strong></p><img src="/2022/07/01/vue3/image-20220708144757189.png" class="" title="image-20220708144757189"><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>created</code>&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>beforeMount</code> &#x3D;&#x3D;&gt;<code>onBeforeMount</code></li><li><code>mounted</code>&#x3D;&#x3D;&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li><li><code>updated </code>&#x3D;&#x3D;&gt;<code>onUpdated</code></li><li><code>beforeUnmount </code>&#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li><li><code>unmounted </code>&#x3D;&#x3D;&gt;<code>onUnmounted</code></li></ul></li></ul><h4 id="hook函数"><a href="#hook函数" class="headerlink" title="hook函数"></a>hook函数</h4><ul><li>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</li><li>类似于vue2.x中的mixin。</li><li>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</li></ul><p>一般写在 hooks 文件夹中，以 use 为开头命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// hooks/usePoint.js</span><br><span class="hljs-keyword">import</span> &#123;reactive,onMounted,onBeforeUnmount&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//实现鼠标“打点”相关的数据</span><br><span class="hljs-keyword">let</span> point = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">x</span>:<span class="hljs-number">0</span>,<br><span class="hljs-attr">y</span>:<span class="hljs-number">0</span><br>&#125;)<br><br><span class="hljs-comment">//实现鼠标“打点”相关的方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">savePoint</span>(<span class="hljs-params">event</span>)&#123;<br>point.<span class="hljs-property">x</span> = event.<span class="hljs-property">pageX</span><br>point.<span class="hljs-property">y</span> = event.<span class="hljs-property">pageY</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">pageX</span>,event.<span class="hljs-property">pageY</span>)<br>&#125;<br><br><span class="hljs-comment">//实现鼠标“打点”相关的生命周期钩子</span><br><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,savePoint)<br>&#125;)<br><br><span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,savePoint)<br>&#125;)<br><br><span class="hljs-keyword">return</span> point<br>&#125;<br></code></pre></td></tr></table></figure><p>组件使用时引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;h2&gt;当前点击时鼠标的坐标为：x：&#123;&#123;point.x&#125;&#125;，y：&#123;&#123;point.y&#125;&#125;&lt;/h2&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import usePoint from &#x27;../hooks/usePoint&#x27;<br>export default &#123;<br>name:&#x27;Test&#x27;,<br>setup()&#123;<br>const point = usePoint()<br>return &#123;point&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h4><ul><li><p>作用：<strong>创建一个 ref 对象，其value值指向另一个对象中的某个属性</strong>。<strong>（引用）</strong></p></li><li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p></li><li><p>应用:   <strong>要将响应式对象中的某个属性单独提供给外部使用时</strong>。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h4><ul><li><p>作用：将回调推迟到下一个DOM更新周期之后执行</p></li><li><p>常用情况</p></li></ul><p>1.页面首次渲染时，setup中有数据依赖于DOM的信息</p><p>2.数据发生改变，等待DOM更新后立即使用</p><ul><li>使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以 页面首次渲染时，setup中有数据依赖于DOM的信息 为例</span><br><span class="hljs-keyword">import</span> &#123; nextTick &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> height = ref&lt;number&gt;(<span class="hljs-number">0</span>)<br>    <span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;box&#x27;</span>)[<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span><br>        height.<span class="hljs-property">value</span> = box.<span class="hljs-property">offsetHeight</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他-API"><a href="#其他-API" class="headerlink" title="其他 API"></a>其他 API</h3><h4 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a>shallowReactive 与 shallowRef</h4><ul><li>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</li><li>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</li></ul><p>Ref 处理对象会向 Reactive 求助，而 shallowRef 并不会</p><ul><li>什么时候使用?<ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li></ul></li></ul><h4 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h4><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h4 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h4><ul><li>toRaw：<ul><li>作用：将一个由<strong>reactive</strong>生成的<strong>响应式对象</strong>转为<strong>普通对象</strong>。(ref 定义的会变成undefined)</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其<strong>永远不会再成为响应式对象</strong>。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h4 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h4><ul><li><p>作用：创建一个<strong>自定义 ref</strong>，并对其依赖项跟踪和更新触发进行显式控制（自定义 get 和 set 逻辑）。</p></li><li><p>实现防抖效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;input type=&quot;text&quot; v-model=&quot;keyWord&quot;&gt;<br>&lt;h3&gt;&#123;&#123;keyWord&#125;&#125;&lt;/h3&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; clear &#125; from &#x27;console&#x27;<br>import &#123;ref, customRef&#125; from &#x27;vue&#x27;<br>export default &#123;<br>name: &#x27;App&#x27;,<br>setup() &#123;<br>// 自定义 ref<br>function myRef(value, delay) &#123;<br>let timer<br>// 不可能从头写底层, 实际上实在 customRef 上去修改（自定义）, 将定义好的返回出去使用<br>return customRef((track, trigger) =&gt; &#123;<br>// 语法要求 返回一个对象<br>return &#123;<br>get() &#123;<br>track()// 通知 vue 追踪数据(value)变化<br>return value<br>&#125;,<br>set(newValue) &#123;<br>clearTimeout(timer)<br>setTimeout(() =&gt; &#123;<br>value = newValue<br>trigger()// 通知 vue 重新解析模板<br>&#125;, delay);<br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br>// let keyWord = ref(&#x27;hello&#x27;)// vue 内置的 ref<br>let keyWord = myRef(&#x27;hello&#x27;)// 自定义 ref<br>return &#123;keyWord&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h4><img src="/2022/07/01/vue3/image-20220708143202180.png" class="" title="image-20220708143202180"><ul><li><p>作用：实现<strong>祖先与后代组件间通信</strong></p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>......<br>    <span class="hljs-keyword">let</span> car = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;奔驰&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-string">&#x27;40万&#x27;</span>&#125;)<br>    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;car&#x27;</span>,car)<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params">props,context</span>)&#123;<br>......<br>    <span class="hljs-keyword">const</span> car = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;car&#x27;</span>)<br>    <span class="hljs-keyword">return</span> &#123;car&#125;<br>......<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul><h4 id="响应式数据的判断"><a href="#响应式数据的判断" class="headerlink" title="响应式数据的判断"></a>响应式数据的判断</h4><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h2 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h2><h3 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h3><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><img src="/2022/07/01/vue3/f84e4e2c02424d9a99862ade0a2e4114tplv-k3u1fbpfcp-watermark.image" class="" title="img"><img src="/2022/07/01/vue3/e5ac7e20d1784887a826f6360768a368tplv-k3u1fbpfcp-watermark.image" class="" title="img"><h3 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h3><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><img src="/2022/07/01/vue3/bc0be8211fc54b6c941c036791ba4efetplv-k3u1fbpfcp-watermark-165726304478210.image" class="" title="img"><img src="/2022/07/01/vue3/6cc55165c0e34069a75fe36f8712eb80tplv-k3u1fbpfcp-watermark-165726305601013.image" class="" title="img"><h2 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h2><h3 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h3><ul><li>在Vue2中: 组件必须有一个根标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;h3&gt;App组件&lt;/h3&gt;<br>        &lt;h4&gt;123&lt;/h4&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ul><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个 <strong>Fragment 虚拟元素</strong>中，fragment 标签编译完后不会出现在 dom 树中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;h3&gt;App组件&lt;/h3&gt;<br>&lt;h4&gt;123&lt;/h4&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ul><li>好处: 减少标签层级, 减小内存占用</li></ul><h3 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h3><ul><li><p>什么是Teleport</p><p>Teleport是一种能够<strong>将组件的html结构移动到指定位置</strong>的技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;teleport to=&quot;移动位置&quot;&gt;<br>&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;<br>&lt;div class=&quot;dialog&quot;&gt;<br>&lt;h3&gt;我是一个弹窗&lt;/h3&gt;<br>&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/teleport&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h3><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p><p>静态引入需等所有组件全部引入完毕，一起显示（木桶原理），异步引入（动态引入）则可以先显示引入好的组件</p><p>但是用户并不知道页面是否还有组件没有加载完毕，而且组件加载完毕后突然出现，效果并不好。可以使用 Suspense 包裹，底层通过插槽实现。</p><ul><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;defineAsyncComponent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code>。default 包裹的是异步组件，fallback 包裹的是当异步组件还没加载完毕时，页面显示的静态组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;app&quot;&gt;<br>&lt;h3&gt;我是App组件&lt;/h3&gt;<br>&lt;Suspense&gt;<br>&lt;template v-slot:default&gt;<br>&lt;Child/&gt;<br>&lt;/template&gt;<br>&lt;template v-slot:fallback&gt;<br>&lt;h3&gt;加载中.....&lt;/h3&gt;<br>&lt;/template&gt;<br>&lt;/Suspense&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h3><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//注册全局组件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyButton&#x27;</span>, &#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;),<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">//注册全局指令</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-attr">inserted</span>: <span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-title function_">focus</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h3 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h3><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.v-enter</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.v-leave</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.v-enter-from</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.v-leave-from</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;my-component<br>  v-on:close=&quot;handleComponentEvent&quot;<br>  v-on:click=&quot;handleNativeClickEvent&quot;<br>/&gt;<br></code></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    emits: [&#x27;close&#x27;]// 不声明 click 说明是原生事件<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul><h2 id="一些重要操作"><a href="#一些重要操作" class="headerlink" title="一些重要操作"></a>一些重要操作</h2><h3 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a><a href="https://blog.csdn.net/m0_50789696/article/details/125168752">全局事件总线</a></h3><p>Vue3从实例中移除了 $on、$off 和 $once 方法，所以我们如果希望继续使用全局事件总线，要通过第三方的库：<br>Vue3官方有推荐一些库，例如 mitt </p><h4 id="1-安装-mitt"><a href="#1-安装-mitt" class="headerlink" title="1.安装 mitt"></a>1.安装 mitt</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> mitt<br></code></pre></td></tr></table></figure><h4 id="2-两种使用方式"><a href="#2-两种使用方式" class="headerlink" title="2.两种使用方式"></a><a href="https://www.bilibili.com/read/cv15580240/">2.两种使用方式</a></h4><h5 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h5><p>挂载到 app 上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> bus = <span class="hljs-title function_">mitt</span>()<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br>app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$bus</span> = bus<br>app.<span class="hljs-title function_">use</span>(store).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 兄弟组件 bro1 --&gt;<br>&lt;script&gt;<br>    import &#123;getCurrentInstance&#125; from &#x27;vue&#x27;;<br>    export default &#123;<br>        setup(props) &#123;<br>            const ins=getCurrentInstance()<br>            const bus=ins.appContext.config.globalProperties.$bus<br>            function passE()&#123;<br>          // 触发事件<br>                bus.emit(&#x27;bro&#x27;,&#x27;xwl&#x27;)<br>            &#125;<br>            return &#123;<br>                passE<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br><br>&lt;!-- 兄弟组件 bro2 --&gt;<br>&lt;script&gt;<br>    import &#123;getCurrentInstance&#125; from &#x27;vue&#x27;;<br>    export default &#123;<br>        setup(props) &#123;<br>            const ins=getCurrentInstance()<br>            const bus=ins.appContext.config.globalProperties.$bus<br>            onMounted(()=&gt;&#123;<br>                // 绑定事件<br>                bus.on(&#x27;bro&#x27;,(value)=&gt;&#123;<br>                    console.log(value);<br>                &#125;)<br>            &#125;)<br>            return &#123; &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="局部引入"><a href="#局部引入" class="headerlink" title="局部引入"></a>局部引入</h5><p>不与 vue 建立连接</p><ol><li><strong>封装 eventBus.js，可以放在 utils 下面</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> mitt <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mitt&#x27;</span>;<br><br><span class="hljs-keyword">const</span> emitter = <span class="hljs-title function_">mitt</span>();<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> emitter<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>使用</strong></li></ol><p><strong>导入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils/eventbus&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>触发事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;event&quot;</span>, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;);<br></code></pre></td></tr></table></figure><p><strong>监听事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;event&quot;</span>, <span class="hljs-function">(<span class="hljs-params">info</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;event:&quot;</span>, info)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>移除事件监听</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">emitter.<span class="hljs-property">all</span>.<span class="hljs-title function_">clear</span>()<br></code></pre></td></tr></table></figure><p><strong>指定监听移除</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onEvent</span>(<span class="hljs-params"></span>)&#123;&#125;<br>emitter.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;event&quot;</span>, onEvent);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm nvm nrm</title>
    <link href="/2022/06/30/npm-nvm-nrm/"/>
    <url>/2022/06/30/npm-nvm-nrm/</url>
    
    <content type="html"><![CDATA[<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>Node Package Manager</p><p>NodeJS包管理和分发工具</p><p><strong>npm 规定在项目根目录中必须提供一个 package.json 包管理配置文件，记录与项目相关的配置信息</strong>，如：</p><p>项目的名称、版本号、描述等</p><p>项目中用到了哪些包</p><p>哪些包只会在开发期间使用</p><p>哪些包在开发和部署时都会使用</p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a><strong>常用指令</strong></h3><h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 默认为 当前文件夹安装 最新版本 写入package.json的dependencies(-S)<br>npm install XXX<br><br><span class="hljs-regexp">//</span> 安装指定版本<br>npm install xxx@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 全局安装<br>npm install -g<br><br><span class="hljs-regexp">//</span> 写入package.json的devDependencies中<br>npm install –D xxx<br></code></pre></td></tr></table></figure><h4 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 卸载<br>npm uninstall XXX<br><br><span class="hljs-regexp">//</span> 卸载并在 package.json 中移除<br>npm uninstall -S XXX<br>npm uninstall -D XXX<br><br><span class="hljs-regexp">//</span> 卸载全局依赖<br>npm uninstall -g XXX<br></code></pre></td></tr></table></figure><h4 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 检查更新<br>npm outdated<br><br><span class="hljs-regexp">//</span> 执行更新<br>npm update<br></code></pre></td></tr></table></figure><h4 id="查看包"><a href="#查看包" class="headerlink" title="查看包"></a>查看包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 查看全局安装的包<br>npm list -g --depth <span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 查看某个包的版本<br>npm list vue-cli<br></code></pre></td></tr></table></figure><h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>Node Version Management</p><p>管理 node 版本的工具，通过它可以安装和切换不同版本的 node.js</p><p>不同的项目需要不同的 node 版本</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><p><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><h3 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a><strong>常用指令</strong></h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 本地 node 版本<br>nvm list<br><br><span class="hljs-regexp">//</span> 官方 node 版本<br>nvm list available<br><br><span class="hljs-regexp">//</span> 安装<br>nvm install <span class="hljs-number">18.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 卸载<br>nvm uninstall <span class="hljs-number">18.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-regexp">//</span> 切换当前版本<br>nvm use <span class="hljs-number">18.2</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>npm registry manager</p><p>npm 的镜像源管理工具</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 全局安装<br>npm install -g nrm<br></code></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 查看所有源<br>nrm ls<br><br><span class="hljs-regexp">//</span> 添加源 nrm add &lt;registry&gt; &lt;url&gt;<br>nrm add baidu www.baidu.com<br><br><span class="hljs-regexp">//</span> 切换源<br>nrm use taobao<br><br><span class="hljs-regexp">//</span> 删除源<br>nrm use taobao<br><br><span class="hljs-regexp">//</span> 测试源相应时长<br>nrm test taobao<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>包管理工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vite</title>
    <link href="/2022/06/30/Vite/"/>
    <url>/2022/06/30/Vite/</url>
    
    <content type="html"><![CDATA[<h1 id="Vite（未完）"><a href="#Vite（未完）" class="headerlink" title="Vite（未完）"></a>Vite（未完）</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://vitejs.cn/guide/why.html#the-problems">官方文档</a></p><h2 id="Vite的优势"><a href="#Vite的优势" class="headerlink" title="Vite的优势"></a>Vite的优势</h2><h3 id="更快的服务器启动"><a href="#更快的服务器启动" class="headerlink" title="更快的服务器启动"></a><strong>更快的服务器启动</strong></h3><p>Vite 通过在一开始将应用中的模块区分为 <strong>依赖</strong> 和 <strong>源码</strong> 两类，改进了开发服务器启动时间</p><p><strong>依赖</strong> 大多为在开发时不会变动的纯 JavaScript。</p><p>Vite 将会使用 **<a href="https://esbuild.github.io/">esbuild</a> <a href="https://vitejs.cn/guide/dep-pre-bundling.html">预构建依赖</a>**。Esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。</p><p><strong>源码</strong> 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue&#x2F;Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。</p><p>Vite 以 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules"><strong>原生 ESM</strong></a> 方式提供源码。这实际上是<strong>让浏览器接管了打包程序的部分工作</strong>：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景<strong>动态导入</strong>代码，即只在当前屏幕上实际使用时才会被处理。</p><h3 id="更快的更新"><a href="#更快的更新" class="headerlink" title="更快的更新"></a>更快的更新</h3><p>轻量快速的 HMR</p><p>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。</p><h3 id="传统构建与-vite-构建对比图"><a href="#传统构建与-vite-构建对比图" class="headerlink" title="传统构建与 vite 构建对比图"></a>传统构建与 vite 构建对比图</h3><p>一次全部打包</p><img src="/2022/06/30/Vite/bundler.37740380.png" class="" title="基于打包器的开发服务器"><p>按需动态引入</p><img src="/2022/06/30/Vite/esm.3070012d.png" class="" title="基于 ESM 的开发服务器"><h2 id="快速搭建一个项目"><a href="#快速搭建一个项目" class="headerlink" title="快速搭建一个项目"></a>快速搭建一个项目</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>初始化<br><span class="hljs-regexp">//</span> yarn create vite<br><span class="hljs-built_in">npm</span> init vite@latest<br><br><span class="hljs-number">2.</span>进入文件夹后安装依赖包<br><span class="hljs-built_in">npm</span> install<br><br><span class="hljs-number">3.</span>启动()<br><span class="hljs-built_in">npm</span> run dev<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json 命令解析</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 启动开发服务器，别名：`vite dev`，`vite serve`</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite build&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 为生产环境构建产物</span><br>    <span class="hljs-attr">&quot;preview&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite preview&quot;</span> <span class="hljs-comment">// 本地预览生产构建产物</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>项目目录</p><img src="/2022/06/30/Vite/image-20220701002419270.png" class="" title="image-20220701002419270"><p>public 下放无需编译的静态资源（图片 &#x2F; js）</p><p>assets 放可被编译的静态资源（图片 -&gt; base64）</p><p>components 公共组件</p>]]></content>
    
    
    <categories>
      
      <category>vite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pinia</title>
    <link href="/2022/06/28/pinia/"/>
    <url>/2022/06/28/pinia/</url>
    
    <content type="html"><![CDATA[<h1 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是-pinia"><a href="#什么是-pinia" class="headerlink" title="什么是 pinia"></a>什么是 pinia</h3><p>Vue 的状态管理库，会逐渐取代 Vuex</p><h3 id="pinia-的优势"><a href="#pinia-的优势" class="headerlink" title="pinia 的优势"></a>pinia 的优势</h3><p>1.完全支持 ts</p><p>2.移除了 mutations，actions 同时支持同步和异步</p><p>3.轻量 压缩后体积只有 1kb 左右</p><p>4.没有模块嵌套，只有 store，每一个 store 都是独立的</p><p>5.store 一旦创建便会自动添加，无需手动添加 store</p><p>6.支持 vue2 与 vue3</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="安装-pinia"><a href="#安装-pinia" class="headerlink" title="安装 pinia"></a>安装 pinia</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install pinia <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="创建-store"><a href="#创建-store" class="headerlink" title="创建 store"></a>创建 store</h3><p>新建 src&#x2F;store 目录并在其下面创建 index.ts，导出 store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/store/index.ts</span><br><span class="hljs-keyword">import</span> &#123;createPinia&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createPinia</span>()<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br></code></pre></td></tr></table></figure><p>vue3 是 createPinia </p><p>vue2 是 PiniaVuePlugin</p><p>在 main.ts 中引入并使用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/main.ts</span><br><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123;createPinia&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createPinia</span>()<br><span class="hljs-keyword">let</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br>app.<span class="hljs-title function_">use</span>(store)<br><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="定义-store"><a href="#定义-store" class="headerlink" title="定义 store"></a>定义 store</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//src/store/index.ts</span><br><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTestStore = <span class="hljs-title function_">defineStore</span>(&#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-comment">// id必填，唯一值(可以理解成命名空间)</span><br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// vuex中的state是对象, pinia中是箭头函数返回对象</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;lwj&#x27;</span>,<br>            <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;23&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">getters</span>: &#123;<br><br>    &#125;,<br>    <span class="hljs-attr">actions</span>: &#123;<br><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src/App.vue --&gt;<br>&lt;template&gt;<br>    &lt;div&gt;<br>        &#123;&#123;Test.name&#125;&#125;--&#123;&#123;Test.age&#125;&#125;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>    import &#123;useTestStore&#125; from &#x27;./store/index&#x27;<br>    const Test = useTestStore()<br>&lt;/script&gt;<br><br>&lt;style scoped&gt; <br>    <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><h4 id="修改-state-的五种方法"><a href="#修改-state-的五种方法" class="headerlink" title="修改 state 的五种方法"></a>修改 state 的五种方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src/App.vue --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &#123;&#123;Test.name&#125;&#125;--&#123;&#123;Test.age&#125;&#125;<br>    &lt;button @click=&quot;change1&quot;&gt;直接修改(修改一个)&lt;/button&gt;<br>    &lt;button @click=&quot;change2&quot;&gt;$patch对象写法(批量修改)&lt;/button&gt;<br>    &lt;button @click=&quot;change3&quot;&gt;$patch函数写法(可增加逻辑)&lt;/button&gt;<br>    &lt;button @click=&quot;change4&quot;&gt;$state(不常用 必须覆盖整个对象)&lt;/button&gt;<br>    &lt;button @click=&quot;change5&quot;&gt;actions&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>  import &#123;useTestStore&#125; from &#x27;./store/index&#x27;<br>  const Test = useTestStore()<br><br>  const change1 = () =&gt; &#123;<br>    Test.age++<br>  &#125;<br><br>  const change2 = () =&gt; &#123;<br>    Test.$patch(&#123;<br>      name: &#x27;lwjjj&#x27;,<br>      age: 24<br>    &#125;)<br>  &#125;<br><br>  const change3 = () =&gt; &#123;<br>    Test.$patch((state) =&gt; &#123;<br>      state.name = &#x27;lwjjjjjj&#x27;,<br>      state.age = 30<br>    &#125;)<br>  &#125;<br><br>  const change4 = () =&gt; &#123;<br>    Test.$state = &#123;<br>      name: &#x27;lwjjjjjjjj&#x27;,<br>      age: 50<br>    &#125;<br>  &#125;<br><br>  const change5 = () =&gt; &#123;<br>    Test.setCurrent(80)<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt; <br>  <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 方法五需要在 src/store/index.ts 中配置 actions</span><br><span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">setCurrent</span>(<span class="hljs-params">num:<span class="hljs-built_in">number</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;lwjjjjjjjjjjj&#x27;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = num<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;origin value &#123;&#123;Test.name&#125;&#125;--&#123;&#123;Test.age&#125;&#125;&#125;&lt;/div&gt;<br>  &lt;div&gt;<br>    &#123;&#123;Test.name&#125;&#125;--&#123;&#123;Test.age&#125;&#125;<br>    &lt;button @click=&quot;change&quot;&gt;change&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>  import &#123;useTestStore&#125; from &#x27;./store/index&#x27;<br>  import &#123; storeToRefs &#125; from &#x27;pinia&#x27;;<br>  const Test = useTestStore()<br><br>  // pinia 解构不具有响应式(直接解构的话修改数据要.value，可以使用 storeToRefs 解决)<br>  const &#123;name, age&#125; = storeToRefs(Test)<br><br>  const change = () =&gt; &#123;<br>    Test.age++<br>    console.log(name, age)<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt; <br>  <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="actions-和-getters"><a href="#actions-和-getters" class="headerlink" title="actions 和 getters"></a>actions 和 getters</h3><p>使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/store/index.ts</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Login</span> = (): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">User</span>&gt; =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(&#123;<br>                <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;vincent&#x27;</span>,<br>                <span class="hljs-attr">age</span>: <span class="hljs-number">99</span><br>            &#125;)<br>        &#125;, <span class="hljs-number">2000</span>);<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTestStore = <span class="hljs-title function_">defineStore</span>(&#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-comment">// id必填，唯一值(可以理解成命名空间)</span><br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// vuex中的state是对象, pinia中是箭头函数返回对象</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">user</span>: &lt;<span class="hljs-title class_">User</span>&gt;&#123;&#125;,<br>            <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;male&quot;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">getters</span>: &#123;<br>        <span class="hljs-title function_">newName</span>():<span class="hljs-built_in">string</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">`$~<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.sex&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.getUserAge&#125;</span>`</span><br>        &#125;,<br>        <span class="hljs-title function_">getUserAge</span>():<span class="hljs-built_in">number</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">age</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">actions</span>: &#123;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">setUser</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Login</span>()<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = result<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;female&#x27;</span>)<br>        &#125;,<br>        setName (<span class="hljs-attr">sex</span>:<span class="hljs-built_in">string</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="store-上的一些方法"><a href="#store-上的一些方法" class="headerlink" title="store 上的一些方法"></a>store 上的一些方法</h3><p><strong>$reset</strong></p><p>重置 store 到他的初始状态</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">reset</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title class_">Test</span>.$reset()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>$subscribe</strong></p><p>state 发生改变时触发</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Test</span>.$subscribe(<span class="hljs-function">(<span class="hljs-params">args, state</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state)<br>&#125;)<br></code></pre></td></tr></table></figure><p>args</p><img src="/2022/06/28/pinia/image-20220708230746204.png" class="" title="image-20220708230746204"><p>state</p><img src="/2022/06/28/pinia/image-20220708230807891.png" class="" title="image-20220708230807891"><p><strong>$onAction</strong></p><p>监听 action 变化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Test</span>.$onAction(<span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;)<br></code></pre></td></tr></table></figure><p>args</p><img src="/2022/06/28/pinia/image-20220708231241529.png" class="" title="image-20220708231241529"><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>pinia 和 vuex 的通病：页面刷新状态会丢失（初始化）</p><p>写一个 pinia 插件缓存值（通过 localStorage)</p><p><strong>写页面</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- App.vue --&gt;<br>&lt;template&gt;<br>  &lt;p&gt;&#123;&#123;Test.user&#125;&#125;&lt;/p&gt;<br>  &lt;hr&gt;<br>  &lt;p&gt;&#123;&#123;Base.baseCurrent&#125;&#125;&lt;/p&gt;<br>  &lt;hr&gt;<br>  &lt;button @click=&quot;changeTest&quot;&gt;changeTest&lt;/button&gt;<br>  &lt;button @click=&quot;changeBase&quot;&gt;changeBase&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>  import &#123;useTestStore, useStore&#125; from &#x27;./store/index&#x27;<br><br>  const Test = useTestStore()<br>  const Base = useStore()<br><br>  const changeTest = () =&gt; &#123;<br>    Test.user.name = &#x27;lwjjjjjjjjjjjjjjjjjjjjjjjjj&#x27;<br>    Test.user.age = 100<br>  &#125;<br><br>  const changeBase = () =&gt; &#123;<br>    Base.baseCurrent += 1<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt; <br>  <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>写数据</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// ./src/index.ts</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTestStore = <span class="hljs-title function_">defineStore</span>(&#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-comment">// id必填，唯一值(可以理解成命名空间)</span><br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// vuex中的state是对象, pinia中是箭头函数返回对象</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">user</span>: &lt;<span class="hljs-title class_">User</span>&gt;&#123;&#125;,<br>            <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;male&quot;</span><br>        &#125;<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">defineStore</span>(&#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;base&#x27;</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">baseCurrent</span>: <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>写插件（逻辑）</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">import</span> &#123; createApp, toRaw &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123;createPinia, <span class="hljs-title class_">PiniaPluginContext</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Options</span> = &#123;<br>    key?:<span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">__piniaKey__</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;xiaoman&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setStorage</span> = (<span class="hljs-params">key:<span class="hljs-built_in">string</span>, value:<span class="hljs-built_in">any</span></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value))<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getStorage</span> = (<span class="hljs-params">key:<span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key) ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key) <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>) : &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">piniaPlugin</span> = (<span class="hljs-params">options:Options</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">context:PiniaPluginContext</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123;store&#125; = context<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">getStorage</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;options?.key ?? __piniaKey__&#125;</span>-<span class="hljs-subst">$&#123;store.$id&#125;</span>`</span>)<br>        store.$subscribe(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">setStorage</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;options?.key ?? __piniaKey__&#125;</span>-<span class="hljs-subst">$&#123;store.$id&#125;</span>`</span>, <span class="hljs-title function_">toRaw</span>(store.<span class="hljs-property">$state</span>))<br>        &#125;)<br>        <span class="hljs-keyword">return</span> &#123;<br>            ...data<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createPinia</span>()<br><br>store.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">piniaPlugin</span>(&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;pinia&quot;</span><br>&#125;))<br><br><span class="hljs-keyword">let</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br>app.<span class="hljs-title function_">use</span>(store)<br><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>状态管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量提升与函数提升</title>
    <link href="/2022/06/27/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/"/>
    <url>/2022/06/27/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<h1 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h1><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>只有var定义的变量才会被提升</p><p>只提升声明，不提升赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a= <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//  &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>只提升函数声明式，不提升函数字面量式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//函数声明式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span> () &#123;&#125;<br><span class="hljs-comment">//函数字面量式 </span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>会整体提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getName</span>()<span class="hljs-comment">// 小明</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;小明&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.后面覆盖前面</p><p>2.如果变量和函数同名，提升的是函数</p><p>3.变量提升会区分作用域</p><h2 id="一道经典题目"><a href="#一道经典题目" class="headerlink" title="一道经典题目"></a>一道经典题目</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br><span class="hljs-title function_">a</span>();<br><span class="hljs-keyword">var</span> a=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span> ()&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>a=<span class="hljs-number">6</span>;<br><span class="hljs-title function_">a</span>()<br><br><span class="hljs-comment">//输出结果：function a () &#123;console.log()&#125;  10 3  TypeError </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端性能优化</title>
    <link href="/2022/06/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/06/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="前端性能优化的手段"><a href="#前端性能优化的手段" class="headerlink" title="前端性能优化的手段"></a>前端性能优化的手段</h2><h3 id="减少-http-请求"><a href="#减少-http-请求" class="headerlink" title="减少 http 请求"></a>减少 http 请求</h3><ol><li>base64 处理图片</li><li>减少重定向</li><li>使用缓存</li><li>不使用 css 的 @import</li></ol><h3 id="减少资源太小-压缩"><a href="#减少资源太小-压缩" class="headerlink" title="减少资源太小(压缩)"></a>减少资源太小(压缩)</h3><ol><li><strong>webpack</strong></li></ol><p>压缩 htmlHtmlWebpackPlugin 配置 minify</p><p>压缩 css   optimize-css-assets-webpack-plugin</p><p>压缩 js  mode: ‘production’(自动使用 terser-webpack-plugin)</p><ol start="2"><li><strong>开启 gzip 编码</strong></li></ol><p>开发模式下：webpack-dev-server 配置 compress: true</p><p>生产模式下：服务端配置，如 express 使用 compression 中间件</p><h3 id="优化网络连接"><a href="#优化网络连接" class="headerlink" title="优化网络连接"></a>优化网络连接</h3><ol><li><strong>内容分发网络 CDN</strong></li></ol><p>根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上</p><ol start="2"><li><strong>DNS 预解析</strong></li></ol><p>DNS 预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度</p><p>方法是在 head 标签里面写上几个 link 标签</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;dns-prefecth&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;https://www.google.com&quot;</span>&gt;<br>&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;dns-prefecth&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;https://www.google-analytics.com&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间</p><h3 id="优化资源加载"><a href="#优化资源加载" class="headerlink" title="优化资源加载"></a>优化资源加载</h3><ol><li><strong>资源加载位置</strong></li></ol><p>通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用</p><p>CSS文件放在head中</p><p>JS文件放在body底部，或者使用 defer&#x2F;async</p><ol start="2"><li><strong>资源加载时机</strong></li></ol><p>按需加载</p><p>懒加载与预加载</p><h3 id="减少重绘回流"><a href="#减少重绘回流" class="headerlink" title="减少重绘回流"></a>减少重绘回流</h3><ol><li><p>避免使用层级较深的选择器</p></li><li><p>防抖节流</p></li><li><p>DocumentFragment</p></li></ol><p>让DOM操作发生在内存中，而不是页面上；可以实现离线更新</p><ol start="4"><li>事件代理</li><li>动画 GPU 加速</li></ol><h3 id="性能更好的API"><a href="#性能更好的API" class="headerlink" title="性能更好的API"></a>性能更好的API</h3><ol><li>requestAnimationFrame来替代setTimeout和setInterval</li><li>使用IntersectionObserver来实现图片可视区域的懒加载</li></ol><h3 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h3><ol><li><p>treeshaking 去除无用代码</p></li><li><p>文件缓存</p></li></ol><p>hash chunkhash contenthash</p>]]></content>
    
    
    <categories>
      
      <category>优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块化</title>
    <link href="/2022/06/22/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2022/06/22/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起；</p><p>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>避免命名冲突、避免全局变量污染</p><p>便于代码编写和维护</p><h2 id="早期的模块化"><a href="#早期的模块化" class="headerlink" title="早期的模块化"></a>早期的模块化</h2><p>立即执行函数</p><p>通过函数作用域解决了命名冲突、污染全局的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-comment">// 在这里面声明各种变量、函数都不会污染全局作用域</span><br>&#125;)(a)<br></code></pre></td></tr></table></figure><h2 id="模块化方案"><a href="#模块化方案" class="headerlink" title="模块化方案"></a>模块化方案</h2><h3 id="1、CommonJS"><a href="#1、CommonJS" class="headerlink" title="1、CommonJS"></a>1、CommonJS</h3><p>①在node环境下使用，不支持浏览器环境<br>②NodeJS遵循的规范<br>③使用require()进行引入依赖<br>④使用exports进行暴露模块</p><h3 id="2、AMD"><a href="#2、AMD" class="headerlink" title="2、AMD"></a>2、AMD</h3><p>①浏览器环境下的异步加载模块<br>②RequireJS遵循的规范<br>③依赖于require.js模块管理工具库<br>④AMD 推崇依赖前置</p><h3 id="3、CMD"><a href="#3、CMD" class="headerlink" title="3、CMD"></a>3、CMD</h3><p>①浏览器环境下，同时支持异步和同步加载<br>②SeaJS遵循的规范<br>③CMD 推崇依赖就近</p><h3 id="4、ES6-module"><a href="#4、ES6-module" class="headerlink" title="4、ES6 module"></a>4、ES6 module</h3><p>ES6模块化语法在编译时就能确定模块的依赖关系，还能确定好输入输出的变量声明，已经不仅仅是模块规范，现在已经作为JS语言的标准语法使用，有以下特性：</p><p>①浏览器环境、<a href="https://www.yisu.com/">服务器</a>环境都支持<br>②编译时就能确定模块的依赖关系及变量，其他模块规范都是在运行时确定的<br>③export命令用于规定模块的对外接口<br>④import命令用于输入其他模块提供的功能</p><h3 id="CommonJs和ES6-module的区别"><a href="#CommonJs和ES6-module的区别" class="headerlink" title="CommonJs和ES6 module的区别"></a>CommonJs和ES6 module的区别</h3><p><strong>CommonJS</strong> 是一种模块规范，最初被应用于 <strong>Nodejs</strong>，成为 Nodejs 的模块规范。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br><span class="hljs-comment">// 导出</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = 导出的值<br></code></pre></td></tr></table></figure><p>运行在<strong>浏览器</strong>端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: <strong>AMD</strong>)，用来对前端模块进行管理。</p><p>自 ES6 起，引入了一套新的 <strong>ES6 Module 规范</strong>，在语言标准的层面上实现了模块功能，而且实现得相当简单，<strong>有望成为浏览器和服务器通用的模块解决方案</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;模块路径&quot;</span><br><span class="hljs-keyword">import</span> &#123;a,b&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;模块路径&quot;</span><br><span class="hljs-keyword">import</span> c <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;模块路径&quot;</span><span class="hljs-comment">//默认导入</span><br><br><br><span class="hljs-comment">// 导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">b</span> = (<span class="hljs-params"></span>)=&gt;&#123;&#125;<br><span class="hljs-comment">//默认导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">xx</span>:yy,<br><span class="hljs-attr">aa</span>:bb<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>但目前浏览器对 ES6 Module <strong>兼容还不太好</strong>，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。</p><p>在**<a href="https://blog.csdn.net/qq_45890970/article/details/123541700?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123541700-blog-123954229.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=3">使用上的差别</a>**主要有：</p><p><strong>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong>（一旦输出一个值，模块内部的变化就影响不到这个值）</p><p><strong>CommonJS 是同步加载模块，ES6 是异步加载模块。</strong>（主要用于服务器编程，模块文件一般都已经存在于本地，加载起来比较快）</p><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p><p>CommonJs 是单个值导出，ES6 Module可以导出多个</p><p>CommonJs 是<strong>动态语法可以写在判断里</strong>，ES6 Module <strong>静态语法只能写在顶层</strong></p><p>CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.yisu.com/zixun/452499.html">https://www.yisu.com/zixun/452499.html</a></p><p><a href="https://blog.csdn.net/weixin_39690316/article/details/122946850">https://blog.csdn.net/weixin_39690316/article/details/122946850</a></p><p><a href="https://blog.csdn.net/qq_45890970/article/details/123541700?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123541700-blog-123954229.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/qq_45890970/article/details/123541700?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123541700-blog-123954229.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>模块化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AJAX</title>
    <link href="/2022/06/21/AJAX/"/>
    <url>/2022/06/21/AJAX/</url>
    
    <content type="html"><![CDATA[<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Asynchronous JavaScript And XML（异步的 JS 和 XML）</p><p>AJAX 是在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页。（<strong>无刷新获取数据</strong>）</p><h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点：</strong></p><ol><li><p>无需刷新页面与服务端通信</p></li><li><p>允许根据用户事件来更新部分页面内容</p></li></ol><p><strong>缺点：</strong></p><ol><li>没有浏览历史、不能回退</li><li>存在跨域问题</li><li>不易SEO</li></ol><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>传统Ajax 指的是 XMLHttpRequest（XHR），最早出现的向后端发送请求的技术，隶属于原始 js 中</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h4><ul><li>创建对象 （XMLHttpRequest 对象）</li><li>请求 （将请求发送到服务器，使用 XMLHttpRequest 对象的 open() 和 send() 方法）</li><li>响应 （获得来自服务器的响应，使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性）</li><li>根据XMLHttpRequest的readyState判定调用哪个回调函数 （onreadystatechange 事件）</li><li>更新页面</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 请求成功回调函数</span><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request success&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 请求结束回调函数</span><br>xhr.<span class="hljs-property">onloadend</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request loadend&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 请求出错回调函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request error&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 请求超时回调函数</span><br>xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request timeout&#x27;</span>);<br>&#125;;<br><br>xhr.<span class="hljs-property">timeout</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 设置超时时间,0表示永不超时</span><br><span class="hljs-comment">// 初始化请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET/POST/DELETE/...&#x27;</span>, <span class="hljs-string">&#x27;/url&#x27;</span>, <span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 设置期望的返回数据类型 &#x27;json&#x27; &#x27;text&#x27; &#x27;document&#x27; ...</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-comment">// 设置请求头</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-comment">// 发送请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span> || <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span> || <span class="hljs-string">&#x27;a=1&amp;b=2&#x27;</span> || <span class="hljs-string">&#x27;json字符串&#x27;</span>);<br><br><span class="hljs-comment">// 请求回调函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> === <span class="hljs-number">304</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request success&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request error&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 取消请求</span><br>xhr.<span class="hljs-title function_">abort</span>()<br></code></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>浏览器通过 XMLHttpRequest 对象进行 http 通信，多个请求之间如果有先后关系的话，就会出现 <a href="https://www.cnblogs.com/bala/p/11650296.html#callback-hell"><strong>回调地狱</strong></a></p><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>fetch 号称是 AJAX 的替代品，是在 ES6 出现的，使用了ES6 中的 promise 对象。Fetch 是基于 promise 设计的。</p><p><strong>fetch 不是 ajax的进一步封装，而是原生 JS ， 没有使用 XMLHttpRequest 对象。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 一个简单的fetch 请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/movies.json&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)&#123;<br>        <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>()<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">myJson</span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myJson) <br>    &#125;)<br><br><br><span class="hljs-comment">// 一个带有参数的fetch请求</span><br><span class="hljs-title function_">postData</span>(<span class="hljs-string">&#x27;http://example.com/answer&#x27;</span>,&#123;<span class="hljs-attr">answer</span>: <span class="hljs-number">42</span>&#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))  <span class="hljs-comment">// JSON from &#x27;response.json()&#x27; call</span><br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error))<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">postData</span>(<span class="hljs-params">url, data</span>) &#123;<br>  <span class="hljs-comment">// Default options are marked with *</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>       <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data),  <span class="hljs-comment">// must match &#x27;Content-Type&#x27; header</span><br>       <span class="hljs-attr">cache</span>: <span class="hljs-string">&#x27;no-cache&#x27;</span>,  <span class="hljs-comment">// * default, no-cache, reload, force-cache, only-if-cached</span><br>        <span class="hljs-attr">headers</span>: &#123;<br>            <span class="hljs-string">&#x27;user-agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/4.0 MDN Example&#x27;</span>,<br>             <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>        &#125;,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-comment">// *GET, POST, PUT, DELETE, etc.</span><br>        <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;cors&#x27;</span>, <span class="hljs-comment">// no-cors, cors, *same-origin</span><br>        <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;follow&#x27;</span>, <span class="hljs-comment">// manual, *follow, error</span><br>        <span class="hljs-attr">referrer</span>: <span class="hljs-string">&#x27;no-referrer&#x27;</span>, <span class="hljs-comment">// *client, no-referrer    </span><br>  &#125;)    <br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>()) <span class="hljs-comment">// parses response to JSON</span><br></code></pre></td></tr></table></figure><p>fetch 的优点：</p><p>　　1、语法简洁，更加语义化</p><p>　　2、基于标准 Promise 实现，支持 async &#x2F; await</p><p>　　3、同构方便，使用<code>[isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)</code></p><p>　　4、更加底层，提供的 API 丰富 （request， response）</p><p>　　5、脱离了 XHR，是 ES 规范中新的实现方式。</p><p>缺点：</p><p>　　1、fetch 只对网络请求报错，对400,500都当作成功的请求，服务器返回400， 500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时， fetch 才会被 reject。需要封装去处理。</p><p>　　2、fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</p><p>　　3、**<a href="https://www.cnblogs.com/bala/p/11650296.html#abort-controller">fetch 不支持 abort</a>** （xhr 有个 xhr.abort 方法可以直接阻断请求），不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求，请求过程继续在后台运行，造成了流量的浪费。</p><p>　　4、fetch 没有办法原生监测请求的进度，而 XHR 可以。</p><p>　　5、fetch 兼容性并不太好，IE 不支持</p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios 是一个基于 <a href="https://www.cnblogs.com/bala/p/11650296.html#promise">Promise</a> 的 http请求库，可以用在浏览器和 node.js 中，本质上也是<strong>对原生XHR的封装</strong>，只不过它是Promise 的实现版本，符合最新的ES规则。是目前最常用的请求方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 配置 baseURL</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;http://localhost:8000&#x27;</span>;<br><br><span class="hljs-comment">// GET 请求</span><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/axios-server&#x27;</span>, &#123;<br>    <span class="hljs-comment">// url 参数</span><br>    <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-number">100</span>,<br>        <span class="hljs-attr">vip</span>: <span class="hljs-number">7</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 请求头信息</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;atguigu&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error) <br>&#125;)<br><br><span class="hljs-comment">// POST 请求</span><br>axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/axios-server&#x27;</span>, &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>&#125;, &#123;<br>    <span class="hljs-comment">// url</span><br>    <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-attr">vip</span>: <span class="hljs-number">9</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 请求头参数</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">height</span>: <span class="hljs-number">180</span>,<br>        <span class="hljs-attr">weight</span>: <span class="hljs-number">180</span>,<br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error) <br>&#125;)<br><br><span class="hljs-comment">// 通用</span><br><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-comment">// 请求方法</span><br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-comment">//url</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/axios-server&#x27;</span>,<br>    <span class="hljs-comment">// url参数</span><br>    <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">vip</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">level</span>: <span class="hljs-number">30</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 头信息</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">a</span>: <span class="hljs-number">100</span>,<br>        <span class="hljs-attr">b</span>: <span class="hljs-number">200</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 请求体参数</span><br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>        <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>    <span class="hljs-comment">// 响应状态码</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">status</span>);<br>    <span class="hljs-comment">// 响应状态字符串</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">statusText</span>);<br>    <span class="hljs-comment">// 响应头信息</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">headers</span>);<br>    <span class="hljs-comment">// 响应体</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error) <br>&#125;)<br><br><span class="hljs-comment">// 利用 async await</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/axios-server&#x27;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)                   <br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)  <br>    &#125;  <br></code></pre></td></tr></table></figure><p>axios 的特征：</p><p>　　1、从浏览器中创建XMLHttpRequest</p><p>　　<strong>2、支持 Promise API，不会产生回调地狱的问题</strong></p><p>　　<strong>3、客户端支持防止 CSRF</strong></p><p>　　4、提供了一些**<a href="https://www.cnblogs.com/bala/p/11650296.html#concurrent">并发</a>**请求的接口（重要，方便了很多的操作）</p><p>　　5、从 node.js 创建 http 请求</p><p>　　<strong>6、拦截请求和响应</strong></p><p>　　7、转换请求和响应数据</p><p>　　8、取消请求</p><p>　　9、自动转换JSON数据</p><h3 id="xhr-封装-axios"><a href="#xhr-封装-axios" class="headerlink" title="xhr 封装 axios"></a>xhr 封装 axios</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">axios</span>(<span class="hljs-params">method, url, data</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>        xhr.<span class="hljs-title function_">open</span>(method, url)<br>        xhr.<span class="hljs-title function_">send</span>(data)<br>        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">response</span>))<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>                       <br><span class="hljs-comment">// 调用</span><br><span class="hljs-title function_">axios</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;接口地址&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)  <br></code></pre></td></tr></table></figure><h3 id="如何终止-http-请求"><a href="#如何终止-http-请求" class="headerlink" title="如何终止 http 请求"></a><a href="https://www.jianshu.com/p/a7d367dd270b">如何终止 http 请求</a></h3><p><strong>XMLHttpRequest</strong></p><p><strong>abort()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ajax = <span class="hljs-title class_">XMLHttpRequest</span><br>ajax.<span class="hljs-title function_">open</span>()<br>ajax.<span class="hljs-title function_">send</span>()<br>ajax.<span class="hljs-property">onreadystateChange</span> = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br><br><span class="hljs-comment">// 终止请求</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    ajax.<span class="hljs-title function_">abort</span>()<br>&#125;, <span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure><p><strong>fetch</strong></p><p>fetch需要配合<a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController"><strong>AbortController</strong></a>实例来完成请求的取消</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br><span class="hljs-keyword">let</span> signal = controller.<span class="hljs-property">signal</span>;<br><br><span class="hljs-keyword">const</span> downloadBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.download&#x27;</span>);<br><span class="hljs-keyword">const</span> abortBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.abort&#x27;</span>);<br><br>downloadBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, fetchVideo);<br><br>abortBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  controller.<span class="hljs-title function_">abort</span>();<span class="hljs-comment">// 终止请求</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Download aborted&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchVideo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-title function_">fetch</span>(url, &#123;signal&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    reports.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;Download error: &#x27;</span> + e.<span class="hljs-property">message</span>;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>axios</strong></p><p> 跟fetch有点像，使用CancelToken.source创建一个 <strong>cancel token</strong> 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cancelToken = axios.<span class="hljs-property">CancelToken</span><br><span class="hljs-keyword">const</span> source = cancelToken.<span class="hljs-title function_">source</span>()<br>axios.<span class="hljs-title function_">get</span>(url, &#123;<br>    <span class="hljs-attr">cancelToken</span>: source.<span class="hljs-property">token</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br><br><span class="hljs-comment">// 终止请求</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    source.<span class="hljs-title function_">cancel</span>()<br>&#125;, <span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>AJAX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>AJAX</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueRouter</title>
    <link href="/2022/06/18/VueRouter/"/>
    <url>/2022/06/18/VueRouter/</url>
    
    <content type="html"><![CDATA[<h1 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h1><p>路由，vue是单页面应用，通过组件来显示不同的视图，路由就是通过设定路径来控制组件的显示与隐藏，实现页面的跳转与切换。</p><p>一个路由就是一个键值对，键是路径，值是组件。</p><h3 id="VueRouter的作用"><a href="#VueRouter的作用" class="headerlink" title="VueRouter的作用"></a>VueRouter的作用</h3><p>vue的核心概念之一：页面组件化、SPA。</p><p>由于vue是单页面应用，且每个功能模块都可以封装为组件，因此不可能和多页面应用一样直接通过超链接跳转，换句话说只有一个html，还能跳转到哪儿去？那如何让vue可以在一个页面中如何切换不同的组件？<br>这也是vue-router要解决的根本目的：让SPA像多页面应用一样实现跳转。</p><h3 id="vue-router钩子函数"><a href="#vue-router钩子函数" class="headerlink" title="vue-router钩子函数"></a>vue-router钩子函数</h3><p>全局的：beforeEach、beforeResolve、afterEach<br>路由的：beforeEnter<br>组件的：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave<br>参数：to、from、next；正对不同的钩子函数参数有所差异。</p><p>除了afterEach全局后置外，其他的守卫中务必要调用next(),否则无法完成导航<br>还有注意全局前置守卫可以用来进行拦截（登录拦截）</p><h3 id="route和router有什么区别"><a href="#route和router有什么区别" class="headerlink" title="route和router有什么区别"></a><a href="https://www.cnblogs.com/itgezhu/p/12177288.html">route和router有什么区别</a></h3><p><strong>route：代表当前路由信息对象，可以获取到当前路由的信息参数</strong></p><p>$route.fullPath ：完成解析后的url，包含查询参数和hash的完整路径</p><p>$route.path：路径，字符串类型，解析为绝对路径</p><p>$route.hash： 当前路由的hash值（带#号的），如果没有hash值则为空字符串</p><p>$route.name：当前路由的名称，如果有的话（用于命名路由）</p><p>$route.params：一个键值对对象，路由参数</p><p>$route.query：一个键值对对象，表示url查询参数</p><p>$route.matched：一个包含了当前路由的所有嵌套路径片段的路由记录（routes配置数组中的对象副本）</p><p>$route.redirectedFrom：重定向来源的路由的名字，如果存在重定向的话。</p><p><strong>router：代表路由实例的对象，包含了路由的跳转方法，钩子函数等</strong></p><p>属性：</p><p>$router.app ：配置了router的Vue根实例</p><p>$router.mode：路由模式，这里是hash</p><p>$router.currentRoute：当前路由的路由信息对象，包含了当前匹配路由的信息</p><p>方法：</p><p>守卫：router.afterEach()</p><p>路由跳转：router.push( location )router.replace( location )</p><h3 id="路由之间如何跳转"><a href="#路由之间如何跳转" class="headerlink" title="路由之间如何跳转"></a>路由之间如何跳转</h3><p>组件导航<br>router-link router-view</p><p>编程导航<br>router.push<br>router.replace<br>router.go</p><h3 id="vue-router完整的导航解析流程"><a href="#vue-router完整的导航解析流程" class="headerlink" title="vue-router完整的导航解析流程"></a>vue-router完整的导航解析流程</h3><p>1.导航被触发；</p><p>2.在失活的组件里调用beforeRouteLeave守卫；</p><p>3.调用全局beforeEach守卫；</p><p>4.在复用组件里调用beforeRouteUpdate守卫；</p><p>5.调用路由配置里的beforeEnter守卫；</p><p>6.解析异步路由组件；</p><p>7.在被激活的组件里调用beforeRouteEnter守卫；</p><p>8.调用全局beforeResolve守卫；</p><p>9.导航被确认；</p><p>10.调用全局的afterEach钩子；</p><p>11.DOM更新；</p><p>12.用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数。</p><h3 id="从零开始写一个vue路由"><a href="#从零开始写一个vue路由" class="headerlink" title="从零开始写一个vue路由"></a>从零开始写一个vue路由</h3><ol><li>为了方便后期维护，建议独立出一个 router.js 文件</li><li>npm install vue-router</li><li>引入注册</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li>向外暴露出一个router实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    ...<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>动态导入，需要跳转到要用的页面的时候在对该页面进行加载</p><p>1.vue的异步组件：resolve&#x3D;&gt;require([‘需要异步加载的组件’]，resolve)</p><p><strong>2.es6的import方法：</strong></p><p>利用 <strong>箭头函数 和 import</strong> 来实现动态加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 将 import UserDetails from &#x27;./views/UserDetails&#x27; 替换成</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">UserDetails</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./views/UserDetails&#x27;</span>)<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">routes</span>: [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserDetails</span> &#125;],<br>&#125;)<br></code></pre></td></tr></table></figure><p>3.webpack的 require.ensure： r &#x3D;&gt; require.ensure([],()&#x3D;&gt;r( require(需要异步加载的组件))，chunkName)</p><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>在用户访问一个特定的地址时,将其重定向到另一个指定的地址 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/goback&#x27;</span>,<br><span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h3><p>active-class是vue-router模块的router-link组件中的属性，用来做选中样式的切换；</p><h3 id="如何获取路由传过来的参数？"><a href="#如何获取路由传过来的参数？" class="headerlink" title="如何获取路由传过来的参数？"></a><a href="https://github.com/haizlin/fe-interview/issues/379#">如何获取路由传过来的参数？</a></h3><p>如果使用<code>query</code>方式传入的参数使用<code>this.$route.query</code> 接收<br>如果使用<code>params</code>方式传入的参数使用<code>this.$route.params</code>接收</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p>vue-router插件的其中一个组件, 用于跳转路由, 类似于a标签, 它一般也会渲染成a标签, 但是可以通过<code>tag</code>来变更默认渲染元素, 通过<code>to</code>来跳转</p><h3 id="路由有几种模式"><a href="#路由有几种模式" class="headerlink" title="路由有几种模式"></a>路由有几种模式</h3><p>路由配置时，设置 mode，默认为 hash</p><p>前端路由实现的本质是<strong>监听 url 变化</strong>，实现方式有两种：<strong>Hash 模式和 History 模式</strong>，<strong>无需刷新页面就能重新加载相应的页面</strong>。</p><p>Hash url 的格式为<code>www.a.com/#/</code>，当#后的哈希值发生变化时，通过 <strong>hashchange</strong> 事件监听，然后页面跳转。</p><p>History url 通过<code>history.pushState</code>和<code>history.replaceState</code>改变 url。 </p><p>两种模式的区别：</p><ul><li>hash 只能改变#后的值，而 history 模式可以随意设置同源 url；</li><li>hash 只能添加字符串类的数据，而 history 可以通过 API 添加多种类型的数据；</li><li>hash 的历史记录只显示之前的<code>www.a.com</code>而不会显示 hash 值，而 history 的每条记录都会进入到历史记录；</li><li>hash 无需后端配置且兼容性好，而 history 需要配置<code>index.html</code>用于匹配不到资源的情况。</li></ul><h3 id="vue-router怎么配置404页面？"><a href="#vue-router怎么配置404页面？" class="headerlink" title="vue-router怎么配置404页面？"></a>vue-router怎么配置404页面？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123; <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>, <span class="hljs-attr">routes</span>: [ &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">NotFoundComponent</span> &#125; ] &#125;)<br></code></pre></td></tr></table></figure><p>path: ‘*’  注意要放在最后</p><p>*代表全匹配 你放在第一个 不管地址是什么都会 匹配到了 放在最后一个 前面有的就不会匹配到</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收</title>
    <link href="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="为什么需要垃圾回收"><a href="#为什么需要垃圾回收" class="headerlink" title="为什么需要垃圾回收"></a>为什么需要垃圾回收</h2><p>V8引擎已经帮我们自动进行了内存的分配和管理，JS 不需要手动开辟和释放内存。</p><p>存在写代码的过程中不够严谨而容易引发内存泄漏的问题</p><h2 id="V8引擎的内存限制"><a href="#V8引擎的内存限制" class="headerlink" title="V8引擎的内存限制"></a>V8引擎的内存限制</h2><p>JS 是单线程，垃圾回收的过程阻碍了主线程逻辑的执行。会导致主线程的等待时间长，浏览器长时间得不到响应。</p><p>V8引擎直接粗暴的限制了堆内存的大小。在浏览器端一般也不会遇到需要操作几个G内存这样的场景。在node端我们可以手动调整。</p><h2 id="经典垃圾回收策略"><a href="#经典垃圾回收策略" class="headerlink" title="经典垃圾回收策略"></a>经典垃圾回收策略</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数会跟踪每个值被引用的次数，当引用数为0时变量，内存就会被释放。因为存在<strong>循环引用</strong>的问题，所以很少使用这种方法。</p><p>在代码运行时就会自动的增减，因此效率高。</p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>第一个阶段是标记，也就是找垃圾的过程，从根节点出发遍历对象，对所有访问过的对象打上标记，表示对象可达。第二阶段是清除，对那些没有标记的对象进行回收。以下几种情况都可以作为根节点：</p><ol><li>全局对象</li><li>本地函数的局部变量和参数</li><li>当前嵌套调用链上的其他函数的变量和参数</li></ol><p>因为需要暂停下来遍历对象，所以效率相对较低。</p><h2 id="V8的垃圾回收策略"><a href="#V8的垃圾回收策略" class="headerlink" title="V8的垃圾回收策略"></a>V8的垃圾回收策略</h2><h3 id="V8的内存结构"><a href="#V8的内存结构" class="headerlink" title="V8的内存结构"></a>V8的内存结构</h3><p><code>新生代(new_space)</code>：<strong>大多数的对象</strong>（如执行上下文）开始都会被分配在这里，这个<strong>区域相对较小</strong>但是<strong>垃圾回收特别频繁</strong>，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。</p><p><code>老生代(old_space)</code>：<strong>新生代中的对象在存活一段时间后就会被转移到老生代内存区</strong>（如全局变量、自定义类、函数等），相对于新生代该内存区域的垃圾回收频率较低。老生代又分为<code>老生代指针区</code>和<code>老生代数据区</code>，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。</p><p><code>大对象区(large_object_space)</code>：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。</p><p><code>代码区(code_space)</code>：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。</p><p><code>map区(map_space)</code>：存放Cell和Map，每个区域都是存放相同大小的元素，结构简单(这里没有做具体深入的了解，有清楚的小伙伴儿还麻烦解释下)。</p><img src="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/16ee12280b78399dtplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp" class="" title="1620974853612-a480b43e-b3bb-452f-a502-3a0162548a7f"><p>上图中的带斜纹的区域代表暂未使用的内存，新生代(new_space)被划分为了两个部分，其中一部分叫做inactive new space，表示暂未激活的内存区域，另一部分为激活状态。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新生代的垃圾回收过程中主要采用了**<code>Scavenge</code>**算法。</p><p><code>Scavenge</code>算法是一种典型的牺牲空间换取时间的算法，对于老生代内存来说，可能会存储大量对象，如果在老生代中使用这种算法，势必会造成内存资源的浪费，但是在新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。</p><p>在<code>Scavenge</code>算法的具体实现中，主要采用了<code>Cheney</code>算法，它将新生代内存一分为二，每一个部分的空间称为<code>semispace</code>，也就是我们在上图中看见的new_space中划分的两个区域，其中处于激活状态的区域我们称为<code>From</code>空间，未激活(inactive new space)的区域我们称为<code>To</code>空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到<code>From</code>空间，当进行垃圾回收时，如果<code>From</code>空间中尚有存活对象，则会被复制到<code>To</code>空间进行保存，非存活的对象会被自动回收。当复制完成后，<code>From</code>空间和<code>To</code>空间完成一次角色互换，<code>To</code>空间会变为新的<code>From</code>空间，原来的<code>From</code>空间则变为<code>To</code>空间。</p><p><code>Scavenge</code>算法的垃圾回收过程主要就是将存活对象在<code>From</code>空间和<code>To</code>空间之间进行复制，同时完成两个空间之间的角色互换，因此该算法的缺点也比较明显，浪费了一半的内存用于复制。</p><h3 id="对象晋升"><a href="#对象晋升" class="headerlink" title="对象晋升"></a>对象晋升</h3><p>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时（在将对象从<code>From</code>空间复制到<code>To</code>空间之前），该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为<code>晋升</code>。<br> 对象晋升的条件主要有以下两个（满足任意一个则会晋升）：</p><ul><li>对象是否经历过一次<code>Scavenge</code>算法</li><li><code>To</code>空间的内存占比是否已经超过<code>25%</code></li></ul><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><p>在老生代中，因为管理着大量的存活对象，如果依旧使用<code>Scavenge</code>算法的话，很明显会浪费一半的内存，因此已经不再使用<code>Scavenge</code>算法，而是采用新的算法**<code>Mark-Sweep(标记清除)</code>和<code>Mark-Compact(标记整理)</code>**来进行管理。</p><p>标记清除的问题是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现<strong>内存碎片</strong>的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。</p><p>为了解决这种内存碎片的问题，<code>Mark-Compact(标记整理)</code>算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，<strong>回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存</strong>。</p><h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><p>全停顿 <img src="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/153329224-c2120a5d-4f25-4659-9347-d6217d5a5ce8.png" class="" title="1620974853612-a480b43e-b3bb-452f-a502-3a0162548a7f"></p><p>增量标记 <img src="/2022/06/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/153329251-e6a21086-f646-48d5-a23c-c2e3351497ef.png" class="" title="1620975019709-efc33748-fbfc-4fb5-a19d-97abadbf8f97"></p><p>为了减少垃圾回收带来的停顿时间，V8引擎又引入了<strong>Incremental Marking(增量标记)<strong>的概念，即将</strong>原本需要一次性遍历堆内存的操作改为增量标记的方式</strong>，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p><p>得益于增量标记的好处，V8引擎后续继续引入了<strong>延迟清理(lazy sweeping)<strong>和</strong>增量式整理(incremental compaction)<strong>，让清理和整理的过程也变成增量式的。同时为了充分利用多核CPU的性能，也将引入</strong>并行标记</strong>和<strong>并行清理</strong>，进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。</p><h2 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h2><ol><li><strong>尽可能少地创建全局变量</strong></li></ol><p>会无形地挂载到<code>window</code>全局对象上，变成根节点，必须要将其设置为 null 才能回收</p><ol start="2"><li><p><strong>记得手动清除定时器</strong></p></li><li><p><strong>少使用闭包</strong></p></li><li><p><strong>使用弱引用</strong></p></li></ol><p>WeakMap, WeakSet</p><p>弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904016325902344#heading-2">https://juejin.cn/post/6844904016325902344#heading-2</a></p><p><a href="https://www.bilibili.com/video/BV1bP4y1u7GF?spm_id_from=333.337.search-card.all.click&amp;vd_source=1616b746cefe2e7615c229563ba38eb4">https://www.bilibili.com/video/BV1bP4y1u7GF?spm_id_from=333.337.search-card.all.click&amp;vd_source=1616b746cefe2e7615c229563ba38eb4</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>垃圾回收</tag>
      
      <tag>V8引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON</title>
    <link href="/2022/06/17/JSON/"/>
    <url>/2022/06/17/JSON/</url>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h2><p>是一种数据格式，之所以需要这样一种数据格式，是因为前后端的编程语言不同，数据的表示形式也不同，所以需要有这样一种格式来作为桥梁传递数据。</p><h2 id="JSON-和-JS-对象的区别"><a href="#JSON-和-JS-对象的区别" class="headerlink" title="JSON 和 JS 对象的区别"></a>JSON 和 JS 对象的区别</h2><p>JSON和JS有相同的语法，JSON和JS对象也非常的像，但还是有一定区别的，JSON的要求更多一些，区别在于：</p><img src="/2022/06/17/JSON/image-20220701002710162.png" class="" title="image-20220701002710162"><p>在我们前端向后端发送数据时，需要将JS对象转换为一个JSON字符串，可以通过JSON.stringify()这个JS方法来实现，并且提供了一些参数来对转换过程做一些处理。相反，我们收到的后端的数据也是JSON格式，我们需要通过JSON.parse()来将其转化为JS对象之后再使用。</p><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value[, replacer [, space]])<br><span class="hljs-comment">// value: 将要序列化成一个 JSON 字符串的值</span><br></code></pre></td></tr></table></figure><ul><li><strong>转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。</strong></li><li>非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。</li><li>布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。</li><li><strong><code>undefined</code>、任意的函数以及 symbol 值，在序列化过程中会被忽略</strong>（出现在非数组对象的属性值中时）或者被转换成 <code>null</code>（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如<code>JSON.stringify(function()&#123;&#125;)</code> or <code>JSON.stringify(undefined)</code>.</li><li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</li><li>所有以 symbol 为属性键的属性都会被完全忽略掉，即便 <code>replacer</code> 参数中强制指定包含了它们。</li><li>Date 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理。</li><li><strong>NaN 和 Infinity 格式的数值及 null 都会被当做 null。</strong></li><li>其他类型的对象，包括 Map&#x2F;Set&#x2F;WeakMap&#x2F;WeakSet，仅会序列化可枚举的属性。</li></ul><h2 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> oldJson = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">const</span> newJson = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(oldJson));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>terser是如何压缩js代码的</title>
    <link href="/2022/06/17/terser%E6%98%AF%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9js%E4%BB%A3%E7%A0%81%E7%9A%84/"/>
    <url>/2022/06/17/terser%E6%98%AF%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9js%E4%BB%A3%E7%A0%81%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="js代码压缩整体策略"><a href="#js代码压缩整体策略" class="headerlink" title="js代码压缩整体策略"></a>js代码压缩整体策略</h2><p>通过 AST 分析，根据选项配置一些策略，来<strong>生成一颗更小体积的 AST</strong> 并生成代码。</p><h2 id="压缩-AST-的方式"><a href="#压缩-AST-的方式" class="headerlink" title="压缩 AST 的方式"></a>压缩 AST 的方式</h2><p>目前前端工程化中使用 <a href="https://terser.org/docs/api-reference#compress-options">terser</a>和 <a href="https://swc.rs/docs/configuration/minification">swc</a>进行 JS 代码压缩，他们拥有相同的 API。</p><p>常见用以压缩 AST 的几种方案如下:</p><ol><li><strong>去除多余字符: 空格，换行及注释</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (a, b) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span> a+b&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>压缩变量名：变量名，函数名及属性名</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (first, second) &#123;<br>  <span class="hljs-keyword">return</span> first + second;  <br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (x, y) &#123;<br>  <span class="hljs-keyword">return</span> x + y;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>合并声明以及布尔值简化</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>编译预计算</strong></li></ol><p><strong>数学</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ONE_YEAR</span> = <span class="hljs-number">365</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span><br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ONE_YAAR</span> = <span class="hljs-number">31536000</span><br></code></pre></td></tr></table></figure><p><strong>函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span> () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello, world&#x27;</span>)<br>&#125;<br><br><span class="hljs-title function_">hello</span>()<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello, world&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="在-webpack-中开启-js-代码压缩"><a href="#在-webpack-中开启-js-代码压缩" class="headerlink" title="在 webpack 中开启 js 代码压缩"></a>在 webpack 中开启 js 代码压缩</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">mode:</span> <span class="hljs-comment">&#x27;production&#x27;</span><br></code></pre></td></tr></table></figure><p>生产环境会自动压缩 js 代码（会自动使用一些插件，如terser-webpack-plugin）</p><p><code>terser-webpack-plugin</code> 内部封装了 <a href="https://link.zhihu.com/?target=https://github.com/terser/terser">terser</a> 库，用于处理 js 的压缩和混淆，通过 <code>webpack plugin</code> 的方式对代码进行处理</p>]]></content>
    
    
    <categories>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>terser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="/2022/06/14/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/06/14/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="对象的深拷贝与浅拷贝"><a href="#对象的深拷贝与浅拷贝" class="headerlink" title="对象的深拷贝与浅拷贝"></a>对象的深拷贝与浅拷贝</h2><h3 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝"></a>什么是浅拷贝</h3><p><strong>只拷贝了数据对象的第一层，深层次的数据值与原始数据会互相影响（拷贝后的数据与原始数据还存有关联）</strong></p><p>常见浅拷贝的方式：Object.assign()、扩展运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-attr">info</span>: &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> &#125; &#125;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj1)<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1 &#125;<br><br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;cat&#x27;</span><br>obj2.<span class="hljs-property">info</span>.<span class="hljs-property">age</span> = <span class="hljs-number">4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1) <span class="hljs-comment">// &#123; name: &#x27;dog&#x27;, info: &#123; age: 4 &#125; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2) <span class="hljs-comment">// &#123; name: &#x27;cat&#x27;, info: &#123; age: 4 &#125; &#125;</span><br></code></pre></td></tr></table></figure><h3 id="什么是深拷贝"><a href="#什么是深拷贝" class="headerlink" title="什么是深拷贝"></a>什么是深拷贝</h3><p><strong>不管数据对象有多少层，改变拷贝后的值都不会影响原始数据的值。（拷贝后的数据与原始数据毫无关系）</strong></p><p>常见深拷贝的方式：JSON.parse()  和  JSON.stringify()  配合使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-attr">info</span>: &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> &#125;, <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125; &#125;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1))<br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;cat&#x27;</span><br>obj2.<span class="hljs-property">info</span>.<span class="hljs-property">age</span> = <span class="hljs-number">4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1) <span class="hljs-comment">// &#123; name: &#x27;dog&#x27;, info: &#123; age: 3 &#125;, fn: function()&#123;&#125; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2) <span class="hljs-comment">// &#123; name: &#x27;cat&#x27;, info: &#123; age: 4 &#125; &#125;</span><br></code></pre></td></tr></table></figure><p>浅拷贝可以使用  Object.assign 或者<strong>遍历赋值</strong>的方式手动实现。</p><p>深拷贝可以通过JSON.stringify() 与 JSON.parse()实现，但对于对象有要求，因为在遇到函数，undefined，Sybmol，Date对象时会自动忽略，遇到正则时会返回空对象。也可以通过<strong>递归</strong>的方式手动实现深拷贝。</p><h3 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h3><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p><strong>Object.assign()</strong> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历赋值"><a href="#遍历赋值" class="headerlink" title="遍历赋值"></a>遍历赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br>    <br>    <span class="hljs-comment">// Object.keys不会遍历到原型链中的属性</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) &#123;<span class="hljs-comment">// for of 遍历元素值</span><br>cloneObj[key] = obj[key]<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br><br><br><span class="hljs-keyword">let</span> c1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>: &#123;<br>        <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>,<br>        <span class="hljs-attr">e</span>: <span class="hljs-number">5</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> d1 = <span class="hljs-title function_">clone</span>(c1)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c1, d1)<br><br>c1.<span class="hljs-property">c</span>.<span class="hljs-property">d</span> = <span class="hljs-number">12</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c1, d1)<br></code></pre></td></tr></table></figure><h3 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a><a href="https://juejin.cn/post/7072528644739956773#heading-15">深拷贝的实现</a></h3><h4 id="JSON-stringify-与-JSON-parse"><a href="#JSON-stringify-与-JSON-parse" class="headerlink" title="JSON.stringify() 与 JSON.parse()"></a>JSON.stringify() 与 JSON.parse()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><a href="https://juejin.cn/post/7113829141392130078">问题：</a></strong></p><ol><li>对象中的时间类型会被变成字符串类型数据</li><li>对象中的 undefined 和 函数类型会直接丢失</li><li>对象中的 NaN、Infinity、-Infinity 会变成 null</li><li>对象循环引用时会报错</li></ol><p>这些问题大部分源于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify()</a>，毕竟这个函数的初衷不是用来做拷贝的。当然，json.stringify 提供了第二个参数（为一个函数），对象中的每个值会递归交给函数处理，可以在该函数中判断类型做相应处理。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h5 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-comment">// 处理 null date reg 原始类型</span><br>    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj)<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> obj<br><br>    <span class="hljs-comment">// 处理对象和数组</span><br>    <span class="hljs-keyword">const</span> cloneObj = <span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)      <span class="hljs-comment">// 根据对象和数组自动生成</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) &#123;<br>        cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key])<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="稍微复杂版"><a href="#稍微复杂版" class="headerlink" title="稍微复杂版"></a>稍微复杂版</h5><ol><li>解决 symbol 无法作为键的问题</li></ol><p>Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组 等于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</p><ol start="2"><li>解决循环引用问题</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>&#125;<br>obj.<span class="hljs-property">b</span> = obj<br><br><span class="hljs-keyword">const</span> newObj = <span class="hljs-title function_">deepClone</span>(obj)<br></code></pre></td></tr></table></figure><p>报错：栈内存溢出，死循环了。</p><p>因为在递归遍历obj的属性时，obj有属性指向自身，因此会无限循环。</p><p>开辟新内存记录出现过的 obj，如果已经出现过就不再遍历，直接返回。</p><ol start="3"><li>解决垃圾回收问题</li></ol><p>使用 WeakMap，WeakMap是弱引用，不影响垃圾回收（WeakMap键指向的对象的其它引用被清除后，该对象会被垃圾回收）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>    <span class="hljs-comment">// 处理 null date reg 原始类型</span><br>    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj)<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> obj<br><br>    <span class="hljs-comment">// 解决循环引用问题</span><br>    <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj)             <span class="hljs-comment">// 说明 obj 在属性中出现过，再去遍历就会造成循环引用，因此直接返回hash中的记录</span><br><br>    <span class="hljs-comment">// 处理对象和数组</span><br>    <span class="hljs-keyword">const</span> cloneObj = <span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)      <span class="hljs-comment">// 根据对象和数组自动生成</span><br><br>    hash.<span class="hljs-title function_">set</span>(obj, cloneObj)                     <span class="hljs-comment">// 记录出现过的 obj</span><br><br>    <span class="hljs-comment">// Reflect.ownKeys 解决 Symbol 无法作为键的问题</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash)<br>    &#125;)<br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="日常开发"><a href="#日常开发" class="headerlink" title="日常开发"></a>日常开发</h3><p>日常开发中，如果要使用深拷贝，为了兼容各种边界情况，一般是使用三方库如 lodash</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-built_in">npm</span> i --save lodash<br><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span><br><span class="hljs-keyword">const</span> cloneObj = _.cloneDeep(obj)<br></code></pre></td></tr></table></figure><h3 id="structuredClone"><a href="#structuredClone" class="headerlink" title="structuredClone()"></a><a href="https://blog.csdn.net/songjungang/article/details/125373543">structuredClone()</a></h3><p>一个新的深拷贝API，ES 的一部分，目前兼容性还不够好。chrome &gt;&#x3D; 98才支持。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">structuredClone</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span><br></code></pre></td></tr></table></figure><p>这个函数有第二个参数 transferables，这个参数很少有用。详细信息，请参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone">MDN 页面structuredClone()</a></p><p><strong>缺陷：</strong></p><ol><li><strong>一些内置对象不能被复制，structuredClone()会抛出DOMException</strong></li></ol><p>Functions (ordinary functions, arrow functions, classes, methods)</p><p>DOM 节点DOM nodes</p><ol start="2"><li><strong>structuredClone()不会复制对象的原型链</strong></li></ol><p>如果structuredClone()与类实例一起使用，将获得一个普通对象作为返回值，因为结构化克隆会丢弃对象的原型链。</p><ol start="3"><li><strong>structuredClone()并不能复制DOM节点<a href="https://exploringjs.com/deep-js/ch_property-attributes-intro.html">特性属性</a>：</strong></li></ol><p>访问器 get 变成了数据属性。</p><p>在副本中，特性属性始终具有默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>深拷贝与浅拷贝</tag>
      
      <tag>手撕代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两栏布局/圣杯布局/双飞翼布局</title>
    <link href="/2022/06/11/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <url>/2022/06/11/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h1><p>HTML 结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-浮动-margin-left"><a href="#1-浮动-margin-left" class="headerlink" title="1.浮动 + margin-left"></a>1.浮动 + margin-left</h2><ol><li>左边元素宽度固定 ，设置浮动。右元素设置 <code>margin-left</code> 。因为右边元素的 <code>width</code> 默认为 <code>auto</code> ，所以会自动撑满父元素。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-绝对定位-margin-left"><a href="#2-绝对定位-margin-left" class="headerlink" title="2.绝对定位 + margin-left"></a>2.绝对定位 + margin-left</h2><p>绝对定位和浮动是一样的都是为了让左元素脱离标准流</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">position</span>: absolute;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-绝对定位-left"><a href="#3-绝对定位-left" class="headerlink" title="3.绝对定位 + left"></a>3.绝对定位 + left</h2><p>与上面不同在于，给右元素浮动定位，设置 left top right bottom（不可省略）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-flex"><a href="#4-flex" class="headerlink" title="4.flex"></a>4.flex</h2><p>左边元素固定宽度，右边的元素设置 <code>flex: 1</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: black;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: wheat;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h1><img src="/2022/06/11/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/image-20220122135020616.png" class="" title="image-20220122135020616"><h2 id="float-相对定位"><a href="#float-相对定位" class="headerlink" title="float + 相对定位"></a>float + 相对定位</h2><p>步骤：</p><p>1.设置基本样式</p><p>2.设置父元素container的padding，空出左右元素的位置</p><p>3.设置三个子元素左浮动，清除浮动</p><p>4.设置center的width:100%，单独站一行。此时left和right被挤到第二行</p><p>5.设置left和right的margin-left，将left和right放回第一行</p><p>6.设置<strong>子元素的相对定位</strong>，将left和right移动到合适的位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>头部<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>主区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>底部<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span>, <span class="hljs-selector-tag">footer</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">color</span>: wheat;<br>    <span class="hljs-attribute">text-align</span>: center;     <span class="hljs-comment">/* 水平居中 */</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;           <span class="hljs-comment">/* 盒子高度 */</span><br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">60px</span>;      <span class="hljs-comment">/* line-height是行高; line-height = height 单行文字垂直居中 */</span><br>&#125;<br><br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.center</span>, <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;     <span class="hljs-comment">/* 相对定位，将左右盒子移动到正确的位置 */</span><br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">left</span>: -<span class="hljs-number">200px</span>;           <span class="hljs-comment">/* 将左盒子移动到最左侧 */</span><br>    <span class="hljs-attribute">background-color</span>: green;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;     <span class="hljs-comment">/* 第二行移动到第一行 */</span><br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<span class="hljs-comment">/* 中间能够自适应的原因 */</span><br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">right</span>: -<span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">300px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;   <span class="hljs-comment">/* 空出放左盒子和右盒子的空间(上右下左) */</span><br>&#125;<br><br><span class="hljs-comment">/* 清除浮动，不然container盒子高度会变0 */</span><br><span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>步骤：</p><p>1.设置基本样式</p><p>2.给父元素container设置display:flex。三个div子元素会排列到一行</p><p>3.给center设置flex:1。会分配所有剩余的空间（一行中去除左右盒子的部分，也就实现了自适应）</p><p>4.给left设置order:-1，将其排到最左侧。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span>, <span class="hljs-selector-tag">footer</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">color</span>: wheat;<br>    <span class="hljs-attribute">text-align</span>: center;     <span class="hljs-comment">/* 水平居中 */</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;           <span class="hljs-comment">/* 盒子高度 */</span><br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">60px</span>;      <span class="hljs-comment">/* line-height是行高; line-height = height 单行文字垂直居中 */</span><br>&#125;<br><br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.center</span>, <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;        <span class="hljs-comment">/* 分配所有剩余的空间 */</span><br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: green;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;      <span class="hljs-comment">/* 数值越小排列越前 */</span><br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h1><p>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决 “中间栏div内容不被遮挡”问题的思路不一样。圣杯布局是利用了相对定位。</p><p>而双飞翼布局没有给父盒子加padding，而是给中间子盒子里面的内容套了层div，再给div加padding，这样左右两个盒子就会自己在最左侧和最右侧，而不需要再定位过去了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>头部<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>主区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 包裹一层div --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>底部<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span>, <span class="hljs-selector-tag">footer</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: black;<br>    <span class="hljs-attribute">color</span>: wheat;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">60px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.center</span>, <span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-comment">/* 不需要相对定位了 */</span><br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: green;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.content</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">300px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;   <span class="hljs-comment">/* 不是父盒子padding，而是center内容的div加padding */</span><br>&#125;<br><br><span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2022/06/10/Promise/"/>
    <url>/2022/06/10/Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Promise 是 JS 中进行异步编程的新解决方案（旧方案是单纯使用回调函数）</p><p>从语法上来说: Promise 是一个<strong>构造函数</strong></p><p>从功能上来说: promise 对象用来<strong>封装一个异步操作并可以获取其成功&#x2F;失败的结果值</strong></p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>pending</p><p>resolved&#x2F;fulfilled</p><p>rejected</p><p>无论变为成功还是失败, 都会有一个结果数据</p><p>成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><img src="/2022/06/10/Promise/image-20220610202339657.png" class="" title="image-20220610202339657"><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li><p><strong>指定回调函数更加灵活</strong>，原先需要在异步任务前指定。如今异步任务在new时写入，成功&#x2F;失败回调在then中绑定</p></li><li><p>支持<strong>链式调用</strong>，解决<strong>回调地狱</strong>问题</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.创建一个Promise实例</span><br><span class="hljs-comment">//2.Promise构造函数接收一个函数作为参数，函数的两个参数分别是resolve和reject。它们均是函数</span><br><span class="hljs-keyword">const</span> promise=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>     <span class="hljs-keyword">if</span>(操作是否成功)&#123;<br>          <span class="hljs-title function_">resolve</span>(value)<br>          <span class="hljs-comment">//3.当异步操作成功时，调用resolve()。状态发生改变（pending-&gt;fulfilled），并将结果作为参数传递出去</span><br>     &#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-title function_">reject</span>(error)<br>         <span class="hljs-comment">//4.当异步操作失败是，调用reject()。状态发生改变（pending-&gt;rejected），并将错误作为参数传递出去</span><br>     &#125;<br>&#125;)<br><span class="hljs-comment">//5.可以使用then方法指定resolved状态和rejected状态的回调函数.then方法接收两个回调函数作为参数（这俩个函数都是可选的）</span><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-comment">//6.状态变为resolved(在这里统一只指`fulfilled`状态)时调用，可使用传出的value</span><br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;<br>   <span class="hljs-comment">// 7.状态变为rejected时调用，可使用传出的error</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="实现一个简易的Promise"><a href="#实现一个简易的Promise" class="headerlink" title="实现一个简易的Promise"></a>实现一个简易的Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejct</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;成功&#x27;</span>) &#123;<br><span class="hljs-title function_">resolve</span>(value)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title function_">reject</span>(error)<br>&#125;<br>&#125;)<br>a.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(error)<br>&#125;)<br><br><span class="hljs-comment">// 实现</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">resolveCallbacks</span> = []<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectCallbacks</span> = []<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">resolveCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>())<br>&#125;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>())<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-title function_">executor</span>(resolve, reject)<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br><span class="hljs-title function_">reject</span>(e)<br>&#125;<br>&#125;<br><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br><span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br><span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>)<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">resolveCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>&#125;)<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>)<br>&#125;)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写API"><a href="#手写API" class="headerlink" title="手写API"></a>手写API</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><ol><li>Promise.all()接受一个promise的iterable类型</li><li>只有数组中全部的 Promise 都变为 resolve 的时候，返回一个成果结果的数组(按参数内的promise顺序排列，而不是promise完成的顺序)</li><li>只要有一个失败，状态就变成 rejected，将失败的那个结果给失败状态的回调函数</li><li>数组为空时会返回[]</li></ol><p><strong>使用例子</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 全部resolve, 输出数组</span><br><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);<br>&#125;, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(error)<br>&#125;);<br><span class="hljs-comment">// expected output: Array [3, 42, &quot;foo&quot;]</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">all</span> = <span class="hljs-function">(<span class="hljs-params">promises</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// 可迭代对象转数组</span><br><span class="hljs-keyword">let</span> promises = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(promises)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> n = promises.<span class="hljs-property">length</span><br><span class="hljs-comment">// 数组为空的情况</span><br><span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>([])<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">let</span> results = []<span class="hljs-comment">// 结果数组</span><br>            <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><span class="hljs-comment">// 记录多少个 promise 已完成</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">processData</span> = (<span class="hljs-params">value, i</span>) =&gt; &#123;<br>results[i] = value<br><span class="hljs-keyword">if</span> (index === n - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-title function_">resolve</span>(results)<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">const</span> curPromise = promises[i]<br><span class="hljs-comment">// 判断是否为 promise, 其实这样判断是不够的</span><br><span class="hljs-keyword">if</span> (curPromise <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>curPromise.<span class="hljs-title function_">then</span>(<br><span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-title function_">processData</span>(data, i),<br><span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">reject</span>(err)<br>                    )<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title function_">processData</span>(curPromise, i)<br>&#125;<br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p><p>数组为空时什么都不会返回</p><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;one&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;two&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1, promise2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>  <span class="hljs-comment">// Both resolve, but promise2 is faster</span><br>&#125;);<br><span class="hljs-comment">// expected output: &quot;two&quot;</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">race</span> = <span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = values[i]<br>            <span class="hljs-keyword">if</span> (current <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                current.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(res), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">reject</span>(err))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(current)<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>Promise.allSettled() 可用于并行执行独立的异步操作，并收集这些操作的结果。</p><p>该函数接受一个 promise 数组(通常是一个可迭代对象)作为参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> statusesPromise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises);<br></code></pre></td></tr></table></figure><p>当所有的输入 <code>promises</code> 都被 <code>fulfilled</code> 或 <code>rejected</code> 时，<code>statusesPromise</code> 会解析为一个具有它们状态的数组</p><ol><li><code>&#123; status: &#39;fulfilled&#39;, value: value &#125;</code> — 如果对应的 promise 已经 <code>fulfilled</code></li><li>或者 <code>&#123;status: &#39;rejected&#39;， reason: reason&#125;</code> 如果相应的 promise 已经被 <code>rejected</code></li></ol><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(reject, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>));<br><span class="hljs-keyword">const</span> promises = [promise1, promise2];<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises).<br>  <span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">status</span>)));<br><br><span class="hljs-comment">// expected output:</span><br><span class="hljs-comment">// &quot;fulfilled&quot;</span><br><span class="hljs-comment">// &quot;rejected&quot;</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">allSettled</span> = <span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> res = []<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">addData</span> = (<span class="hljs-params">status, value, i</span>) =&gt; &#123;<br>            res[i] = &#123;<br>                status,<br>                value<br>            &#125;<br>            count++<br>            <span class="hljs-keyword">if</span> (count === values.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(res)<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = values[i]<br>            <span class="hljs-keyword">if</span> (current <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                current.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, res, i), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>, err, i))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, current, i)<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><ul><li>如果有一个Promise成功，则返回这个成功结果</li><li>如果所有Promise都失败，则报错</li></ul><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);<br>&#125;);<br><span class="hljs-comment">// expected output: Array [3, 42, &quot;foo&quot;]</span><br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">any</span> = <span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = values[i]<br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(val), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                count++<br>                <span class="hljs-keyword">if</span> (count === values.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>))<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-控制并发数"><a href="#Promise-控制并发数" class="headerlink" title="Promise 控制并发数"></a>Promise 控制并发数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// values 是数组</span><br><span class="hljs-comment">// iteratorFn 是每个 promise 需要执行的异步操作。</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncPool</span>(<span class="hljs-params">values, limit, iteratorFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = []          <span class="hljs-comment">// 存放所有 promise 实例</span><br>    <span class="hljs-keyword">const</span> executing = []    <span class="hljs-comment">// 存放目前正在执行的 promise</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> values) &#123;<br>        <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">iteratorFn</span>(item))     <span class="hljs-comment">// 异步操作应当返回 promise, 包裹一层 Promise.resolve 避免返回的不是 promise</span><br>        res.<span class="hljs-title function_">push</span>(p)<br>        <span class="hljs-keyword">if</span> (limit &lt;= values.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">const</span> e = p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> executing.<span class="hljs-title function_">splice</span>(executing.<span class="hljs-title function_">indexOf</span>(e), <span class="hljs-number">1</span>))   <span class="hljs-comment">// 当这个promise状态变为fulfilled后，将其从正在执行的promise列表executing中删除</span><br>            executing.<span class="hljs-title function_">push</span>(e)<br>            <span class="hljs-keyword">if</span> (executing.<span class="hljs-property">length</span> &gt;= limit) &#123;<br>                <span class="hljs-comment">// 一旦正在执行的promise列表数量等于限制数，就使用Promise.race等待某一个promise状态发生变更，</span><br>                <span class="hljs-comment">// 状态变更后，就会执行上面then的回调，将该promise从executing中删除，</span><br>                <span class="hljs-comment">// 然后再进入到下一次for循环，生成新的promise进行补充</span><br>                <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(executing)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(res)<br>&#125;<br><br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">timeout</span> = (<span class="hljs-params">i</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;开始&#x27;</span>, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(i);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;结束&#x27;</span>, i);<br>    &#125;, i));<br>&#125;;<br><br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncPool</span>(<span class="hljs-number">2</span>, [<span class="hljs-number">1000</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">2000</span>], timeout);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>AJAX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异步编程</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入URL后浏览器发生了什么变化</title>
    <link href="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/"/>
    <url>/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="输入-url-后浏览器发生了什么变化"><a href="#输入-url-后浏览器发生了什么变化" class="headerlink" title="输入 url 后浏览器发生了什么变化"></a>输入 url 后浏览器发生了什么变化</h1><h2 id="步骤简单总结"><a href="#步骤简单总结" class="headerlink" title="步骤简单总结"></a>步骤简单总结</h2><ul><li><p><strong>网络请求</strong></p></li><li><ul><li><strong>DNS</strong> 查询（得到 IP），建立 TCP 连接（三次握手）</li><li>浏览器发送 HTTP 请求</li><li>收到请求响应，得到 HTML（解析 HTML 过程中，遇到静态资源还会继续发起网络请求）</li></ul></li><li><p><strong>解析</strong>（字符串 -&gt; 结构化数据）</p></li><li><ul><li>HTML 构建 <strong>DOM</strong> 树</li><li>CSS 构建 <strong>CSSOM</strong> 树</li><li>两者结合形成 <strong>render</strong> tree</li></ul></li><li><p><strong>渲染</strong></p></li><li><ul><li><strong>layout</strong> 计算布局：（文档流， 盒模型， 计算各个元素的大小、位置）</li><li><strong>paint</strong> 绘制：（将边框颜色、文字颜色、阴影等都画出来）</li><li>composite 合成：根据层叠关系显示画面</li><li>遇到 JS 执行</li><li>异步 CSS，图片加载，可能会触发重新渲染</li></ul></li></ul><h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>通过域名查找 IP 地址</p><h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><p>递归实现</p><p>先在<strong>本地计算机缓存</strong>查找，找不到再将请求发送给 dns 服务器</p><p>在<strong>本地 dns 服务器</strong>找</p><p>再到<strong>根域名服务器</strong>找</p><p>再到<strong>顶级域名服务器</strong>找</p><p>以 <a href="http://www.google.com/">www.google.com</a> 为例：</p><p>. -&gt; .com -&gt; google.com. -&gt; <a href="http://www.google.com/">www.google.com</a></p><h3 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h3><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>DNS缓存指DNS返回了正确的IP之后，系统就会将这个结果临时储存起来。并且它会为缓存设定一个失效时间 (例如N小时)，在这N小时之内，当你再次访问这个网站时，系统就会直接从你<strong>电脑本地的DNS缓存</strong>中把结果交还给你，而<strong>不必再去询问DNS服务器</strong>，变相“加速”了网址的解析。</p><h4 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h4><p>你访问大公司域名的时候，每次响应的并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问。DNS可以返回一个<strong>合适的机器的IP</strong>给用户，例如可以根据每台<strong>机器的负载量</strong>，该机器离用户<strong>地理位置</strong>的距离等等，这种过程就是DNS负载均衡。</p><h2 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h2><p>SYN(synchronous建立联机)</p><p>ACK(acknowledgement 确认)</p><p>FIN(finish结束)</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>在 TCP&#x2F;IP 协议中，TCP 协议提供可靠的连接服务，采用三次握手建立一个连接。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/20150603155505255.png" class="" title="img"> <p><strong>第一次握手</strong>：建立连接时，客户端发送 syn 包(syn&#x3D;j)到服务器，并进入 SYN_SEND 状态，等待服务器确认； </p><p><strong>第二次握手</strong>：服务器收到 syn 包，必须确认客户的 SYN（ack&#x3D;j+1），同时自己也发送一个 SYN 包（syn&#x3D;k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；<br><strong>第三次握手</strong>：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack&#x3D;k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/20150511164615901.jpeg" class="" title="img"> <p>通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。 <strong>三次握手的最主要目的是保证连接是双工的，可靠更多的是通过重传机制来保证的。</strong></p><p><strong>为什么是三次？</strong></p><p>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。 </p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。</p><p>那TCP 的四次握手，<strong>是为了保证通信双方都关闭了连接</strong>，具体过程如下：</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/20150603155803953.png" class="" title="img"> <p>1）客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送；<br>2）服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号；<br>3）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A；<br>4）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。</p><p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p><p>这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。<strong>但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了，但是你还可以给对方发送数据，也有这么种可能，你还有一些数据在传给对方的途中，所以你不能立马关闭连接</strong>,也即你可能还需要把在传输途中的数据给对方之后，又或者，你还有一些数据需要传输给对方后，（再关闭连接）再发送FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p><h3 id="TCP-x2F-UDP-的区别"><a href="#TCP-x2F-UDP-的区别" class="headerlink" title="TCP&#x2F;UDP 的区别"></a>TCP&#x2F;UDP 的区别</h3><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接，是指发送数据之前必须在两端建立TCP连接，连接方式为三次握手（打电话）</td><td>不面向连接（写信）</td></tr><tr><td>可靠传输，流量控制与拥塞控制</td><td>不可靠传输，尽最大努力交付</td></tr><tr><td>传输方式上以字节流的形式传输</td><td>以报文形式传输</td></tr><tr><td>只能是一对一通信</td><td>支持一对一、一对多、多对多、多对一交互通信</td></tr><tr><td>最小20字节，最多60字节</td><td>首部开销较小，只有 8 字节</td></tr><tr><td>适用于要求<strong>可靠传输</strong>的应用（传文件）</td><td><strong>适用于实时应用，如视频会议、直播等</strong>（丢几帧无所谓）</td></tr></tbody></table><p><strong>DNS使用什么协议传输？为什么？</strong></p><p>-  UDP 机制简单 开销小 性能更好</p><h2 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h2><h3 id="1-HTTP报文结构"><a href="#1-HTTP报文结构" class="headerlink" title="1. HTTP报文结构"></a>1. HTTP报文结构</h3><p>HTTP报文由<strong>报文首部</strong>和<strong>报文主体</strong>构成，中间由一个<strong>空行分隔</strong>。<strong>报文首部包含请求行和请求头部</strong>，报文主体主要包含被发送的信息。</p><p>报文首部是客户端或服务端需要处理请求或响应的内容及属性，可以传递额外的信息。</p><p>一个HTTP报文示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.enjoytoday.cn<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36<br>Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://www.enjoytoday.cn/posts/326<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, sdch<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8<br><br><span class="language-ini"><span class="hljs-attr">username</span>=hfcai&amp;sex=man</span><br></code></pre></td></tr></table></figure><h4 id="1-1-请求报文"><a href="#1-1-请求报文" class="headerlink" title="1-1. 请求报文"></a>1-1. 请求报文</h4><p>一个HTTP请求报文由<strong>请求行，请求头部，空行和请求数据</strong>4部分组成。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/278526F9CD532C9C14FBF3ADB9A2A930.png" class="" title="图片说明"> <p>请求行：三部分组成，方法 + URI + HTTP版本</p><p>请求头部：首部字段名和字段值构成，中间用 : 分隔。首部字段格式： 首部字段名:字段值</p><h4 id="1-2-响应报文"><a href="#1-2-响应报文" class="headerlink" title="1-2. 响应报文"></a>1-2. 响应报文</h4><p>HTTP响应报文由<strong>状态行、响应头部、空行和响应体</strong>4部分组成</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/FB5C81ED3A220004B71069645F112867.png" class="" title="图片说明"> <p>状态行：HTTP版本 + 状态码 + 响应短语</p><h3 id="2-HTTP首部字段"><a href="#2-HTTP首部字段" class="headerlink" title="2. HTTP首部字段"></a>2. HTTP首部字段</h3><p>给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等</p><h4 id="2-1-HTTP通用首部字段"><a href="#2-1-HTTP通用首部字段" class="headerlink" title="2-1. HTTP通用首部字段"></a>2-1. HTTP通用首部字段</h4><p>通用首部字段是请求报文和响应报文都会使用的字段，例如：</p><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td><strong>Date</strong></td><td>有</td><td></td><td>表示请求和响应生成的日期，GTM时间。例如 <code>Tue, 02 Mar 2021 12:31:25 GMT</code></td></tr><tr><td>Pragma</td><td>有</td><td></td><td>表示数据是否允许被缓存的通信选项</td></tr><tr><td><strong>Cache-Control</strong></td><td></td><td>有</td><td>控制缓存的相关信息<br />no-store表示不缓存<br />no-cache表示不缓存过期的资源</td></tr><tr><td><strong>Connection</strong></td><td></td><td>有</td><td>设置发送响应之后 TCP 连接是否继续保持<br />http1.1前需如下所示手动设置 Connection: Keep-Alive<br /><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606145754409.png" class="" title="img"></td></tr><tr><td>Transfer-Encoding</td><td></td><td>有</td><td>表示消息主体的编码格式</td></tr><tr><td>Via</td><td></td><td>有</td><td>记录途中经过的代理和网关</td></tr></tbody></table><h4 id="2-2-HTTP请求首部字段"><a href="#2-2-HTTP请求首部字段" class="headerlink" title="2-2. HTTP请求首部字段"></a>2-2. HTTP请求首部字段</h4><p>补充请求的附加信息、客户端信息、对相应内容相关的优先级</p><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td><strong>Host</strong></td><td></td><td>有</td><td>接受请求的服务器IP地址和端口号</td></tr><tr><td><strong>Accept</strong></td><td>有</td><td>有</td><td>客户端可支持的数据类型<br /><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606151327313.png" class="" title="img"><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606151859848-16548294901661.png" class="" title="img"></td></tr><tr><td>User-Agent</td><td>有</td><td>有</td><td></td></tr><tr><td><strong>If-Modified-Since</strong></td><td>有</td><td>有</td><td>UMT时间，表示该时间之后资源是否修改<br /><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606154802921.png" class="" title="img"></td></tr><tr><td><strong>If-None-Match</strong></td><td></td><td>有</td><td>返回服务器响应头的 Etag 值</td></tr><tr><td>Referer</td><td>有</td><td>有</td><td>通过点击超链接进入下一个页面时，在这里会记录上一个页面的 URI</td></tr><tr><td>Accept-Encoding</td><td>有</td><td>有</td><td>客户端可支持的编码格式<br />gzip&#x2F;compress&#x2F;deflate&#x2F;identify</td></tr><tr><td>Accept-Language</td><td>有</td><td>有</td><td>客户端可支持的语言（中文&#x2F;英文）</td></tr><tr><td><strong>If-Match</strong></td><td></td><td>有</td><td>If-xxx 条件请求  判断为真时，服务器才会执行请求<br />If-Match 和 ETag 值一致时，服务器才会接受请求</td></tr><tr><td>If-Unmodified-Since</td><td></td><td>有</td><td></td></tr><tr><td>Range</td><td></td><td>有</td><td>当只需要回去部分数据时，可通过这个字段指定要获取的数据范围</td></tr><tr><td>Authorization</td><td></td><td></td><td><br /><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606152828630.png" class="" title="img"></td></tr></tbody></table><h4 id="2-3-HTTP响应首部字段"><a href="#2-3-HTTP响应首部字段" class="headerlink" title="2-3. HTTP响应首部字段"></a>2-3. HTTP响应首部字段</h4><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td>Location</td><td>有</td><td>有</td><td>令客户端重定向至URI，绝对路径</td></tr><tr><td>Server</td><td>有</td><td>有</td><td>服务器程序的名称和版本号相关信息</td></tr></tbody></table><h4 id="2-4-HTTP实体（消息体）首部字段"><a href="#2-4-HTTP实体（消息体）首部字段" class="headerlink" title="2-4. HTTP实体（消息体）首部字段"></a>2-4. HTTP实体（消息体）首部字段</h4><table><thead><tr><th>通用头部字段</th><th>HTTP1.0</th><th>HTTP1.1</th><th>含义</th></tr></thead><tbody><tr><td>Allow</td><td>有</td><td>有</td><td>表示指定的 URI 支持的方法</td></tr><tr><td>Content-Encoding</td><td>有</td><td>有</td><td>消息的编码格式</td></tr><tr><td>Content-Length</td><td>有</td><td>有</td><td>消息体的长度</td></tr><tr><td>Content-Type</td><td>有</td><td>有</td><td>消息体的数据类型</td></tr><tr><td><strong>Expires</strong></td><td>有</td><td>有</td><td>消息体的有效期，UMT 时间</td></tr><tr><td><strong>Last-Modified</strong></td><td>有</td><td>有</td><td>数据最后更新的日期</td></tr><tr><td><strong>Etag</strong></td><td></td><td>有</td><td>资源的唯一标识符，控制是否使用缓存</td></tr></tbody></table><h3 id="3-HTTP方法"><a href="#3-HTTP方法" class="headerlink" title="3. HTTP方法"></a>3. HTTP方法</h3><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p><p>HTTP1.0 定义了三种请求方法：GET、POST 和 HEAD 方法</p><p>HTTP1.1 新增了六种方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>用于从服务器获取数据</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过响应中没有具体的内容，<strong>用户获取报头</strong></td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求。数据被包含在请求体中，POST请求可能导致新的资源的建立或已有资源的修改</td></tr><tr><td>PUT</td><td>客户端向服务器传送的数据取代指定的文档内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的资源</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>CONNECT</td><td>HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220606122333035.png" class="" title="img"><p><strong>GET与POST方法的区别：</strong></p><ol><li>get 是从指定的资源请求数据，post 是向指定的资源提交要处理的数据 </li><li>get 请求可以被缓存，post 请求不会被缓存 </li><li>get 请求传输的数据有长度限制，一般为 2048 字符，post 请求传输的数据没有大小限制 </li><li>get 请求的数据一般追加在 URL 的末尾，post 请求的数据在 http 请求体中</li></ol><p>一般不使用 GET 请求发送如密码这样的敏感信息。我认为 post 请求比 get请求更安全。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>304状态码是在协商缓存，缓存命中的时候服务器返回的，告诉客户端，服务器资源没有修改，可以使用客户端自己的缓存。</p><p>浏览器缓存分<strong>为本地缓存（强缓存）和协商缓存（弱缓存）</strong>。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/57B66CA5C634CC9645E63287A8BA90AC.png" class="" title="图片说明"> <p><strong>如上图所示，在浏览器第一次发出请求之后，需要再次发送请求的时候，浏览器首先获取该资源缓存的 header 信息，然后根据 Cache-Control 和 Expires 字段判断缓存是否过期。如果没有过期，直接使用浏览器缓存，并不会与服务器通信。该过程为判断是否使用强缓存，即本地缓存。</strong></p><ol><li><p><strong>Cache-Control</strong></p><p><strong>设置是否缓存与缓存时间等</strong>，通用字段，请求头和响应头中都有</p><p>该字段是 HTTP1.1 规范，一般利用该字段的 <strong>max-age</strong> 属性来判断，这个值是一个<strong>相对时间</strong>，单位为 s，代表资源的有效期。例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">Cache-Control:max-age=3600<br></code></pre></td></tr></table></figure><p>除此之外还有几个常用的值：</p><ul><li>no-cache：表示<strong>不使用强缓存</strong>，需要使用协商缓存 </li><li>no-store：禁止<strong>浏览器缓存数据</strong>，每次请求下载完整的资源 </li><li>public：可以被所有用户缓存，包括终端用户和中间代理服务器 </li><li>private：只能被终端用户的浏览器缓存</li></ul></li><li><p><strong>Expires</strong></p><p>该字段是 HTTP1.0 规范，他是一个<strong>绝对时间</strong>的 GMT 格式的时间字符串。例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">expires:Mar, 06 Apr 2020 10:57:09 GMT<br></code></pre></td></tr></table></figure><p>这个时间代表资源的失效时间，只要发送请求的时间在这之前，都会使用强缓存。</p><p>由于失效时间是一个绝对时间，因此当<strong>服务器时间与客户端时间偏差较大时，就会导致缓存混乱</strong>。</p></li></ol><p><strong>如果缓存过期，浏览器会向服务器发送请求，即 使用协商缓存。本次请求会带着第一次请求返回的有关缓存的 header 字段信息，比如以下两个字段：</strong>最后更新时间（<code>last-modified</code>）和文件标识（<code>ETag</code>）</p><p><strong>Etag&#x2F;If-None-Match</strong></p><p>判断响应头中是否存在 Etag 字段，如果存在，浏览器则发送一个带有 If-None-Match 字段的请求头的请求，该字段的值为 Etag 值。服务器通过对比客户端发过来的Etag值是否与服务器相同。如果相同，说明缓存命中，服务器返回 304 状态码，并将 If-None-Match 设为 false，客户端继续使用本地缓存。如果不相同，说明缓存未命中，服务器返回 200 状态码，并将 If-None-Match 设为 true，并且返回请求的数据。</p><p><strong>Last-Modified</strong>&#x2F;If-Modified-Since</p><p>除了 Etag 字段之外，客户端还会通过服务器返回的 Last-Modified 字段判断是否继续使用缓存，该字段为服务器返回的资源的最后修改时间，为UMT时间。浏览器发送一个带有 If-Modified-Since 字段的请求头的请求给服务器，该字段的值为 Last-Modified 值。服务器收到之后，通过这个时间判断，在该时间之后，资源有无修改，如果未修改，缓存命中，返回 304 状态码；如果未命中，返回 200 状态码，并返回最新的内容。</p><p>Etag和Last-Modified是服务器响应头里的；请求头里会加上If-None-Match和If-Modified-Since给服务器用于判断是否采用协商缓存</p><p><strong>Cache-Control 与 Expires 的优先级：</strong></p><p>两者可以在服务端配置同时使用，<strong>Cache-Control 的优先级高于 Expires。</strong></p><p><strong>Last-Modified&#x2F;If-Modified-Since 已经可以判断缓存是否失效了，为什么出现 Etag&#x2F;If-None-Match?</strong></p><p>Etag&#x2F;If-None-Match 是实体标签，是一个资源的唯一标识符，资源的变化都会导致 ETag 的变化。出现 Etag 的主要原因是解决 Last-Modified 比较难解决的问题：</p><ul><li>一些文件也许会周期性的修改，但是他的内容并不发生改变，这个时候我们并不希望客户端认为这个文件修改了 </li><li>某些文件在秒以下的时间内进行修改了，If-Modified-Since无法判断。UNIX时间只能精确到秒</li></ul><p>Last-Modified 和 Etag 可以一起使用， <strong>Etag 的优先级更高</strong>。</p><p><strong>E-tag 的缺点</strong></p><p>服务器需要计算Etag，会有性能损失</p><p>不同操作系统，web服务器对于ETag的计算方法也不同，当使用不同操作系统，不同类型的web服务器做负载均衡的时候，如果用ETag作为判断条件，在被负载均衡到不同服务器后，则很容易导致缓存失效。</p><p><strong>刷新页面的问题：</strong></p><p>F5刷新：不使用强缓存，使用协商缓存</p><p>ctrl+F5：二者都不使用</p><h2 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h2><h3 id="浏览器渲染步骤"><a href="#浏览器渲染步骤" class="headerlink" title="浏览器渲染步骤"></a>浏览器渲染步骤</h3><p> （1）首先解析收到的文档（HTML文件），根据文档定义<strong>构建一棵 DOM 树</strong>，DOM 树是由 DOM 元素及属性节点组成的。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115170857468.png" class="" title="img"><p> （2）然后对 CSS 进行解析，<strong>生成 CSSOM 规则树</strong>。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171024474.png" class="" title="img"><p> （3）根据 DOM 树和 CSSOM 规则树<strong>构建渲染树</strong>。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171208070.png" class="" title="img"><p> （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会<strong>根据渲染树来进行布局</strong>（也可以叫做<strong>回流</strong>）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171453541.png" class="" title="img"><p> （5）<strong>布局阶段结束后是绘制阶段</strong>，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</p><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是<strong>解析完一部分内容就显示一部分内容</strong>，同时，可能还在通过网络下载其余内容。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220115171612862.png" class="" title="img"><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><h4 id="阻塞关系"><a href="#阻塞关系" class="headerlink" title="阻塞关系"></a>阻塞关系</h4><ul><li><p>CSS </p></li><li><ul><li><strong>CSS 不会阻塞 HTML 的解析</strong>，解析 HTML 和解析 CSS 是并行的；</li><li>页面渲染依照 CSS Tree +DOM Tree 合成 Render Tree，因此 <strong>CSS 会阻塞页面的渲染</strong></li><li><strong>CSS 下载解析会阻塞 JS 执行</strong>，JS 需要读取 CSS 的结果</li></ul></li><li><p><strong>JS 会阻塞 HTML 解析</strong>：</p></li><li><ul><li>JS 可能会修改 DOM，需要阻塞 HTML 的解析</li><li>JS 执行线程是单独的线程，和浏览器解析渲染线程互斥</li></ul></li></ul><p>解析页面过程中如果遇到一个 script 标签，会停止 HTML 解析，去下载 script 脚本，下载完毕之后立即执行脚本，然后接着解析 HTML，所以如果 script 下载速度很慢，会造成页面<strong>白屏</strong>。因此我们常常<strong>把 script 标签放到 body 底部</strong>。当然在当下，并不是说 script 标签必须放在底部，因为你可以<strong>给 script 标签添加 defer 或者 async 属性</strong>。</p><h4 id="async-和-defer-的作用是什么？有什么区别？"><a href="#async-和-defer-的作用是什么？有什么区别？" class="headerlink" title="async 和 defer 的作用是什么？有什么区别？"></a><strong>async 和 defer 的作用是什么？有什么区别？</strong></h4><p>script ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</p><p>async script ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</p><p>defer script ：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/image-20220611161332407.png" class=""><h3 id="渲染页面时常见哪些不良现象？"><a href="#渲染页面时常见哪些不良现象？" class="headerlink" title="渲染页面时常见哪些不良现象？"></a>渲染页面时常见哪些不良现象？</h3><p>FOUC：主要指的是<strong>样式闪烁</strong>的问题，由于浏览器渲染机制（比如firefox），<strong>在 CSS 加载之前，先呈现了 HTML</strong>，就会导致展示出<strong>无样式</strong>内容，然后<strong>样式突然呈现</strong>的现象。会出现这个问题的原因主要是 <strong>css 加载时间过长，或者 css 被放在了文档底部</strong>。</p><p><strong>白屏</strong>：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 <strong>CSS 部分放在 HTML 尾部</strong>，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 <strong>js 文件放在头部</strong>，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</p><h3 id="浏览器的绘制过程"><a href="#浏览器的绘制过程" class="headerlink" title="浏览器的绘制过程"></a>浏览器的绘制过程</h3><h4 id="什么是重绘和回流（重拍）？"><a href="#什么是重绘和回流（重拍）？" class="headerlink" title="什么是重绘和回流（重拍）？"></a>什么是重绘和回流（重拍）？</h4><p><strong>重绘</strong>: 当渲染树中的一些元素需要更新属性，而这些属性<strong>只是影响元素的外观、风格，而不会影响布局</strong>的操作，比如 background-color，我们将这样的操作称为重绘。</p><p><strong>回流</strong>：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会<strong>影响到布局的操作</strong>，这样<br>的操作我们称为回流。</p><p><strong>常见引起回流属性和方法：</strong></p><p><strong>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</strong></p><p> （1）添加或者删除可见的 DOM 元素；<br> （2）元素尺寸改变——边距、填充、边框、宽度和高度<br> （3）内容变化，比如用户在 input 框中输入文字<br> （4）浏览器窗口尺寸改变——resize事件发生时<br> （5）计算 offsetWidth 和 offsetHeight 属性<br> （6）设置 style 属性的值<br> （7）当你修改网页的默认字体时。</p><p><strong>回流必定会发生重绘，重绘不一定会引发回流</strong>。回流的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><p><strong>常见引起重绘属性和方法：</strong></p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/68747470733a2f2f636176737a686f75796f752d313235343039333639372e636f732e61702d63686f6e6771696e672e6d7971636c6f75642e636f6d2f6e6f74652d31342e706e67.png" class="" title="常见引起回流属性和方法"><p><strong>常见引起回流属性和方法：</strong></p><img src="/2022/06/10/%E8%BE%93%E5%85%A5url%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96/68747470733a2f2f636176737a686f75796f752d313235343039333639372e636f732e61702d63686f6e6771696e672e6d7971636c6f75642e636f6d2f6e6f74652d31332e706e67.png" class="" title="常见引起重绘属性和方法"><h4 id="如何减少回流？"><a href="#如何减少回流？" class="headerlink" title="如何减少回流？"></a>如何减少回流？</h4><ol><li><p><strong>最小化重绘和重排</strong>，比如<strong>样式集中改变</strong>，使用添加新样式类名 <code>.class</code> 或 <code>cssText</code> 。</p></li><li><p><strong>批量操作 DOM</strong>，比如读取某元素 <code>offsetWidth</code> 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。</p></li><li><p><strong>使用  absolute 或 fixed 使元素脱离文档流</strong>，这在制作复杂的动画时对性能的影响比较明显。</p></li><li><p><strong>开启 GPU 加速</strong>，利用 css 属性 <code>transform</code> 、<code>will-change</code> 等，比如改变元素位置，我们使用 <code>translate</code> 会比使用绝对定位改变其 <code>left</code> 、<code>top</code> 等来的高效，因为它不会触发重排或重绘，<code>transform</code> 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。</p></li><li><p><strong>opacity替代visibility</strong>： 前者回流重绘都不会触发(前提是它单独在一个图层)，后者两个都会触发。</p></li></ol><h4 id="为什么操作-DOM-慢？"><a href="#为什么操作-DOM-慢？" class="headerlink" title="为什么操作 DOM 慢？"></a>为什么操作 DOM 慢？</h4><p>一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</p><p>DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。</p><h2 id="JS-解析"><a href="#JS-解析" class="headerlink" title="JS 解析"></a>JS 解析</h2><p>事件循环，放在 JS 部分里</p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>DNS</tag>
      
      <tag>TCP/UDP</tag>
      
      <tag>缓存</tag>
      
      <tag>浏览器解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
